// this file was generated by regz: https://github.com/ZigEmbeddedGroup/regz
// commit: 644b9d6f61ba1e49d90e4f606f82727f3d6581f2
//
// vendor: Raspberry Pi
// device: RP2040
// cpu: CM0PLUS

pub const VectorTable = extern struct {
    initial_stack_pointer: u32,
    Reset: InterruptVector = unhandled,
    NMI: InterruptVector = unhandled,
    HardFault: InterruptVector = unhandled,
    reserved0: [7]u32 = undefined,
    SVCall: InterruptVector = unhandled,
    reserved1: [2]u32 = undefined,
    PendSV: InterruptVector = unhandled,
    SysTick: InterruptVector = unhandled,
    TIMER_IRQ_0: InterruptVector = unhandled,
    TIMER_IRQ_1: InterruptVector = unhandled,
    TIMER_IRQ_2: InterruptVector = unhandled,
    TIMER_IRQ_3: InterruptVector = unhandled,
    PWM_IRQ_WRAP: InterruptVector = unhandled,
    USBCTRL_IRQ: InterruptVector = unhandled,
    XIP_IRQ: InterruptVector = unhandled,
    PIO0_IRQ_0: InterruptVector = unhandled,
    PIO0_IRQ_1: InterruptVector = unhandled,
    PIO1_IRQ_0: InterruptVector = unhandled,
    PIO1_IRQ_1: InterruptVector = unhandled,
    DMA_IRQ_0: InterruptVector = unhandled,
    DMA_IRQ_1: InterruptVector = unhandled,
    IO_IRQ_BANK0: InterruptVector = unhandled,
    IO_IRQ_QSPI: InterruptVector = unhandled,
    SIO_IRQ_PROC0: InterruptVector = unhandled,
    SIO_IRQ_PROC1: InterruptVector = unhandled,
    CLOCKS_IRQ: InterruptVector = unhandled,
    SPI0_IRQ: InterruptVector = unhandled,
    SPI1_IRQ: InterruptVector = unhandled,
    UART0_IRQ: InterruptVector = unhandled,
    UART1_IRQ: InterruptVector = unhandled,
    ADC_IRQ_FIFO: InterruptVector = unhandled,
    I2C0_IRQ: InterruptVector = unhandled,
    I2C1_IRQ: InterruptVector = unhandled,
    RTC_IRQ: InterruptVector = unhandled,
};

pub const registers = struct {
    /// System Control Space
    pub const SCS = struct {
        pub const base_address = 0xe000e000;

        /// System Tick Timer
        pub const SysTick = struct {
            /// address: 0xe000e010
            /// SysTick Control and Status Register
            pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                ENABLE: u1,
                TICKINT: u1,
                CLKSOURCE: u1,
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                reserved6: u1 = 0,
                reserved7: u1 = 0,
                reserved8: u1 = 0,
                reserved9: u1 = 0,
                reserved10: u1 = 0,
                reserved11: u1 = 0,
                reserved12: u1 = 0,
                COUNTFLAG: u1,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
                padding6: u1 = 0,
                padding7: u1 = 0,
                padding8: u1 = 0,
                padding9: u1 = 0,
                padding10: u1 = 0,
                padding11: u1 = 0,
                padding12: u1 = 0,
                padding13: u1 = 0,
                padding14: u1 = 0,
            }), base_address + 0x10);

            /// address: 0xe000e014
            /// SysTick Reload Value Register
            pub const LOAD = @intToPtr(*volatile Mmio(32, packed struct {
                RELOAD: u24,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
                padding6: u1 = 0,
                padding7: u1 = 0,
            }), base_address + 0x14);

            /// address: 0xe000e018
            /// SysTick Current Value Register
            pub const VAL = @intToPtr(*volatile Mmio(32, packed struct {
                CURRENT: u24,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
                padding6: u1 = 0,
                padding7: u1 = 0,
            }), base_address + 0x18);

            /// address: 0xe000e01c
            /// SysTick Calibration Register
            pub const CALIB = @intToPtr(*volatile Mmio(32, packed struct {
                TENMS: u24,
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                SKEW: u1,
                NOREF: u1,
            }), base_address + 0x1c);
        };

        /// Nested Vectored Interrupt Controller
        pub const NVIC = struct {
            /// address: 0xe000e100
            /// Interrupt Set Enable Register
            pub const ISER = @intToPtr(*volatile Mmio(32, packed struct {
                TIMER_IRQ_0: u1,
                TIMER_IRQ_1: u1,
                TIMER_IRQ_2: u1,
                TIMER_IRQ_3: u1,
                PWM_IRQ_WRAP: u1,
                USBCTRL_IRQ: u1,
                XIP_IRQ: u1,
                PIO0_IRQ_0: u1,
                PIO0_IRQ_1: u1,
                PIO1_IRQ_0: u1,
                PIO1_IRQ_1: u1,
                DMA_IRQ_0: u1,
                DMA_IRQ_1: u1,
                IO_IRQ_BANK0: u1,
                IO_IRQ_QSPI: u1,
                SIO_IRQ_PROC0: u1,
                SIO_IRQ_PROC1: u1,
                CLOCKS_IRQ: u1,
                SPI0_IRQ: u1,
                SPI1_IRQ: u1,
                UART0_IRQ: u1,
                UART1_IRQ: u1,
                ADC_IRQ_FIFO: u1,
                I2C0_IRQ: u1,
                I2C1_IRQ: u1,
                RTC_IRQ: u1,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
            }), base_address + 0x100);

            /// address: 0xe000e180
            /// Interrupt Clear Enable Register
            pub const ICER = @intToPtr(*volatile Mmio(32, packed struct {
                TIMER_IRQ_0: u1,
                TIMER_IRQ_1: u1,
                TIMER_IRQ_2: u1,
                TIMER_IRQ_3: u1,
                PWM_IRQ_WRAP: u1,
                USBCTRL_IRQ: u1,
                XIP_IRQ: u1,
                PIO0_IRQ_0: u1,
                PIO0_IRQ_1: u1,
                PIO1_IRQ_0: u1,
                PIO1_IRQ_1: u1,
                DMA_IRQ_0: u1,
                DMA_IRQ_1: u1,
                IO_IRQ_BANK0: u1,
                IO_IRQ_QSPI: u1,
                SIO_IRQ_PROC0: u1,
                SIO_IRQ_PROC1: u1,
                CLOCKS_IRQ: u1,
                SPI0_IRQ: u1,
                SPI1_IRQ: u1,
                UART0_IRQ: u1,
                UART1_IRQ: u1,
                ADC_IRQ_FIFO: u1,
                I2C0_IRQ: u1,
                I2C1_IRQ: u1,
                RTC_IRQ: u1,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
            }), base_address + 0x180);

            /// address: 0xe000e200
            /// Interrupt Set Pending Register
            pub const ISPR = @intToPtr(*volatile Mmio(32, packed struct {
                TIMER_IRQ_0: u1,
                TIMER_IRQ_1: u1,
                TIMER_IRQ_2: u1,
                TIMER_IRQ_3: u1,
                PWM_IRQ_WRAP: u1,
                USBCTRL_IRQ: u1,
                XIP_IRQ: u1,
                PIO0_IRQ_0: u1,
                PIO0_IRQ_1: u1,
                PIO1_IRQ_0: u1,
                PIO1_IRQ_1: u1,
                DMA_IRQ_0: u1,
                DMA_IRQ_1: u1,
                IO_IRQ_BANK0: u1,
                IO_IRQ_QSPI: u1,
                SIO_IRQ_PROC0: u1,
                SIO_IRQ_PROC1: u1,
                CLOCKS_IRQ: u1,
                SPI0_IRQ: u1,
                SPI1_IRQ: u1,
                UART0_IRQ: u1,
                UART1_IRQ: u1,
                ADC_IRQ_FIFO: u1,
                I2C0_IRQ: u1,
                I2C1_IRQ: u1,
                RTC_IRQ: u1,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
            }), base_address + 0x200);

            /// address: 0xe000e280
            /// Interrupt Clear Pending Register
            pub const ICPR = @intToPtr(*volatile Mmio(32, packed struct {
                TIMER_IRQ_0: u1,
                TIMER_IRQ_1: u1,
                TIMER_IRQ_2: u1,
                TIMER_IRQ_3: u1,
                PWM_IRQ_WRAP: u1,
                USBCTRL_IRQ: u1,
                XIP_IRQ: u1,
                PIO0_IRQ_0: u1,
                PIO0_IRQ_1: u1,
                PIO1_IRQ_0: u1,
                PIO1_IRQ_1: u1,
                DMA_IRQ_0: u1,
                DMA_IRQ_1: u1,
                IO_IRQ_BANK0: u1,
                IO_IRQ_QSPI: u1,
                SIO_IRQ_PROC0: u1,
                SIO_IRQ_PROC1: u1,
                CLOCKS_IRQ: u1,
                SPI0_IRQ: u1,
                SPI1_IRQ: u1,
                UART0_IRQ: u1,
                UART1_IRQ: u1,
                ADC_IRQ_FIFO: u1,
                I2C0_IRQ: u1,
                I2C1_IRQ: u1,
                RTC_IRQ: u1,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
            }), base_address + 0x280);

            /// address: 0xe000e400
            /// Interrupt Priority Register
            pub const IP0 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                TIMER_IRQ_0: u2,
                reserved6: u1 = 0,
                reserved7: u1 = 0,
                reserved8: u1 = 0,
                reserved9: u1 = 0,
                reserved10: u1 = 0,
                reserved11: u1 = 0,
                TIMER_IRQ_1: u2,
                reserved12: u1 = 0,
                reserved13: u1 = 0,
                reserved14: u1 = 0,
                reserved15: u1 = 0,
                reserved16: u1 = 0,
                reserved17: u1 = 0,
                TIMER_IRQ_2: u2,
                reserved18: u1 = 0,
                reserved19: u1 = 0,
                reserved20: u1 = 0,
                reserved21: u1 = 0,
                reserved22: u1 = 0,
                reserved23: u1 = 0,
                TIMER_IRQ_3: u2,
            }), base_address + 0x400);

            /// address: 0xe000e404
            /// Interrupt Priority Register
            pub const IP1 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                PWM_IRQ_WRAP: u2,
                reserved6: u1 = 0,
                reserved7: u1 = 0,
                reserved8: u1 = 0,
                reserved9: u1 = 0,
                reserved10: u1 = 0,
                reserved11: u1 = 0,
                USBCTRL_IRQ: u2,
                reserved12: u1 = 0,
                reserved13: u1 = 0,
                reserved14: u1 = 0,
                reserved15: u1 = 0,
                reserved16: u1 = 0,
                reserved17: u1 = 0,
                XIP_IRQ: u2,
                reserved18: u1 = 0,
                reserved19: u1 = 0,
                reserved20: u1 = 0,
                reserved21: u1 = 0,
                reserved22: u1 = 0,
                reserved23: u1 = 0,
                PIO0_IRQ_0: u2,
            }), base_address + 0x404);

            /// address: 0xe000e408
            /// Interrupt Priority Register
            pub const IP2 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                PIO0_IRQ_1: u2,
                reserved6: u1 = 0,
                reserved7: u1 = 0,
                reserved8: u1 = 0,
                reserved9: u1 = 0,
                reserved10: u1 = 0,
                reserved11: u1 = 0,
                PIO1_IRQ_0: u2,
                reserved12: u1 = 0,
                reserved13: u1 = 0,
                reserved14: u1 = 0,
                reserved15: u1 = 0,
                reserved16: u1 = 0,
                reserved17: u1 = 0,
                PIO1_IRQ_1: u2,
                reserved18: u1 = 0,
                reserved19: u1 = 0,
                reserved20: u1 = 0,
                reserved21: u1 = 0,
                reserved22: u1 = 0,
                reserved23: u1 = 0,
                DMA_IRQ_0: u2,
            }), base_address + 0x408);

            /// address: 0xe000e40c
            /// Interrupt Priority Register
            pub const IP3 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                DMA_IRQ_1: u2,
                reserved6: u1 = 0,
                reserved7: u1 = 0,
                reserved8: u1 = 0,
                reserved9: u1 = 0,
                reserved10: u1 = 0,
                reserved11: u1 = 0,
                IO_IRQ_BANK0: u2,
                reserved12: u1 = 0,
                reserved13: u1 = 0,
                reserved14: u1 = 0,
                reserved15: u1 = 0,
                reserved16: u1 = 0,
                reserved17: u1 = 0,
                IO_IRQ_QSPI: u2,
                reserved18: u1 = 0,
                reserved19: u1 = 0,
                reserved20: u1 = 0,
                reserved21: u1 = 0,
                reserved22: u1 = 0,
                reserved23: u1 = 0,
                SIO_IRQ_PROC0: u2,
            }), base_address + 0x40c);

            /// address: 0xe000e410
            /// Interrupt Priority Register
            pub const IP4 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                SIO_IRQ_PROC1: u2,
                reserved6: u1 = 0,
                reserved7: u1 = 0,
                reserved8: u1 = 0,
                reserved9: u1 = 0,
                reserved10: u1 = 0,
                reserved11: u1 = 0,
                CLOCKS_IRQ: u2,
                reserved12: u1 = 0,
                reserved13: u1 = 0,
                reserved14: u1 = 0,
                reserved15: u1 = 0,
                reserved16: u1 = 0,
                reserved17: u1 = 0,
                SPI0_IRQ: u2,
                reserved18: u1 = 0,
                reserved19: u1 = 0,
                reserved20: u1 = 0,
                reserved21: u1 = 0,
                reserved22: u1 = 0,
                reserved23: u1 = 0,
                SPI1_IRQ: u2,
            }), base_address + 0x410);

            /// address: 0xe000e414
            /// Interrupt Priority Register
            pub const IP5 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                UART0_IRQ: u2,
                reserved6: u1 = 0,
                reserved7: u1 = 0,
                reserved8: u1 = 0,
                reserved9: u1 = 0,
                reserved10: u1 = 0,
                reserved11: u1 = 0,
                UART1_IRQ: u2,
                reserved12: u1 = 0,
                reserved13: u1 = 0,
                reserved14: u1 = 0,
                reserved15: u1 = 0,
                reserved16: u1 = 0,
                reserved17: u1 = 0,
                ADC_IRQ_FIFO: u2,
                reserved18: u1 = 0,
                reserved19: u1 = 0,
                reserved20: u1 = 0,
                reserved21: u1 = 0,
                reserved22: u1 = 0,
                reserved23: u1 = 0,
                I2C0_IRQ: u2,
            }), base_address + 0x414);

            /// address: 0xe000e418
            /// Interrupt Priority Register
            pub const IP6 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                I2C1_IRQ: u2,
                reserved6: u1 = 0,
                reserved7: u1 = 0,
                reserved8: u1 = 0,
                reserved9: u1 = 0,
                reserved10: u1 = 0,
                reserved11: u1 = 0,
                RTC_IRQ: u2,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
                padding6: u1 = 0,
                padding7: u1 = 0,
                padding8: u1 = 0,
                padding9: u1 = 0,
                padding10: u1 = 0,
                padding11: u1 = 0,
                padding12: u1 = 0,
                padding13: u1 = 0,
                padding14: u1 = 0,
                padding15: u1 = 0,
            }), base_address + 0x418);

            /// address: 0xe000e41c
            /// Interrupt Priority Register
            pub const IP7 = @intToPtr(*volatile u32, base_address + 0x41c);
        };

        /// System Control Block
        pub const SCB = struct {
            /// address: 0xe000ed00
            pub const CPUID = @intToPtr(*volatile Mmio(32, packed struct {
                REVISION: u4,
                PARTNO: u12,
                ARCHITECTURE: u4,
                VARIANT: u4,
                IMPLEMENTER: u8,
            }), base_address + 0xd00);

            /// address: 0xe000ed04
            /// Interrupt Control and State Register
            pub const ICSR = @intToPtr(*volatile Mmio(32, packed struct {
                VECTACTIVE: u9,
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                VECTPENDING: u9,
                reserved3: u1 = 0,
                ISRPENDING: u1,
                ISRPREEMPT: u1,
                reserved4: u1 = 0,
                PENDSTCLR: u1,
                PENDSTSET: u1,
                PENDSVCLR: u1,
                PENDSVSET: u1,
                reserved5: u1 = 0,
                reserved6: u1 = 0,
                NMIPENDSET: u1,
            }), base_address + 0xd04);

            /// address: 0xe000ed0c
            /// Application Interrupt and Reset Control Register
            pub const AIRCR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1 = 0,
                VECTCLRACTIVE: u1,
                SYSRESETREQ: u1,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                reserved6: u1 = 0,
                reserved7: u1 = 0,
                reserved8: u1 = 0,
                reserved9: u1 = 0,
                reserved10: u1 = 0,
                reserved11: u1 = 0,
                reserved12: u1 = 0,
                ENDIANESS: u1,
                VECTKEY: u16,
            }), base_address + 0xd0c);

            /// address: 0xe000ed10
            /// System Control Register
            pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1 = 0,
                SLEEPONEXIT: u1,
                SLEEPDEEP: u1,
                reserved1: u1 = 0,
                SEVONPEND: u1,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
                padding6: u1 = 0,
                padding7: u1 = 0,
                padding8: u1 = 0,
                padding9: u1 = 0,
                padding10: u1 = 0,
                padding11: u1 = 0,
                padding12: u1 = 0,
                padding13: u1 = 0,
                padding14: u1 = 0,
                padding15: u1 = 0,
                padding16: u1 = 0,
                padding17: u1 = 0,
                padding18: u1 = 0,
                padding19: u1 = 0,
                padding20: u1 = 0,
                padding21: u1 = 0,
                padding22: u1 = 0,
                padding23: u1 = 0,
                padding24: u1 = 0,
                padding25: u1 = 0,
                padding26: u1 = 0,
            }), base_address + 0xd10);

            /// address: 0xe000ed14
            /// Configuration Control Register
            pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                UNALIGN_TRP: u1,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                reserved6: u1 = 0,
                reserved7: u1 = 0,
                STKALIGN: u1,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
                padding6: u1 = 0,
                padding7: u1 = 0,
                padding8: u1 = 0,
                padding9: u1 = 0,
                padding10: u1 = 0,
                padding11: u1 = 0,
                padding12: u1 = 0,
                padding13: u1 = 0,
                padding14: u1 = 0,
                padding15: u1 = 0,
                padding16: u1 = 0,
                padding17: u1 = 0,
                padding18: u1 = 0,
                padding19: u1 = 0,
                padding20: u1 = 0,
                padding21: u1 = 0,
            }), base_address + 0xd14);

            /// address: 0xe000ed1c
            /// System Handlers Priority Registers. [0] is RESERVED
            pub const SHP = @intToPtr(*volatile u32, base_address + 0xd1c);

            /// address: 0xe000ed24
            /// System Handler Control and State Register
            pub const SHCSR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                reserved6: u1 = 0,
                reserved7: u1 = 0,
                reserved8: u1 = 0,
                reserved9: u1 = 0,
                reserved10: u1 = 0,
                reserved11: u1 = 0,
                reserved12: u1 = 0,
                reserved13: u1 = 0,
                reserved14: u1 = 0,
                SVCALLPENDED: u1,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
                padding6: u1 = 0,
                padding7: u1 = 0,
                padding8: u1 = 0,
                padding9: u1 = 0,
                padding10: u1 = 0,
                padding11: u1 = 0,
                padding12: u1 = 0,
                padding13: u1 = 0,
                padding14: u1 = 0,
                padding15: u1 = 0,
            }), base_address + 0xd24);

            /// address: 0xe000ed08
            /// Vector Table Offset Register
            pub const VTOR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                reserved6: u1 = 0,
                reserved7: u1 = 0,
                TBLOFF: u24,
            }), base_address + 0xd08);
        };

        /// Memory Protection Unit
        pub const MPU = struct {
            /// address: 0xe000ed90
            /// MPU Type Register
            pub const TYPE = @intToPtr(*volatile Mmio(32, packed struct {
                SEPARATE: u1,
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                reserved4: u1 = 0,
                reserved5: u1 = 0,
                reserved6: u1 = 0,
                DREGION: u8,
                IREGION: u8,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
                padding6: u1 = 0,
                padding7: u1 = 0,
            }), base_address + 0xd90);

            /// address: 0xe000ed94
            /// MPU Control Register
            pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                ENABLE: u1,
                HFNMIENA: u1,
                PRIVDEFENA: u1,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
                padding6: u1 = 0,
                padding7: u1 = 0,
                padding8: u1 = 0,
                padding9: u1 = 0,
                padding10: u1 = 0,
                padding11: u1 = 0,
                padding12: u1 = 0,
                padding13: u1 = 0,
                padding14: u1 = 0,
                padding15: u1 = 0,
                padding16: u1 = 0,
                padding17: u1 = 0,
                padding18: u1 = 0,
                padding19: u1 = 0,
                padding20: u1 = 0,
                padding21: u1 = 0,
                padding22: u1 = 0,
                padding23: u1 = 0,
                padding24: u1 = 0,
                padding25: u1 = 0,
                padding26: u1 = 0,
                padding27: u1 = 0,
                padding28: u1 = 0,
            }), base_address + 0xd94);

            /// address: 0xe000ed98
            /// MPU Region RNRber Register
            pub const RNR = @intToPtr(*volatile Mmio(32, packed struct {
                REGION: u8,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
                padding3: u1 = 0,
                padding4: u1 = 0,
                padding5: u1 = 0,
                padding6: u1 = 0,
                padding7: u1 = 0,
                padding8: u1 = 0,
                padding9: u1 = 0,
                padding10: u1 = 0,
                padding11: u1 = 0,
                padding12: u1 = 0,
                padding13: u1 = 0,
                padding14: u1 = 0,
                padding15: u1 = 0,
                padding16: u1 = 0,
                padding17: u1 = 0,
                padding18: u1 = 0,
                padding19: u1 = 0,
                padding20: u1 = 0,
                padding21: u1 = 0,
                padding22: u1 = 0,
                padding23: u1 = 0,
            }), base_address + 0xd98);

            /// address: 0xe000ed9c
            /// MPU Region Base Address Register
            pub const RBAR = @intToPtr(*volatile Mmio(32, packed struct {
                REGION: u4,
                VALID: u1,
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                reserved2: u1 = 0,
                ADDR: u24,
            }), base_address + 0xd9c);

            /// address: 0xe000eda0
            /// MPU Region Attribute and Size Register
            pub const RASR = @intToPtr(*volatile Mmio(32, packed struct {
                ENABLE: u1,
                SIZE: u5,
                reserved0: u1 = 0,
                reserved1: u1 = 0,
                SRD: u8,
                B: u1,
                C: u1,
                S: u1,
                TEX: u3,
                reserved2: u1 = 0,
                reserved3: u1 = 0,
                AP: u3,
                reserved4: u1 = 0,
                XN: u1,
                padding0: u1 = 0,
                padding1: u1 = 0,
                padding2: u1 = 0,
            }), base_address + 0xda0);
        };
    };

    /// QSPI flash execute-in-place block
    pub const XIP_CTRL = struct {
        pub const base_address = 0x14000000;
        pub const version = "1";

        /// address: 0x14000000
        /// Cache control
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// When 1, enable the cache. When the cache is disabled, all XIP accesses\n
            /// will go straight to the flash, without querying the cache. When enabled,\n
            /// cacheable XIP accesses will query the cache, and the flash will\n
            /// not be accessed if the tag matches and the valid bit is set.\n\n
            /// If the cache is enabled, cache-as-SRAM accesses have no effect on the\n
            /// cache data RAM, and will produce a bus error response.
            EN: u1,
            /// When 1, writes to any alias other than 0x0 (caching, allocating)\n
            /// will produce a bus fault. When 0, these writes are silently ignored.\n
            /// In either case, writes to the 0x0 alias will deallocate on tag match,\n
            /// as usual.
            ERR_BADWRITE: u1,
            reserved0: u1 = 0,
            /// When 1, the cache memories are powered down. They retain state,\n
            /// but can not be accessed. This reduces static power dissipation.\n
            /// Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache cannot\n
            /// be enabled when powered down.\n
            /// Cache-as-SRAM accesses will produce a bus error response when\n
            /// the cache is powered down.
            POWER_DOWN: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x14000004
        /// Cache Flush control
        pub const FLUSH = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x4);

        /// address: 0x14000008
        /// Cache Status
        pub const STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reads as 0 while a cache flush is in progress, and 1 otherwise.\n
            /// The cache is flushed whenever the XIP block is reset, and also\n
            /// when requested via the FLUSH register.
            FLUSH_READY: u1,
            /// When 1, indicates the XIP streaming FIFO is completely empty.
            FIFO_EMPTY: u1,
            /// When 1, indicates the XIP streaming FIFO is completely full.\n
            /// The streaming FIFO is 2 entries deep, so the full and empty\n
            /// flag allow its level to be ascertained.
            FIFO_FULL: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x1400000c
        /// Cache Hit counter\n
        /// A 32 bit saturating counter that increments upon each cache hit,\n
        /// i.e. when an XIP access is serviced directly from cached data.\n
        /// Write any value to clear.
        pub const CTR_HIT = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x14000010
        /// Cache Access counter\n
        /// A 32 bit saturating counter that increments upon each XIP access,\n
        /// whether the cache is hit or not. This includes noncacheable accesses.\n
        /// Write any value to clear.
        pub const CTR_ACC = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x14000014
        /// FIFO stream address
        pub const STREAM_ADDR = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x14);

        /// address: 0x14000018
        /// FIFO stream control
        pub const STREAM_CTR = @intToPtr(*volatile MmioInt(32, u22), base_address + 0x18);

        /// address: 0x1400001c
        /// FIFO stream data\n
        /// Streamed data is buffered here, for retrieval by the system DMA.\n
        /// This FIFO can also be accessed via the XIP_AUX slave, to avoid exposing\n
        /// the DMA to bus stalls caused by other XIP traffic.
        pub const STREAM_FIFO = @intToPtr(*volatile u32, base_address + 0x1c);
    };

    /// DW_apb_ssi has the following features:\n
    /// * APB interface – Allows for easy integration into a DesignWare Synthesizable
    /// Components for AMBA 2 implementation.\n
    /// * APB3 and APB4 protocol support.\n
    /// * Scalable APB data bus width – Supports APB data bus widths of 8, 16, and 32
    /// bits.\n
    /// * Serial-master or serial-slave operation – Enables serial communication with
    /// serial-master or serial-slave peripheral devices.\n
    /// * Programmable Dual/Quad/Octal SPI support in Master Mode.\n
    /// * Dual Data Rate (DDR) and Read Data Strobe (RDS) Support - Enables the
    /// DW_apb_ssi master to perform operations with the device in DDR and RDS modes
    /// when working in Dual/Quad/Octal mode of operation.\n
    /// * Data Mask Support - Enables the DW_apb_ssi to selectively update the bytes in
    /// the device. This feature is applicable only in enhanced SPI modes.\n
    /// * eXecute-In-Place (XIP) support - Enables the DW_apb_ssi master to behave as a
    /// memory mapped I/O and fetches the data from the device based on the APB read
    /// request. This feature is applicable only in enhanced SPI modes.\n
    /// * DMA Controller Interface – Enables the DW_apb_ssi to interface to a DMA
    /// controller over the bus using a handshaking interface for transfer requests.\n
    /// * Independent masking of interrupts – Master collision, transmit FIFO
    /// overflow, transmit FIFO empty, receive FIFO full, receive FIFO underflow, and
    /// receive FIFO overflow interrupts can all be masked independently.\n
    /// * Multi-master contention detection – Informs the processor of multiple
    /// serial-master accesses on the serial bus.\n
    /// * Bypass of meta-stability flip-flops for synchronous clocks – When the APB
    /// clock (pclk) and the DW_apb_ssi serial clock (ssi_clk) are synchronous,
    /// meta-stable flip-flops are not used when transferring control signals across
    /// these clock domains.\n
    /// * Programmable delay on the sample time of the received serial data bit (rxd);
    /// enables programmable control of routing delays resulting in higher serial
    /// data-bit rates.\n
    /// * Programmable features:\n
    /// - Serial interface operation – Choice of Motorola SPI, Texas Instruments
    /// Synchronous Serial Protocol or National Semiconductor Microwire.\n
    /// - Clock bit-rate – Dynamic control of the serial bit rate of the data
    /// transfer; used in only serial-master mode of operation.\n
    /// - Data Item size (4 to 32 bits) – Item size of each data transfer under the
    /// control of the programmer.\n
    /// * Configured features:\n
    /// - FIFO depth – 16 words deep. The FIFO width is fixed at 32 bits.\n
    /// - 1 slave select output.\n
    /// - Hardware slave-select – Dedicated hardware slave-select line.\n
    /// - Combined interrupt line - one combined interrupt line from the DW_apb_ssi to
    /// the interrupt controller.\n
    /// - Interrupt polarity – active high interrupt lines.\n
    /// - Serial clock polarity – low serial-clock polarity directly after reset.\n
    /// - Serial clock phase – capture on first edge of serial-clock directly after
    /// reset.
    pub const XIP_SSI = struct {
        pub const base_address = 0x18000000;
        pub const version = "1";

        /// address: 0x18000000
        /// Control register 0
        pub const CTRLR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data frame size
            DFS: u4,
            /// Frame format
            FRF: u2,
            /// Serial clock phase
            SCPH: u1,
            /// Serial clock polarity
            SCPOL: u1,
            /// Transfer mode
            TMOD: u2,
            /// Slave output enable
            SLV_OE: u1,
            /// Shift register loop (test mode)
            SRL: u1,
            /// Control frame size\n
            /// Value of n -> n+1 clocks per frame.
            CFS: u4,
            /// Data frame size in 32b transfer mode\n
            /// Value of n -> n+1 clocks per frame.
            DFS_32: u5,
            /// SPI frame format
            SPI_FRF: u2,
            reserved0: u1 = 0,
            /// Slave select toggle enable
            SSTE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x18000004
        /// Master Control register 1
        pub const CTRLR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data frames
            NDF: u16,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x18000008
        /// SSI Enable
        pub const SSIENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SSI enable
            SSI_EN: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x1800000c
        /// Microwire Control
        pub const MWCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Microwire transfer mode
            MWMOD: u1,
            /// Microwire control
            MDD: u1,
            /// Microwire handshaking
            MHS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
        }), base_address + 0xc);

        /// address: 0x18000010
        /// Slave enable
        pub const SER = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x10);

        /// address: 0x18000014
        /// Baud rate
        pub const BAUDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SSI clock divider
            SCKDV: u16,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0x14);

        /// address: 0x18000018
        /// TX FIFO threshold level
        pub const TXFTLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO threshold
            TFT: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x1800001c
        /// RX FIFO threshold level
        pub const RXFTLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive FIFO threshold
            RFT: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x1c);

        /// address: 0x18000020
        /// TX FIFO level
        pub const TXFLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO level
            TFTFL: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x20);

        /// address: 0x18000024
        /// RX FIFO level
        pub const RXFLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive FIFO level
            RXTFL: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x24);

        /// address: 0x18000028
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SSI busy flag
            BUSY: u1,
            /// Transmit FIFO not full
            TFNF: u1,
            /// Transmit FIFO empty
            TFE: u1,
            /// Receive FIFO not empty
            RFNE: u1,
            /// Receive FIFO full
            RFF: u1,
            /// Transmission error
            TXE: u1,
            /// Data collision error
            DCOL: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
        }), base_address + 0x28);

        /// address: 0x1800002c
        /// Interrupt mask
        pub const IMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO empty interrupt mask
            TXEIM: u1,
            /// Transmit FIFO overflow interrupt mask
            TXOIM: u1,
            /// Receive FIFO underflow interrupt mask
            RXUIM: u1,
            /// Receive FIFO overflow interrupt mask
            RXOIM: u1,
            /// Receive FIFO full interrupt mask
            RXFIM: u1,
            /// Multi-master contention interrupt mask
            MSTIM: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
        }), base_address + 0x2c);

        /// address: 0x18000030
        /// Interrupt status
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO empty interrupt status
            TXEIS: u1,
            /// Transmit FIFO overflow interrupt status
            TXOIS: u1,
            /// Receive FIFO underflow interrupt status
            RXUIS: u1,
            /// Receive FIFO overflow interrupt status
            RXOIS: u1,
            /// Receive FIFO full interrupt status
            RXFIS: u1,
            /// Multi-master contention interrupt status
            MSTIS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
        }), base_address + 0x30);

        /// address: 0x18000034
        /// Raw interrupt status
        pub const RISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO empty raw interrupt status
            TXEIR: u1,
            /// Transmit FIFO overflow raw interrupt status
            TXOIR: u1,
            /// Receive FIFO underflow raw interrupt status
            RXUIR: u1,
            /// Receive FIFO overflow raw interrupt status
            RXOIR: u1,
            /// Receive FIFO full raw interrupt status
            RXFIR: u1,
            /// Multi-master contention raw interrupt status
            MSTIR: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
        }), base_address + 0x34);

        /// address: 0x18000038
        /// TX FIFO overflow interrupt clear
        pub const TXOICR = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x38);

        /// address: 0x1800003c
        /// RX FIFO overflow interrupt clear
        pub const RXOICR = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x3c);

        /// address: 0x18000040
        /// RX FIFO underflow interrupt clear
        pub const RXUICR = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x40);

        /// address: 0x18000044
        /// Multi-master interrupt clear
        pub const MSTICR = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x44);

        /// address: 0x18000048
        /// Interrupt clear
        pub const ICR = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x48);

        /// address: 0x1800004c
        /// DMA control
        pub const DMACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive DMA enable
            RDMAE: u1,
            /// Transmit DMA enable
            TDMAE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
        }), base_address + 0x4c);

        /// address: 0x18000050
        /// DMA TX data level
        pub const DMATDLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data watermark level
            DMATDL: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x50);

        /// address: 0x18000054
        /// DMA RX data level
        pub const DMARDLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive data watermark level (DMARDLR+1)
            DMARDL: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x54);

        /// address: 0x18000058
        /// Identification register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral dentification code
            IDCODE: u32,
        }), base_address + 0x58);

        /// address: 0x1800005c
        /// Version ID
        pub const SSI_VERSION_ID = @intToPtr(*volatile Mmio(32, packed struct {
            /// SNPS component version (format X.YY)
            SSI_COMP_VERSION: u32,
        }), base_address + 0x5c);

        /// address: 0x18000060
        /// Data Register 0 (of 36)
        pub const DR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// First data register of 36
            DR: u32,
        }), base_address + 0x60);

        /// address: 0x180000f0
        /// RX sample delay
        pub const RX_SAMPLE_DLY = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXD sample delay (in SCLK cycles)
            RSD: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xf0);

        /// address: 0x180000f4
        /// SPI control
        pub const SPI_CTRLR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address and instruction transfer format
            TRANS_TYPE: u2,
            /// Address length (0b-60b in 4b increments)
            ADDR_L: u4,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// Instruction length (0/4/8/16b)
            INST_L: u2,
            reserved2: u1 = 0,
            /// Wait cycles between control frame transmit and data reception (in SCLK cycles)
            WAIT_CYCLES: u5,
            /// SPI DDR transfer enable
            SPI_DDR_EN: u1,
            /// Instruction DDR transfer enable
            INST_DDR_EN: u1,
            /// Read data strobe enable
            SPI_RXDS_EN: u1,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// SPI Command to send in XIP mode (INST_L = 8-bit) or to append to Address (INST_L
            /// = 0-bit)
            XIP_CMD: u8,
        }), base_address + 0xf4);

        /// address: 0x180000f8
        /// TX drive edge
        pub const TXD_DRIVE_EDGE = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXD drive edge
            TDE: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xf8);
    };
    pub const SYSINFO = struct {
        pub const base_address = 0x40000000;
        pub const version = "1";

        /// address: 0x40000000
        /// JEDEC JEP-106 compliant chip identifier.
        pub const CHIP_ID = @intToPtr(*volatile Mmio(32, packed struct {
            MANUFACTURER: u12,
            PART: u16,
            REVISION: u4,
        }), base_address + 0x0);

        /// address: 0x40000004
        /// Platform register. Allows software to know what environment it is running in.
        pub const PLATFORM = @intToPtr(*volatile Mmio(32, packed struct {
            FPGA: u1,
            ASIC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40000040
        /// Git hash of the chip source. Used to identify chip version.
        pub const GITREF_RP2040 = @intToPtr(*volatile u32, base_address + 0x40);
    };

    /// Register block for various chip control signals
    pub const SYSCFG = struct {
        pub const base_address = 0x40004000;
        pub const version = "1";

        /// address: 0x40004000
        /// Processor core 0 NMI source mask\n
        /// Set a bit high to enable NMI from that IRQ
        pub const PROC0_NMI_MASK = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40004004
        /// Processor core 1 NMI source mask\n
        /// Set a bit high to enable NMI from that IRQ
        pub const PROC1_NMI_MASK = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40004008
        /// Configuration for processors
        pub const PROC_CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indication that proc0 has halted
            PROC0_HALTED: u1,
            /// Indication that proc1 has halted
            PROC1_HALTED: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            reserved18: u1 = 0,
            reserved19: u1 = 0,
            reserved20: u1 = 0,
            reserved21: u1 = 0,
            /// Configure proc0 DAP instance ID.\n
            /// Recommend that this is NOT changed until you require debug access in multi-chip
            /// environment\n
            /// WARNING: do not set to 15 as this is reserved for RescueDP
            PROC0_DAP_INSTID: u4,
            /// Configure proc1 DAP instance ID.\n
            /// Recommend that this is NOT changed until you require debug access in multi-chip
            /// environment\n
            /// WARNING: do not set to 15 as this is reserved for RescueDP
            PROC1_DAP_INSTID: u4,
        }), base_address + 0x8);

        /// address: 0x4000400c
        /// For each bit, if 1, bypass the input synchronizer between that GPIO\n
        /// and the GPIO input register in the SIO. The input synchronizers should\n
        /// generally be unbypassed, to avoid injecting metastabilities into processors.\n
        /// If you're feeling brave, you can bypass to save two cycles of input\n
        /// latency. This register applies to GPIO 0...29.
        pub const PROC_IN_SYNC_BYPASS = @intToPtr(*volatile MmioInt(32, u30), base_address + 0xc);

        /// address: 0x40004010
        /// For each bit, if 1, bypass the input synchronizer between that GPIO\n
        /// and the GPIO input register in the SIO. The input synchronizers should\n
        /// generally be unbypassed, to avoid injecting metastabilities into processors.\n
        /// If you're feeling brave, you can bypass to save two cycles of input\n
        /// latency. This register applies to GPIO 30...35 (the QSPI IOs).
        pub const PROC_IN_SYNC_BYPASS_HI = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x10);

        /// address: 0x40004014
        /// Directly control the SWD debug port of either processor
        pub const DBGFORCE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Observe the value of processor 0 SWDIO output.
            PROC0_SWDO: u1,
            /// Directly drive processor 0 SWDIO input, if PROC0_ATTACH is set
            PROC0_SWDI: u1,
            /// Directly drive processor 0 SWCLK, if PROC0_ATTACH is set
            PROC0_SWCLK: u1,
            /// Attach processor 0 debug port to syscfg controls, and disconnect it from
            /// external SWD pads.
            PROC0_ATTACH: u1,
            /// Observe the value of processor 1 SWDIO output.
            PROC1_SWDO: u1,
            /// Directly drive processor 1 SWDIO input, if PROC1_ATTACH is set
            PROC1_SWDI: u1,
            /// Directly drive processor 1 SWCLK, if PROC1_ATTACH is set
            PROC1_SWCLK: u1,
            /// Attach processor 1 debug port to syscfg controls, and disconnect it from
            /// external SWD pads.
            PROC1_ATTACH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x14);

        /// address: 0x40004018
        /// Control power downs to memories. Set high to power down memories.\n
        /// Use with extreme caution
        pub const MEMPOWERDOWN = @intToPtr(*volatile Mmio(32, packed struct {
            SRAM0: u1,
            SRAM1: u1,
            SRAM2: u1,
            SRAM3: u1,
            SRAM4: u1,
            SRAM5: u1,
            USB: u1,
            ROM: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x18);
    };
    pub const CLOCKS = struct {
        pub const base_address = 0x40008000;
        pub const version = "1";

        /// address: 0x40008000
        /// Clock control, can be changed on-the-fly (except for auxsrc)
        pub const CLK_GPOUT0_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            /// Selects the auxiliary clock source, will glitch when switching
            AUXSRC: u4,
            reserved5: u1 = 0,
            /// Asynchronously kills the clock generator
            KILL: u1,
            /// Starts and stops the clock generator cleanly
            ENABLE: u1,
            /// Enables duty cycle correction for odd divisors
            DC50: u1,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// This delays the enable signal by up to 3 cycles of the input clock\n
            /// This must be set before the clock is enabled to have any effect
            PHASE: u2,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            /// An edge on this signal shifts the phase of the output by 1 cycle of the input
            /// clock\n
            /// This can be done at any time
            NUDGE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40008004
        /// Clock divisor, can be changed on-the-fly
        pub const CLK_GPOUT0_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fractional component of the divisor
            FRAC: u8,
            /// Integer component of the divisor, 0 -> divide by 2^16
            INT: u24,
        }), base_address + 0x4);

        /// address: 0x40008008
        /// Indicates which SRC is currently selected by the glitchless mux (one-hot).\n
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present,
        /// not SRC) so this register is hardwired to 0x1.
        pub const CLK_GPOUT0_SELECTED = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4000800c
        /// Clock control, can be changed on-the-fly (except for auxsrc)
        pub const CLK_GPOUT1_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            /// Selects the auxiliary clock source, will glitch when switching
            AUXSRC: u4,
            reserved5: u1 = 0,
            /// Asynchronously kills the clock generator
            KILL: u1,
            /// Starts and stops the clock generator cleanly
            ENABLE: u1,
            /// Enables duty cycle correction for odd divisors
            DC50: u1,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// This delays the enable signal by up to 3 cycles of the input clock\n
            /// This must be set before the clock is enabled to have any effect
            PHASE: u2,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            /// An edge on this signal shifts the phase of the output by 1 cycle of the input
            /// clock\n
            /// This can be done at any time
            NUDGE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
        }), base_address + 0xc);

        /// address: 0x40008010
        /// Clock divisor, can be changed on-the-fly
        pub const CLK_GPOUT1_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fractional component of the divisor
            FRAC: u8,
            /// Integer component of the divisor, 0 -> divide by 2^16
            INT: u24,
        }), base_address + 0x10);

        /// address: 0x40008014
        /// Indicates which SRC is currently selected by the glitchless mux (one-hot).\n
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present,
        /// not SRC) so this register is hardwired to 0x1.
        pub const CLK_GPOUT1_SELECTED = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x40008018
        /// Clock control, can be changed on-the-fly (except for auxsrc)
        pub const CLK_GPOUT2_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            /// Selects the auxiliary clock source, will glitch when switching
            AUXSRC: u4,
            reserved5: u1 = 0,
            /// Asynchronously kills the clock generator
            KILL: u1,
            /// Starts and stops the clock generator cleanly
            ENABLE: u1,
            /// Enables duty cycle correction for odd divisors
            DC50: u1,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// This delays the enable signal by up to 3 cycles of the input clock\n
            /// This must be set before the clock is enabled to have any effect
            PHASE: u2,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            /// An edge on this signal shifts the phase of the output by 1 cycle of the input
            /// clock\n
            /// This can be done at any time
            NUDGE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x4000801c
        /// Clock divisor, can be changed on-the-fly
        pub const CLK_GPOUT2_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fractional component of the divisor
            FRAC: u8,
            /// Integer component of the divisor, 0 -> divide by 2^16
            INT: u24,
        }), base_address + 0x1c);

        /// address: 0x40008020
        /// Indicates which SRC is currently selected by the glitchless mux (one-hot).\n
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present,
        /// not SRC) so this register is hardwired to 0x1.
        pub const CLK_GPOUT2_SELECTED = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40008024
        /// Clock control, can be changed on-the-fly (except for auxsrc)
        pub const CLK_GPOUT3_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            /// Selects the auxiliary clock source, will glitch when switching
            AUXSRC: u4,
            reserved5: u1 = 0,
            /// Asynchronously kills the clock generator
            KILL: u1,
            /// Starts and stops the clock generator cleanly
            ENABLE: u1,
            /// Enables duty cycle correction for odd divisors
            DC50: u1,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// This delays the enable signal by up to 3 cycles of the input clock\n
            /// This must be set before the clock is enabled to have any effect
            PHASE: u2,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            /// An edge on this signal shifts the phase of the output by 1 cycle of the input
            /// clock\n
            /// This can be done at any time
            NUDGE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
        }), base_address + 0x24);

        /// address: 0x40008028
        /// Clock divisor, can be changed on-the-fly
        pub const CLK_GPOUT3_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fractional component of the divisor
            FRAC: u8,
            /// Integer component of the divisor, 0 -> divide by 2^16
            INT: u24,
        }), base_address + 0x28);

        /// address: 0x4000802c
        /// Indicates which SRC is currently selected by the glitchless mux (one-hot).\n
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present,
        /// not SRC) so this register is hardwired to 0x1.
        pub const CLK_GPOUT3_SELECTED = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x40008030
        /// Clock control, can be changed on-the-fly (except for auxsrc)
        pub const CLK_REF_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects the clock source glitchlessly, can be changed on-the-fly
            SRC: u2,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            /// Selects the auxiliary clock source, will glitch when switching
            AUXSRC: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
        }), base_address + 0x30);

        /// address: 0x40008034
        /// Clock divisor, can be changed on-the-fly
        pub const CLK_REF_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Integer component of the divisor, 0 -> divide by 2^16
            INT: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
        }), base_address + 0x34);

        /// address: 0x40008038
        /// Indicates which SRC is currently selected by the glitchless mux (one-hot).\n
        /// The glitchless multiplexer does not switch instantaneously (to avoid glitches),
        /// so software should poll this register to wait for the switch to complete. This
        /// register contains one decoded bit for each of the clock sources enumerated in
        /// the CTRL SRC field. At most one of these bits will be set at any time,
        /// indicating that clock is currently present at the output of the glitchless mux.
        /// Whilst switching is in progress, this register may briefly show all-0s.
        pub const CLK_REF_SELECTED = @intToPtr(*volatile u32, base_address + 0x38);

        /// address: 0x4000803c
        /// Clock control, can be changed on-the-fly (except for auxsrc)
        pub const CLK_SYS_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Selects the clock source glitchlessly, can be changed on-the-fly
            SRC: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// Selects the auxiliary clock source, will glitch when switching
            AUXSRC: u3,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x3c);

        /// address: 0x40008040
        /// Clock divisor, can be changed on-the-fly
        pub const CLK_SYS_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fractional component of the divisor
            FRAC: u8,
            /// Integer component of the divisor, 0 -> divide by 2^16
            INT: u24,
        }), base_address + 0x40);

        /// address: 0x40008044
        /// Indicates which SRC is currently selected by the glitchless mux (one-hot).\n
        /// The glitchless multiplexer does not switch instantaneously (to avoid glitches),
        /// so software should poll this register to wait for the switch to complete. This
        /// register contains one decoded bit for each of the clock sources enumerated in
        /// the CTRL SRC field. At most one of these bits will be set at any time,
        /// indicating that clock is currently present at the output of the glitchless mux.
        /// Whilst switching is in progress, this register may briefly show all-0s.
        pub const CLK_SYS_SELECTED = @intToPtr(*volatile u32, base_address + 0x44);

        /// address: 0x40008048
        /// Clock control, can be changed on-the-fly (except for auxsrc)
        pub const CLK_PERI_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            /// Selects the auxiliary clock source, will glitch when switching
            AUXSRC: u3,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            /// Asynchronously kills the clock generator
            KILL: u1,
            /// Starts and stops the clock generator cleanly
            ENABLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x48);

        /// address: 0x40008050
        /// Indicates which SRC is currently selected by the glitchless mux (one-hot).\n
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present,
        /// not SRC) so this register is hardwired to 0x1.
        pub const CLK_PERI_SELECTED = @intToPtr(*volatile u32, base_address + 0x50);

        /// address: 0x40008054
        /// Clock control, can be changed on-the-fly (except for auxsrc)
        pub const CLK_USB_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            /// Selects the auxiliary clock source, will glitch when switching
            AUXSRC: u3,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            /// Asynchronously kills the clock generator
            KILL: u1,
            /// Starts and stops the clock generator cleanly
            ENABLE: u1,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            /// This delays the enable signal by up to 3 cycles of the input clock\n
            /// This must be set before the clock is enabled to have any effect
            PHASE: u2,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// An edge on this signal shifts the phase of the output by 1 cycle of the input
            /// clock\n
            /// This can be done at any time
            NUDGE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
        }), base_address + 0x54);

        /// address: 0x40008058
        /// Clock divisor, can be changed on-the-fly
        pub const CLK_USB_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Integer component of the divisor, 0 -> divide by 2^16
            INT: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
        }), base_address + 0x58);

        /// address: 0x4000805c
        /// Indicates which SRC is currently selected by the glitchless mux (one-hot).\n
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present,
        /// not SRC) so this register is hardwired to 0x1.
        pub const CLK_USB_SELECTED = @intToPtr(*volatile u32, base_address + 0x5c);

        /// address: 0x40008060
        /// Clock control, can be changed on-the-fly (except for auxsrc)
        pub const CLK_ADC_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            /// Selects the auxiliary clock source, will glitch when switching
            AUXSRC: u3,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            /// Asynchronously kills the clock generator
            KILL: u1,
            /// Starts and stops the clock generator cleanly
            ENABLE: u1,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            /// This delays the enable signal by up to 3 cycles of the input clock\n
            /// This must be set before the clock is enabled to have any effect
            PHASE: u2,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// An edge on this signal shifts the phase of the output by 1 cycle of the input
            /// clock\n
            /// This can be done at any time
            NUDGE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
        }), base_address + 0x60);

        /// address: 0x40008064
        /// Clock divisor, can be changed on-the-fly
        pub const CLK_ADC_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Integer component of the divisor, 0 -> divide by 2^16
            INT: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
        }), base_address + 0x64);

        /// address: 0x40008068
        /// Indicates which SRC is currently selected by the glitchless mux (one-hot).\n
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present,
        /// not SRC) so this register is hardwired to 0x1.
        pub const CLK_ADC_SELECTED = @intToPtr(*volatile u32, base_address + 0x68);

        /// address: 0x4000806c
        /// Clock control, can be changed on-the-fly (except for auxsrc)
        pub const CLK_RTC_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            /// Selects the auxiliary clock source, will glitch when switching
            AUXSRC: u3,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            /// Asynchronously kills the clock generator
            KILL: u1,
            /// Starts and stops the clock generator cleanly
            ENABLE: u1,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            /// This delays the enable signal by up to 3 cycles of the input clock\n
            /// This must be set before the clock is enabled to have any effect
            PHASE: u2,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// An edge on this signal shifts the phase of the output by 1 cycle of the input
            /// clock\n
            /// This can be done at any time
            NUDGE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
        }), base_address + 0x6c);

        /// address: 0x40008070
        /// Clock divisor, can be changed on-the-fly
        pub const CLK_RTC_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fractional component of the divisor
            FRAC: u8,
            /// Integer component of the divisor, 0 -> divide by 2^16
            INT: u24,
        }), base_address + 0x70);

        /// address: 0x40008074
        /// Indicates which SRC is currently selected by the glitchless mux (one-hot).\n
        /// This slice does not have a glitchless mux (only the AUX_SRC field is present,
        /// not SRC) so this register is hardwired to 0x1.
        pub const CLK_RTC_SELECTED = @intToPtr(*volatile u32, base_address + 0x74);

        /// address: 0x40008078
        pub const CLK_SYS_RESUS_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// This is expressed as a number of clk_ref cycles\n
            /// and must be >= 2x clk_ref_freq/min_clk_tst_freq
            TIMEOUT: u8,
            /// Enable resus
            ENABLE: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            /// Force a resus, for test purposes only
            FRCE: u1,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            /// For clearing the resus after the fault that triggered it has been corrected
            CLEAR: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
        }), base_address + 0x78);

        /// address: 0x4000807c
        pub const CLK_SYS_RESUS_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock has been resuscitated, correct the error then send ctrl_clear=1
            RESUSSED: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x7c);

        /// address: 0x40008080
        /// Reference clock frequency in kHz
        pub const FC0_REF_KHZ = @intToPtr(*volatile MmioInt(32, u20), base_address + 0x80);

        /// address: 0x40008084
        /// Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using
        /// the pass/fail flags
        pub const FC0_MIN_KHZ = @intToPtr(*volatile MmioInt(32, u25), base_address + 0x84);

        /// address: 0x40008088
        /// Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not
        /// using the pass/fail flags
        pub const FC0_MAX_KHZ = @intToPtr(*volatile MmioInt(32, u25), base_address + 0x88);

        /// address: 0x4000808c
        /// Delays the start of frequency counting to allow the mux to settle\n
        /// Delay is measured in multiples of the reference clock period
        pub const FC0_DELAY = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x8c);

        /// address: 0x40008090
        /// The test interval is 0.98us * 2**interval, but let's call it 1us * 2**interval\n
        /// The default gives a test interval of 250us
        pub const FC0_INTERVAL = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x90);

        /// address: 0x40008094
        /// Clock sent to frequency counter, set to 0 when not required\n
        /// Writing to this register initiates the frequency count
        pub const FC0_SRC = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x94);

        /// address: 0x40008098
        /// Frequency counter status
        pub const FC0_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Test passed
            PASS: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            /// Test complete
            DONE: u1,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            /// Test running
            RUNNING: u1,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Waiting for test clock to start
            WAITING: u1,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            /// Test failed
            FAIL: u1,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            /// Test clock slower than expected, only valid when status_done=1
            SLOW: u1,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// Test clock faster than expected, only valid when status_done=1
            FAST: u1,
            reserved18: u1 = 0,
            reserved19: u1 = 0,
            reserved20: u1 = 0,
            /// Test clock stopped during test
            DIED: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
        }), base_address + 0x98);

        /// address: 0x4000809c
        /// Result of frequency measurement, only valid when status_done=1
        pub const FC0_RESULT = @intToPtr(*volatile Mmio(32, packed struct {
            FRAC: u5,
            KHZ: u25,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x9c);

        /// address: 0x400080a0
        /// enable clock in wake mode
        pub const WAKE_EN0 = @intToPtr(*volatile Mmio(32, packed struct {
            clk_sys_clocks: u1,
            clk_adc_adc: u1,
            clk_sys_adc: u1,
            clk_sys_busctrl: u1,
            clk_sys_busfabric: u1,
            clk_sys_dma: u1,
            clk_sys_i2c0: u1,
            clk_sys_i2c1: u1,
            clk_sys_io: u1,
            clk_sys_jtag: u1,
            clk_sys_vreg_and_chip_reset: u1,
            clk_sys_pads: u1,
            clk_sys_pio0: u1,
            clk_sys_pio1: u1,
            clk_sys_pll_sys: u1,
            clk_sys_pll_usb: u1,
            clk_sys_psm: u1,
            clk_sys_pwm: u1,
            clk_sys_resets: u1,
            clk_sys_rom: u1,
            clk_sys_rosc: u1,
            clk_rtc_rtc: u1,
            clk_sys_rtc: u1,
            clk_sys_sio: u1,
            clk_peri_spi0: u1,
            clk_sys_spi0: u1,
            clk_peri_spi1: u1,
            clk_sys_spi1: u1,
            clk_sys_sram0: u1,
            clk_sys_sram1: u1,
            clk_sys_sram2: u1,
            clk_sys_sram3: u1,
        }), base_address + 0xa0);

        /// address: 0x400080a4
        /// enable clock in wake mode
        pub const WAKE_EN1 = @intToPtr(*volatile Mmio(32, packed struct {
            clk_sys_sram4: u1,
            clk_sys_sram5: u1,
            clk_sys_syscfg: u1,
            clk_sys_sysinfo: u1,
            clk_sys_tbman: u1,
            clk_sys_timer: u1,
            clk_peri_uart0: u1,
            clk_sys_uart0: u1,
            clk_peri_uart1: u1,
            clk_sys_uart1: u1,
            clk_sys_usbctrl: u1,
            clk_usb_usbctrl: u1,
            clk_sys_watchdog: u1,
            clk_sys_xip: u1,
            clk_sys_xosc: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
        }), base_address + 0xa4);

        /// address: 0x400080a8
        /// enable clock in sleep mode
        pub const SLEEP_EN0 = @intToPtr(*volatile Mmio(32, packed struct {
            clk_sys_clocks: u1,
            clk_adc_adc: u1,
            clk_sys_adc: u1,
            clk_sys_busctrl: u1,
            clk_sys_busfabric: u1,
            clk_sys_dma: u1,
            clk_sys_i2c0: u1,
            clk_sys_i2c1: u1,
            clk_sys_io: u1,
            clk_sys_jtag: u1,
            clk_sys_vreg_and_chip_reset: u1,
            clk_sys_pads: u1,
            clk_sys_pio0: u1,
            clk_sys_pio1: u1,
            clk_sys_pll_sys: u1,
            clk_sys_pll_usb: u1,
            clk_sys_psm: u1,
            clk_sys_pwm: u1,
            clk_sys_resets: u1,
            clk_sys_rom: u1,
            clk_sys_rosc: u1,
            clk_rtc_rtc: u1,
            clk_sys_rtc: u1,
            clk_sys_sio: u1,
            clk_peri_spi0: u1,
            clk_sys_spi0: u1,
            clk_peri_spi1: u1,
            clk_sys_spi1: u1,
            clk_sys_sram0: u1,
            clk_sys_sram1: u1,
            clk_sys_sram2: u1,
            clk_sys_sram3: u1,
        }), base_address + 0xa8);

        /// address: 0x400080ac
        /// enable clock in sleep mode
        pub const SLEEP_EN1 = @intToPtr(*volatile Mmio(32, packed struct {
            clk_sys_sram4: u1,
            clk_sys_sram5: u1,
            clk_sys_syscfg: u1,
            clk_sys_sysinfo: u1,
            clk_sys_tbman: u1,
            clk_sys_timer: u1,
            clk_peri_uart0: u1,
            clk_sys_uart0: u1,
            clk_peri_uart1: u1,
            clk_sys_uart1: u1,
            clk_sys_usbctrl: u1,
            clk_usb_usbctrl: u1,
            clk_sys_watchdog: u1,
            clk_sys_xip: u1,
            clk_sys_xosc: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
        }), base_address + 0xac);

        /// address: 0x400080b0
        /// indicates the state of the clock enable
        pub const ENABLED0 = @intToPtr(*volatile Mmio(32, packed struct {
            clk_sys_clocks: u1,
            clk_adc_adc: u1,
            clk_sys_adc: u1,
            clk_sys_busctrl: u1,
            clk_sys_busfabric: u1,
            clk_sys_dma: u1,
            clk_sys_i2c0: u1,
            clk_sys_i2c1: u1,
            clk_sys_io: u1,
            clk_sys_jtag: u1,
            clk_sys_vreg_and_chip_reset: u1,
            clk_sys_pads: u1,
            clk_sys_pio0: u1,
            clk_sys_pio1: u1,
            clk_sys_pll_sys: u1,
            clk_sys_pll_usb: u1,
            clk_sys_psm: u1,
            clk_sys_pwm: u1,
            clk_sys_resets: u1,
            clk_sys_rom: u1,
            clk_sys_rosc: u1,
            clk_rtc_rtc: u1,
            clk_sys_rtc: u1,
            clk_sys_sio: u1,
            clk_peri_spi0: u1,
            clk_sys_spi0: u1,
            clk_peri_spi1: u1,
            clk_sys_spi1: u1,
            clk_sys_sram0: u1,
            clk_sys_sram1: u1,
            clk_sys_sram2: u1,
            clk_sys_sram3: u1,
        }), base_address + 0xb0);

        /// address: 0x400080b4
        /// indicates the state of the clock enable
        pub const ENABLED1 = @intToPtr(*volatile Mmio(32, packed struct {
            clk_sys_sram4: u1,
            clk_sys_sram5: u1,
            clk_sys_syscfg: u1,
            clk_sys_sysinfo: u1,
            clk_sys_tbman: u1,
            clk_sys_timer: u1,
            clk_peri_uart0: u1,
            clk_sys_uart0: u1,
            clk_peri_uart1: u1,
            clk_sys_uart1: u1,
            clk_sys_usbctrl: u1,
            clk_usb_usbctrl: u1,
            clk_sys_watchdog: u1,
            clk_sys_xip: u1,
            clk_sys_xosc: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
        }), base_address + 0xb4);

        /// address: 0x400080b8
        /// Raw Interrupts
        pub const INTR = @intToPtr(*volatile Mmio(32, packed struct {
            CLK_SYS_RESUS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0xb8);

        /// address: 0x400080bc
        /// Interrupt Enable
        pub const INTE = @intToPtr(*volatile Mmio(32, packed struct {
            CLK_SYS_RESUS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0xbc);

        /// address: 0x400080c0
        /// Interrupt Force
        pub const INTF = @intToPtr(*volatile Mmio(32, packed struct {
            CLK_SYS_RESUS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0xc0);

        /// address: 0x400080c4
        /// Interrupt status after masking & forcing
        pub const INTS = @intToPtr(*volatile Mmio(32, packed struct {
            CLK_SYS_RESUS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0xc4);
    };
    pub const RESETS = struct {
        pub const base_address = 0x4000c000;
        pub const version = "1";

        /// address: 0x4000c000
        /// Reset control. If a bit is set it means the peripheral is in reset. 0 means the
        /// peripheral's reset is deasserted.
        pub const RESET = @intToPtr(*volatile Mmio(32, packed struct {
            adc: u1,
            busctrl: u1,
            dma: u1,
            i2c0: u1,
            i2c1: u1,
            io_bank0: u1,
            io_qspi: u1,
            jtag: u1,
            pads_bank0: u1,
            pads_qspi: u1,
            pio0: u1,
            pio1: u1,
            pll_sys: u1,
            pll_usb: u1,
            pwm: u1,
            rtc: u1,
            spi0: u1,
            spi1: u1,
            syscfg: u1,
            sysinfo: u1,
            tbman: u1,
            timer: u1,
            uart0: u1,
            uart1: u1,
            usbctrl: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x4000c004
        /// Watchdog select. If a bit is set then the watchdog will reset this peripheral
        /// when the watchdog fires.
        pub const WDSEL = @intToPtr(*volatile Mmio(32, packed struct {
            adc: u1,
            busctrl: u1,
            dma: u1,
            i2c0: u1,
            i2c1: u1,
            io_bank0: u1,
            io_qspi: u1,
            jtag: u1,
            pads_bank0: u1,
            pads_qspi: u1,
            pio0: u1,
            pio1: u1,
            pll_sys: u1,
            pll_usb: u1,
            pwm: u1,
            rtc: u1,
            spi0: u1,
            spi1: u1,
            syscfg: u1,
            sysinfo: u1,
            tbman: u1,
            timer: u1,
            uart0: u1,
            uart1: u1,
            usbctrl: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x4000c008
        /// Reset done. If a bit is set then a reset done signal has been returned by the
        /// peripheral. This indicates that the peripheral's registers are ready to be
        /// accessed.
        pub const RESET_DONE = @intToPtr(*volatile Mmio(32, packed struct {
            adc: u1,
            busctrl: u1,
            dma: u1,
            i2c0: u1,
            i2c1: u1,
            io_bank0: u1,
            io_qspi: u1,
            jtag: u1,
            pads_bank0: u1,
            pads_qspi: u1,
            pio0: u1,
            pio1: u1,
            pll_sys: u1,
            pll_usb: u1,
            pwm: u1,
            rtc: u1,
            spi0: u1,
            spi1: u1,
            syscfg: u1,
            sysinfo: u1,
            tbman: u1,
            timer: u1,
            uart0: u1,
            uart1: u1,
            usbctrl: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
        }), base_address + 0x8);
    };
    pub const PSM = struct {
        pub const base_address = 0x40010000;
        pub const version = "1";

        /// address: 0x40010000
        /// Force block out of reset (i.e. power it on)
        pub const FRCE_ON = @intToPtr(*volatile Mmio(32, packed struct {
            rosc: u1,
            xosc: u1,
            clocks: u1,
            resets: u1,
            busfabric: u1,
            rom: u1,
            sram0: u1,
            sram1: u1,
            sram2: u1,
            sram3: u1,
            sram4: u1,
            sram5: u1,
            xip: u1,
            vreg_and_chip_reset: u1,
            sio: u1,
            proc0: u1,
            proc1: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40010004
        /// Force into reset (i.e. power it off)
        pub const FRCE_OFF = @intToPtr(*volatile Mmio(32, packed struct {
            rosc: u1,
            xosc: u1,
            clocks: u1,
            resets: u1,
            busfabric: u1,
            rom: u1,
            sram0: u1,
            sram1: u1,
            sram2: u1,
            sram3: u1,
            sram4: u1,
            sram5: u1,
            xip: u1,
            vreg_and_chip_reset: u1,
            sio: u1,
            proc0: u1,
            proc1: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40010008
        /// Set to 1 if this peripheral should be reset when the watchdog fires.
        pub const WDSEL = @intToPtr(*volatile Mmio(32, packed struct {
            rosc: u1,
            xosc: u1,
            clocks: u1,
            resets: u1,
            busfabric: u1,
            rom: u1,
            sram0: u1,
            sram1: u1,
            sram2: u1,
            sram3: u1,
            sram4: u1,
            sram5: u1,
            xip: u1,
            vreg_and_chip_reset: u1,
            sio: u1,
            proc0: u1,
            proc1: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x4001000c
        /// Indicates the peripheral's registers are ready to access.
        pub const DONE = @intToPtr(*volatile Mmio(32, packed struct {
            rosc: u1,
            xosc: u1,
            clocks: u1,
            resets: u1,
            busfabric: u1,
            rom: u1,
            sram0: u1,
            sram1: u1,
            sram2: u1,
            sram3: u1,
            sram4: u1,
            sram5: u1,
            xip: u1,
            vreg_and_chip_reset: u1,
            sio: u1,
            proc0: u1,
            proc1: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
        }), base_address + 0xc);
    };
    pub const IO_BANK0 = struct {
        pub const base_address = 0x40014000;
        pub const version = "1";

        /// address: 0x40014000
        /// GPIO status
        pub const GPIO0_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40014004
        /// GPIO control including function select and overrides.
        pub const GPIO0_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40014008
        /// GPIO status
        pub const GPIO1_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x4001400c
        /// GPIO control including function select and overrides.
        pub const GPIO1_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0xc);

        /// address: 0x40014010
        /// GPIO status
        pub const GPIO2_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x10);

        /// address: 0x40014014
        /// GPIO control including function select and overrides.
        pub const GPIO2_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x14);

        /// address: 0x40014018
        /// GPIO status
        pub const GPIO3_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x4001401c
        /// GPIO control including function select and overrides.
        pub const GPIO3_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x1c);

        /// address: 0x40014020
        /// GPIO status
        pub const GPIO4_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x20);

        /// address: 0x40014024
        /// GPIO control including function select and overrides.
        pub const GPIO4_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x24);

        /// address: 0x40014028
        /// GPIO status
        pub const GPIO5_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x28);

        /// address: 0x4001402c
        /// GPIO control including function select and overrides.
        pub const GPIO5_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x2c);

        /// address: 0x40014030
        /// GPIO status
        pub const GPIO6_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x30);

        /// address: 0x40014034
        /// GPIO control including function select and overrides.
        pub const GPIO6_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x34);

        /// address: 0x40014038
        /// GPIO status
        pub const GPIO7_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x38);

        /// address: 0x4001403c
        /// GPIO control including function select and overrides.
        pub const GPIO7_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x3c);

        /// address: 0x40014040
        /// GPIO status
        pub const GPIO8_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x40);

        /// address: 0x40014044
        /// GPIO control including function select and overrides.
        pub const GPIO8_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x44);

        /// address: 0x40014048
        /// GPIO status
        pub const GPIO9_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x48);

        /// address: 0x4001404c
        /// GPIO control including function select and overrides.
        pub const GPIO9_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x4c);

        /// address: 0x40014050
        /// GPIO status
        pub const GPIO10_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x50);

        /// address: 0x40014054
        /// GPIO control including function select and overrides.
        pub const GPIO10_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x54);

        /// address: 0x40014058
        /// GPIO status
        pub const GPIO11_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x58);

        /// address: 0x4001405c
        /// GPIO control including function select and overrides.
        pub const GPIO11_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x5c);

        /// address: 0x40014060
        /// GPIO status
        pub const GPIO12_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x60);

        /// address: 0x40014064
        /// GPIO control including function select and overrides.
        pub const GPIO12_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x64);

        /// address: 0x40014068
        /// GPIO status
        pub const GPIO13_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x68);

        /// address: 0x4001406c
        /// GPIO control including function select and overrides.
        pub const GPIO13_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x6c);

        /// address: 0x40014070
        /// GPIO status
        pub const GPIO14_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x70);

        /// address: 0x40014074
        /// GPIO control including function select and overrides.
        pub const GPIO14_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x74);

        /// address: 0x40014078
        /// GPIO status
        pub const GPIO15_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x78);

        /// address: 0x4001407c
        /// GPIO control including function select and overrides.
        pub const GPIO15_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x7c);

        /// address: 0x40014080
        /// GPIO status
        pub const GPIO16_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x80);

        /// address: 0x40014084
        /// GPIO control including function select and overrides.
        pub const GPIO16_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x84);

        /// address: 0x40014088
        /// GPIO status
        pub const GPIO17_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x88);

        /// address: 0x4001408c
        /// GPIO control including function select and overrides.
        pub const GPIO17_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x8c);

        /// address: 0x40014090
        /// GPIO status
        pub const GPIO18_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x90);

        /// address: 0x40014094
        /// GPIO control including function select and overrides.
        pub const GPIO18_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x94);

        /// address: 0x40014098
        /// GPIO status
        pub const GPIO19_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x98);

        /// address: 0x4001409c
        /// GPIO control including function select and overrides.
        pub const GPIO19_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x9c);

        /// address: 0x400140a0
        /// GPIO status
        pub const GPIO20_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0xa0);

        /// address: 0x400140a4
        /// GPIO control including function select and overrides.
        pub const GPIO20_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0xa4);

        /// address: 0x400140a8
        /// GPIO status
        pub const GPIO21_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0xa8);

        /// address: 0x400140ac
        /// GPIO control including function select and overrides.
        pub const GPIO21_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0xac);

        /// address: 0x400140b0
        /// GPIO status
        pub const GPIO22_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0xb0);

        /// address: 0x400140b4
        /// GPIO control including function select and overrides.
        pub const GPIO22_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0xb4);

        /// address: 0x400140b8
        /// GPIO status
        pub const GPIO23_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0xb8);

        /// address: 0x400140bc
        /// GPIO control including function select and overrides.
        pub const GPIO23_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0xbc);

        /// address: 0x400140c0
        /// GPIO status
        pub const GPIO24_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0xc0);

        /// address: 0x400140c4
        /// GPIO control including function select and overrides.
        pub const GPIO24_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0xc4);

        /// address: 0x400140c8
        /// GPIO status
        pub const GPIO25_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0xc8);

        /// address: 0x400140cc
        /// GPIO control including function select and overrides.
        pub const GPIO25_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0xcc);

        /// address: 0x400140d0
        /// GPIO status
        pub const GPIO26_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0xd0);

        /// address: 0x400140d4
        /// GPIO control including function select and overrides.
        pub const GPIO26_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0xd4);

        /// address: 0x400140d8
        /// GPIO status
        pub const GPIO27_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0xd8);

        /// address: 0x400140dc
        /// GPIO control including function select and overrides.
        pub const GPIO27_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0xdc);

        /// address: 0x400140e0
        /// GPIO status
        pub const GPIO28_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0xe0);

        /// address: 0x400140e4
        /// GPIO control including function select and overrides.
        pub const GPIO28_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0xe4);

        /// address: 0x400140e8
        /// GPIO status
        pub const GPIO29_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0xe8);

        /// address: 0x400140ec
        /// GPIO control including function select and overrides.
        pub const GPIO29_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0xec);

        /// address: 0x400140f0
        /// Raw Interrupts
        pub const INTR0 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO0_LEVEL_LOW: u1,
            GPIO0_LEVEL_HIGH: u1,
            GPIO0_EDGE_LOW: u1,
            GPIO0_EDGE_HIGH: u1,
            GPIO1_LEVEL_LOW: u1,
            GPIO1_LEVEL_HIGH: u1,
            GPIO1_EDGE_LOW: u1,
            GPIO1_EDGE_HIGH: u1,
            GPIO2_LEVEL_LOW: u1,
            GPIO2_LEVEL_HIGH: u1,
            GPIO2_EDGE_LOW: u1,
            GPIO2_EDGE_HIGH: u1,
            GPIO3_LEVEL_LOW: u1,
            GPIO3_LEVEL_HIGH: u1,
            GPIO3_EDGE_LOW: u1,
            GPIO3_EDGE_HIGH: u1,
            GPIO4_LEVEL_LOW: u1,
            GPIO4_LEVEL_HIGH: u1,
            GPIO4_EDGE_LOW: u1,
            GPIO4_EDGE_HIGH: u1,
            GPIO5_LEVEL_LOW: u1,
            GPIO5_LEVEL_HIGH: u1,
            GPIO5_EDGE_LOW: u1,
            GPIO5_EDGE_HIGH: u1,
            GPIO6_LEVEL_LOW: u1,
            GPIO6_LEVEL_HIGH: u1,
            GPIO6_EDGE_LOW: u1,
            GPIO6_EDGE_HIGH: u1,
            GPIO7_LEVEL_LOW: u1,
            GPIO7_LEVEL_HIGH: u1,
            GPIO7_EDGE_LOW: u1,
            GPIO7_EDGE_HIGH: u1,
        }), base_address + 0xf0);

        /// address: 0x400140f4
        /// Raw Interrupts
        pub const INTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO8_LEVEL_LOW: u1,
            GPIO8_LEVEL_HIGH: u1,
            GPIO8_EDGE_LOW: u1,
            GPIO8_EDGE_HIGH: u1,
            GPIO9_LEVEL_LOW: u1,
            GPIO9_LEVEL_HIGH: u1,
            GPIO9_EDGE_LOW: u1,
            GPIO9_EDGE_HIGH: u1,
            GPIO10_LEVEL_LOW: u1,
            GPIO10_LEVEL_HIGH: u1,
            GPIO10_EDGE_LOW: u1,
            GPIO10_EDGE_HIGH: u1,
            GPIO11_LEVEL_LOW: u1,
            GPIO11_LEVEL_HIGH: u1,
            GPIO11_EDGE_LOW: u1,
            GPIO11_EDGE_HIGH: u1,
            GPIO12_LEVEL_LOW: u1,
            GPIO12_LEVEL_HIGH: u1,
            GPIO12_EDGE_LOW: u1,
            GPIO12_EDGE_HIGH: u1,
            GPIO13_LEVEL_LOW: u1,
            GPIO13_LEVEL_HIGH: u1,
            GPIO13_EDGE_LOW: u1,
            GPIO13_EDGE_HIGH: u1,
            GPIO14_LEVEL_LOW: u1,
            GPIO14_LEVEL_HIGH: u1,
            GPIO14_EDGE_LOW: u1,
            GPIO14_EDGE_HIGH: u1,
            GPIO15_LEVEL_LOW: u1,
            GPIO15_LEVEL_HIGH: u1,
            GPIO15_EDGE_LOW: u1,
            GPIO15_EDGE_HIGH: u1,
        }), base_address + 0xf4);

        /// address: 0x400140f8
        /// Raw Interrupts
        pub const INTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO16_LEVEL_LOW: u1,
            GPIO16_LEVEL_HIGH: u1,
            GPIO16_EDGE_LOW: u1,
            GPIO16_EDGE_HIGH: u1,
            GPIO17_LEVEL_LOW: u1,
            GPIO17_LEVEL_HIGH: u1,
            GPIO17_EDGE_LOW: u1,
            GPIO17_EDGE_HIGH: u1,
            GPIO18_LEVEL_LOW: u1,
            GPIO18_LEVEL_HIGH: u1,
            GPIO18_EDGE_LOW: u1,
            GPIO18_EDGE_HIGH: u1,
            GPIO19_LEVEL_LOW: u1,
            GPIO19_LEVEL_HIGH: u1,
            GPIO19_EDGE_LOW: u1,
            GPIO19_EDGE_HIGH: u1,
            GPIO20_LEVEL_LOW: u1,
            GPIO20_LEVEL_HIGH: u1,
            GPIO20_EDGE_LOW: u1,
            GPIO20_EDGE_HIGH: u1,
            GPIO21_LEVEL_LOW: u1,
            GPIO21_LEVEL_HIGH: u1,
            GPIO21_EDGE_LOW: u1,
            GPIO21_EDGE_HIGH: u1,
            GPIO22_LEVEL_LOW: u1,
            GPIO22_LEVEL_HIGH: u1,
            GPIO22_EDGE_LOW: u1,
            GPIO22_EDGE_HIGH: u1,
            GPIO23_LEVEL_LOW: u1,
            GPIO23_LEVEL_HIGH: u1,
            GPIO23_EDGE_LOW: u1,
            GPIO23_EDGE_HIGH: u1,
        }), base_address + 0xf8);

        /// address: 0x400140fc
        /// Raw Interrupts
        pub const INTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO24_LEVEL_LOW: u1,
            GPIO24_LEVEL_HIGH: u1,
            GPIO24_EDGE_LOW: u1,
            GPIO24_EDGE_HIGH: u1,
            GPIO25_LEVEL_LOW: u1,
            GPIO25_LEVEL_HIGH: u1,
            GPIO25_EDGE_LOW: u1,
            GPIO25_EDGE_HIGH: u1,
            GPIO26_LEVEL_LOW: u1,
            GPIO26_LEVEL_HIGH: u1,
            GPIO26_EDGE_LOW: u1,
            GPIO26_EDGE_HIGH: u1,
            GPIO27_LEVEL_LOW: u1,
            GPIO27_LEVEL_HIGH: u1,
            GPIO27_EDGE_LOW: u1,
            GPIO27_EDGE_HIGH: u1,
            GPIO28_LEVEL_LOW: u1,
            GPIO28_LEVEL_HIGH: u1,
            GPIO28_EDGE_LOW: u1,
            GPIO28_EDGE_HIGH: u1,
            GPIO29_LEVEL_LOW: u1,
            GPIO29_LEVEL_HIGH: u1,
            GPIO29_EDGE_LOW: u1,
            GPIO29_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0xfc);

        /// address: 0x40014100
        /// Interrupt Enable for proc0
        pub const PROC0_INTE0 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO0_LEVEL_LOW: u1,
            GPIO0_LEVEL_HIGH: u1,
            GPIO0_EDGE_LOW: u1,
            GPIO0_EDGE_HIGH: u1,
            GPIO1_LEVEL_LOW: u1,
            GPIO1_LEVEL_HIGH: u1,
            GPIO1_EDGE_LOW: u1,
            GPIO1_EDGE_HIGH: u1,
            GPIO2_LEVEL_LOW: u1,
            GPIO2_LEVEL_HIGH: u1,
            GPIO2_EDGE_LOW: u1,
            GPIO2_EDGE_HIGH: u1,
            GPIO3_LEVEL_LOW: u1,
            GPIO3_LEVEL_HIGH: u1,
            GPIO3_EDGE_LOW: u1,
            GPIO3_EDGE_HIGH: u1,
            GPIO4_LEVEL_LOW: u1,
            GPIO4_LEVEL_HIGH: u1,
            GPIO4_EDGE_LOW: u1,
            GPIO4_EDGE_HIGH: u1,
            GPIO5_LEVEL_LOW: u1,
            GPIO5_LEVEL_HIGH: u1,
            GPIO5_EDGE_LOW: u1,
            GPIO5_EDGE_HIGH: u1,
            GPIO6_LEVEL_LOW: u1,
            GPIO6_LEVEL_HIGH: u1,
            GPIO6_EDGE_LOW: u1,
            GPIO6_EDGE_HIGH: u1,
            GPIO7_LEVEL_LOW: u1,
            GPIO7_LEVEL_HIGH: u1,
            GPIO7_EDGE_LOW: u1,
            GPIO7_EDGE_HIGH: u1,
        }), base_address + 0x100);

        /// address: 0x40014104
        /// Interrupt Enable for proc0
        pub const PROC0_INTE1 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO8_LEVEL_LOW: u1,
            GPIO8_LEVEL_HIGH: u1,
            GPIO8_EDGE_LOW: u1,
            GPIO8_EDGE_HIGH: u1,
            GPIO9_LEVEL_LOW: u1,
            GPIO9_LEVEL_HIGH: u1,
            GPIO9_EDGE_LOW: u1,
            GPIO9_EDGE_HIGH: u1,
            GPIO10_LEVEL_LOW: u1,
            GPIO10_LEVEL_HIGH: u1,
            GPIO10_EDGE_LOW: u1,
            GPIO10_EDGE_HIGH: u1,
            GPIO11_LEVEL_LOW: u1,
            GPIO11_LEVEL_HIGH: u1,
            GPIO11_EDGE_LOW: u1,
            GPIO11_EDGE_HIGH: u1,
            GPIO12_LEVEL_LOW: u1,
            GPIO12_LEVEL_HIGH: u1,
            GPIO12_EDGE_LOW: u1,
            GPIO12_EDGE_HIGH: u1,
            GPIO13_LEVEL_LOW: u1,
            GPIO13_LEVEL_HIGH: u1,
            GPIO13_EDGE_LOW: u1,
            GPIO13_EDGE_HIGH: u1,
            GPIO14_LEVEL_LOW: u1,
            GPIO14_LEVEL_HIGH: u1,
            GPIO14_EDGE_LOW: u1,
            GPIO14_EDGE_HIGH: u1,
            GPIO15_LEVEL_LOW: u1,
            GPIO15_LEVEL_HIGH: u1,
            GPIO15_EDGE_LOW: u1,
            GPIO15_EDGE_HIGH: u1,
        }), base_address + 0x104);

        /// address: 0x40014108
        /// Interrupt Enable for proc0
        pub const PROC0_INTE2 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO16_LEVEL_LOW: u1,
            GPIO16_LEVEL_HIGH: u1,
            GPIO16_EDGE_LOW: u1,
            GPIO16_EDGE_HIGH: u1,
            GPIO17_LEVEL_LOW: u1,
            GPIO17_LEVEL_HIGH: u1,
            GPIO17_EDGE_LOW: u1,
            GPIO17_EDGE_HIGH: u1,
            GPIO18_LEVEL_LOW: u1,
            GPIO18_LEVEL_HIGH: u1,
            GPIO18_EDGE_LOW: u1,
            GPIO18_EDGE_HIGH: u1,
            GPIO19_LEVEL_LOW: u1,
            GPIO19_LEVEL_HIGH: u1,
            GPIO19_EDGE_LOW: u1,
            GPIO19_EDGE_HIGH: u1,
            GPIO20_LEVEL_LOW: u1,
            GPIO20_LEVEL_HIGH: u1,
            GPIO20_EDGE_LOW: u1,
            GPIO20_EDGE_HIGH: u1,
            GPIO21_LEVEL_LOW: u1,
            GPIO21_LEVEL_HIGH: u1,
            GPIO21_EDGE_LOW: u1,
            GPIO21_EDGE_HIGH: u1,
            GPIO22_LEVEL_LOW: u1,
            GPIO22_LEVEL_HIGH: u1,
            GPIO22_EDGE_LOW: u1,
            GPIO22_EDGE_HIGH: u1,
            GPIO23_LEVEL_LOW: u1,
            GPIO23_LEVEL_HIGH: u1,
            GPIO23_EDGE_LOW: u1,
            GPIO23_EDGE_HIGH: u1,
        }), base_address + 0x108);

        /// address: 0x4001410c
        /// Interrupt Enable for proc0
        pub const PROC0_INTE3 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO24_LEVEL_LOW: u1,
            GPIO24_LEVEL_HIGH: u1,
            GPIO24_EDGE_LOW: u1,
            GPIO24_EDGE_HIGH: u1,
            GPIO25_LEVEL_LOW: u1,
            GPIO25_LEVEL_HIGH: u1,
            GPIO25_EDGE_LOW: u1,
            GPIO25_EDGE_HIGH: u1,
            GPIO26_LEVEL_LOW: u1,
            GPIO26_LEVEL_HIGH: u1,
            GPIO26_EDGE_LOW: u1,
            GPIO26_EDGE_HIGH: u1,
            GPIO27_LEVEL_LOW: u1,
            GPIO27_LEVEL_HIGH: u1,
            GPIO27_EDGE_LOW: u1,
            GPIO27_EDGE_HIGH: u1,
            GPIO28_LEVEL_LOW: u1,
            GPIO28_LEVEL_HIGH: u1,
            GPIO28_EDGE_LOW: u1,
            GPIO28_EDGE_HIGH: u1,
            GPIO29_LEVEL_LOW: u1,
            GPIO29_LEVEL_HIGH: u1,
            GPIO29_EDGE_LOW: u1,
            GPIO29_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x10c);

        /// address: 0x40014110
        /// Interrupt Force for proc0
        pub const PROC0_INTF0 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO0_LEVEL_LOW: u1,
            GPIO0_LEVEL_HIGH: u1,
            GPIO0_EDGE_LOW: u1,
            GPIO0_EDGE_HIGH: u1,
            GPIO1_LEVEL_LOW: u1,
            GPIO1_LEVEL_HIGH: u1,
            GPIO1_EDGE_LOW: u1,
            GPIO1_EDGE_HIGH: u1,
            GPIO2_LEVEL_LOW: u1,
            GPIO2_LEVEL_HIGH: u1,
            GPIO2_EDGE_LOW: u1,
            GPIO2_EDGE_HIGH: u1,
            GPIO3_LEVEL_LOW: u1,
            GPIO3_LEVEL_HIGH: u1,
            GPIO3_EDGE_LOW: u1,
            GPIO3_EDGE_HIGH: u1,
            GPIO4_LEVEL_LOW: u1,
            GPIO4_LEVEL_HIGH: u1,
            GPIO4_EDGE_LOW: u1,
            GPIO4_EDGE_HIGH: u1,
            GPIO5_LEVEL_LOW: u1,
            GPIO5_LEVEL_HIGH: u1,
            GPIO5_EDGE_LOW: u1,
            GPIO5_EDGE_HIGH: u1,
            GPIO6_LEVEL_LOW: u1,
            GPIO6_LEVEL_HIGH: u1,
            GPIO6_EDGE_LOW: u1,
            GPIO6_EDGE_HIGH: u1,
            GPIO7_LEVEL_LOW: u1,
            GPIO7_LEVEL_HIGH: u1,
            GPIO7_EDGE_LOW: u1,
            GPIO7_EDGE_HIGH: u1,
        }), base_address + 0x110);

        /// address: 0x40014114
        /// Interrupt Force for proc0
        pub const PROC0_INTF1 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO8_LEVEL_LOW: u1,
            GPIO8_LEVEL_HIGH: u1,
            GPIO8_EDGE_LOW: u1,
            GPIO8_EDGE_HIGH: u1,
            GPIO9_LEVEL_LOW: u1,
            GPIO9_LEVEL_HIGH: u1,
            GPIO9_EDGE_LOW: u1,
            GPIO9_EDGE_HIGH: u1,
            GPIO10_LEVEL_LOW: u1,
            GPIO10_LEVEL_HIGH: u1,
            GPIO10_EDGE_LOW: u1,
            GPIO10_EDGE_HIGH: u1,
            GPIO11_LEVEL_LOW: u1,
            GPIO11_LEVEL_HIGH: u1,
            GPIO11_EDGE_LOW: u1,
            GPIO11_EDGE_HIGH: u1,
            GPIO12_LEVEL_LOW: u1,
            GPIO12_LEVEL_HIGH: u1,
            GPIO12_EDGE_LOW: u1,
            GPIO12_EDGE_HIGH: u1,
            GPIO13_LEVEL_LOW: u1,
            GPIO13_LEVEL_HIGH: u1,
            GPIO13_EDGE_LOW: u1,
            GPIO13_EDGE_HIGH: u1,
            GPIO14_LEVEL_LOW: u1,
            GPIO14_LEVEL_HIGH: u1,
            GPIO14_EDGE_LOW: u1,
            GPIO14_EDGE_HIGH: u1,
            GPIO15_LEVEL_LOW: u1,
            GPIO15_LEVEL_HIGH: u1,
            GPIO15_EDGE_LOW: u1,
            GPIO15_EDGE_HIGH: u1,
        }), base_address + 0x114);

        /// address: 0x40014118
        /// Interrupt Force for proc0
        pub const PROC0_INTF2 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO16_LEVEL_LOW: u1,
            GPIO16_LEVEL_HIGH: u1,
            GPIO16_EDGE_LOW: u1,
            GPIO16_EDGE_HIGH: u1,
            GPIO17_LEVEL_LOW: u1,
            GPIO17_LEVEL_HIGH: u1,
            GPIO17_EDGE_LOW: u1,
            GPIO17_EDGE_HIGH: u1,
            GPIO18_LEVEL_LOW: u1,
            GPIO18_LEVEL_HIGH: u1,
            GPIO18_EDGE_LOW: u1,
            GPIO18_EDGE_HIGH: u1,
            GPIO19_LEVEL_LOW: u1,
            GPIO19_LEVEL_HIGH: u1,
            GPIO19_EDGE_LOW: u1,
            GPIO19_EDGE_HIGH: u1,
            GPIO20_LEVEL_LOW: u1,
            GPIO20_LEVEL_HIGH: u1,
            GPIO20_EDGE_LOW: u1,
            GPIO20_EDGE_HIGH: u1,
            GPIO21_LEVEL_LOW: u1,
            GPIO21_LEVEL_HIGH: u1,
            GPIO21_EDGE_LOW: u1,
            GPIO21_EDGE_HIGH: u1,
            GPIO22_LEVEL_LOW: u1,
            GPIO22_LEVEL_HIGH: u1,
            GPIO22_EDGE_LOW: u1,
            GPIO22_EDGE_HIGH: u1,
            GPIO23_LEVEL_LOW: u1,
            GPIO23_LEVEL_HIGH: u1,
            GPIO23_EDGE_LOW: u1,
            GPIO23_EDGE_HIGH: u1,
        }), base_address + 0x118);

        /// address: 0x4001411c
        /// Interrupt Force for proc0
        pub const PROC0_INTF3 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO24_LEVEL_LOW: u1,
            GPIO24_LEVEL_HIGH: u1,
            GPIO24_EDGE_LOW: u1,
            GPIO24_EDGE_HIGH: u1,
            GPIO25_LEVEL_LOW: u1,
            GPIO25_LEVEL_HIGH: u1,
            GPIO25_EDGE_LOW: u1,
            GPIO25_EDGE_HIGH: u1,
            GPIO26_LEVEL_LOW: u1,
            GPIO26_LEVEL_HIGH: u1,
            GPIO26_EDGE_LOW: u1,
            GPIO26_EDGE_HIGH: u1,
            GPIO27_LEVEL_LOW: u1,
            GPIO27_LEVEL_HIGH: u1,
            GPIO27_EDGE_LOW: u1,
            GPIO27_EDGE_HIGH: u1,
            GPIO28_LEVEL_LOW: u1,
            GPIO28_LEVEL_HIGH: u1,
            GPIO28_EDGE_LOW: u1,
            GPIO28_EDGE_HIGH: u1,
            GPIO29_LEVEL_LOW: u1,
            GPIO29_LEVEL_HIGH: u1,
            GPIO29_EDGE_LOW: u1,
            GPIO29_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x11c);

        /// address: 0x40014120
        /// Interrupt status after masking & forcing for proc0
        pub const PROC0_INTS0 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO0_LEVEL_LOW: u1,
            GPIO0_LEVEL_HIGH: u1,
            GPIO0_EDGE_LOW: u1,
            GPIO0_EDGE_HIGH: u1,
            GPIO1_LEVEL_LOW: u1,
            GPIO1_LEVEL_HIGH: u1,
            GPIO1_EDGE_LOW: u1,
            GPIO1_EDGE_HIGH: u1,
            GPIO2_LEVEL_LOW: u1,
            GPIO2_LEVEL_HIGH: u1,
            GPIO2_EDGE_LOW: u1,
            GPIO2_EDGE_HIGH: u1,
            GPIO3_LEVEL_LOW: u1,
            GPIO3_LEVEL_HIGH: u1,
            GPIO3_EDGE_LOW: u1,
            GPIO3_EDGE_HIGH: u1,
            GPIO4_LEVEL_LOW: u1,
            GPIO4_LEVEL_HIGH: u1,
            GPIO4_EDGE_LOW: u1,
            GPIO4_EDGE_HIGH: u1,
            GPIO5_LEVEL_LOW: u1,
            GPIO5_LEVEL_HIGH: u1,
            GPIO5_EDGE_LOW: u1,
            GPIO5_EDGE_HIGH: u1,
            GPIO6_LEVEL_LOW: u1,
            GPIO6_LEVEL_HIGH: u1,
            GPIO6_EDGE_LOW: u1,
            GPIO6_EDGE_HIGH: u1,
            GPIO7_LEVEL_LOW: u1,
            GPIO7_LEVEL_HIGH: u1,
            GPIO7_EDGE_LOW: u1,
            GPIO7_EDGE_HIGH: u1,
        }), base_address + 0x120);

        /// address: 0x40014124
        /// Interrupt status after masking & forcing for proc0
        pub const PROC0_INTS1 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO8_LEVEL_LOW: u1,
            GPIO8_LEVEL_HIGH: u1,
            GPIO8_EDGE_LOW: u1,
            GPIO8_EDGE_HIGH: u1,
            GPIO9_LEVEL_LOW: u1,
            GPIO9_LEVEL_HIGH: u1,
            GPIO9_EDGE_LOW: u1,
            GPIO9_EDGE_HIGH: u1,
            GPIO10_LEVEL_LOW: u1,
            GPIO10_LEVEL_HIGH: u1,
            GPIO10_EDGE_LOW: u1,
            GPIO10_EDGE_HIGH: u1,
            GPIO11_LEVEL_LOW: u1,
            GPIO11_LEVEL_HIGH: u1,
            GPIO11_EDGE_LOW: u1,
            GPIO11_EDGE_HIGH: u1,
            GPIO12_LEVEL_LOW: u1,
            GPIO12_LEVEL_HIGH: u1,
            GPIO12_EDGE_LOW: u1,
            GPIO12_EDGE_HIGH: u1,
            GPIO13_LEVEL_LOW: u1,
            GPIO13_LEVEL_HIGH: u1,
            GPIO13_EDGE_LOW: u1,
            GPIO13_EDGE_HIGH: u1,
            GPIO14_LEVEL_LOW: u1,
            GPIO14_LEVEL_HIGH: u1,
            GPIO14_EDGE_LOW: u1,
            GPIO14_EDGE_HIGH: u1,
            GPIO15_LEVEL_LOW: u1,
            GPIO15_LEVEL_HIGH: u1,
            GPIO15_EDGE_LOW: u1,
            GPIO15_EDGE_HIGH: u1,
        }), base_address + 0x124);

        /// address: 0x40014128
        /// Interrupt status after masking & forcing for proc0
        pub const PROC0_INTS2 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO16_LEVEL_LOW: u1,
            GPIO16_LEVEL_HIGH: u1,
            GPIO16_EDGE_LOW: u1,
            GPIO16_EDGE_HIGH: u1,
            GPIO17_LEVEL_LOW: u1,
            GPIO17_LEVEL_HIGH: u1,
            GPIO17_EDGE_LOW: u1,
            GPIO17_EDGE_HIGH: u1,
            GPIO18_LEVEL_LOW: u1,
            GPIO18_LEVEL_HIGH: u1,
            GPIO18_EDGE_LOW: u1,
            GPIO18_EDGE_HIGH: u1,
            GPIO19_LEVEL_LOW: u1,
            GPIO19_LEVEL_HIGH: u1,
            GPIO19_EDGE_LOW: u1,
            GPIO19_EDGE_HIGH: u1,
            GPIO20_LEVEL_LOW: u1,
            GPIO20_LEVEL_HIGH: u1,
            GPIO20_EDGE_LOW: u1,
            GPIO20_EDGE_HIGH: u1,
            GPIO21_LEVEL_LOW: u1,
            GPIO21_LEVEL_HIGH: u1,
            GPIO21_EDGE_LOW: u1,
            GPIO21_EDGE_HIGH: u1,
            GPIO22_LEVEL_LOW: u1,
            GPIO22_LEVEL_HIGH: u1,
            GPIO22_EDGE_LOW: u1,
            GPIO22_EDGE_HIGH: u1,
            GPIO23_LEVEL_LOW: u1,
            GPIO23_LEVEL_HIGH: u1,
            GPIO23_EDGE_LOW: u1,
            GPIO23_EDGE_HIGH: u1,
        }), base_address + 0x128);

        /// address: 0x4001412c
        /// Interrupt status after masking & forcing for proc0
        pub const PROC0_INTS3 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO24_LEVEL_LOW: u1,
            GPIO24_LEVEL_HIGH: u1,
            GPIO24_EDGE_LOW: u1,
            GPIO24_EDGE_HIGH: u1,
            GPIO25_LEVEL_LOW: u1,
            GPIO25_LEVEL_HIGH: u1,
            GPIO25_EDGE_LOW: u1,
            GPIO25_EDGE_HIGH: u1,
            GPIO26_LEVEL_LOW: u1,
            GPIO26_LEVEL_HIGH: u1,
            GPIO26_EDGE_LOW: u1,
            GPIO26_EDGE_HIGH: u1,
            GPIO27_LEVEL_LOW: u1,
            GPIO27_LEVEL_HIGH: u1,
            GPIO27_EDGE_LOW: u1,
            GPIO27_EDGE_HIGH: u1,
            GPIO28_LEVEL_LOW: u1,
            GPIO28_LEVEL_HIGH: u1,
            GPIO28_EDGE_LOW: u1,
            GPIO28_EDGE_HIGH: u1,
            GPIO29_LEVEL_LOW: u1,
            GPIO29_LEVEL_HIGH: u1,
            GPIO29_EDGE_LOW: u1,
            GPIO29_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x12c);

        /// address: 0x40014130
        /// Interrupt Enable for proc1
        pub const PROC1_INTE0 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO0_LEVEL_LOW: u1,
            GPIO0_LEVEL_HIGH: u1,
            GPIO0_EDGE_LOW: u1,
            GPIO0_EDGE_HIGH: u1,
            GPIO1_LEVEL_LOW: u1,
            GPIO1_LEVEL_HIGH: u1,
            GPIO1_EDGE_LOW: u1,
            GPIO1_EDGE_HIGH: u1,
            GPIO2_LEVEL_LOW: u1,
            GPIO2_LEVEL_HIGH: u1,
            GPIO2_EDGE_LOW: u1,
            GPIO2_EDGE_HIGH: u1,
            GPIO3_LEVEL_LOW: u1,
            GPIO3_LEVEL_HIGH: u1,
            GPIO3_EDGE_LOW: u1,
            GPIO3_EDGE_HIGH: u1,
            GPIO4_LEVEL_LOW: u1,
            GPIO4_LEVEL_HIGH: u1,
            GPIO4_EDGE_LOW: u1,
            GPIO4_EDGE_HIGH: u1,
            GPIO5_LEVEL_LOW: u1,
            GPIO5_LEVEL_HIGH: u1,
            GPIO5_EDGE_LOW: u1,
            GPIO5_EDGE_HIGH: u1,
            GPIO6_LEVEL_LOW: u1,
            GPIO6_LEVEL_HIGH: u1,
            GPIO6_EDGE_LOW: u1,
            GPIO6_EDGE_HIGH: u1,
            GPIO7_LEVEL_LOW: u1,
            GPIO7_LEVEL_HIGH: u1,
            GPIO7_EDGE_LOW: u1,
            GPIO7_EDGE_HIGH: u1,
        }), base_address + 0x130);

        /// address: 0x40014134
        /// Interrupt Enable for proc1
        pub const PROC1_INTE1 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO8_LEVEL_LOW: u1,
            GPIO8_LEVEL_HIGH: u1,
            GPIO8_EDGE_LOW: u1,
            GPIO8_EDGE_HIGH: u1,
            GPIO9_LEVEL_LOW: u1,
            GPIO9_LEVEL_HIGH: u1,
            GPIO9_EDGE_LOW: u1,
            GPIO9_EDGE_HIGH: u1,
            GPIO10_LEVEL_LOW: u1,
            GPIO10_LEVEL_HIGH: u1,
            GPIO10_EDGE_LOW: u1,
            GPIO10_EDGE_HIGH: u1,
            GPIO11_LEVEL_LOW: u1,
            GPIO11_LEVEL_HIGH: u1,
            GPIO11_EDGE_LOW: u1,
            GPIO11_EDGE_HIGH: u1,
            GPIO12_LEVEL_LOW: u1,
            GPIO12_LEVEL_HIGH: u1,
            GPIO12_EDGE_LOW: u1,
            GPIO12_EDGE_HIGH: u1,
            GPIO13_LEVEL_LOW: u1,
            GPIO13_LEVEL_HIGH: u1,
            GPIO13_EDGE_LOW: u1,
            GPIO13_EDGE_HIGH: u1,
            GPIO14_LEVEL_LOW: u1,
            GPIO14_LEVEL_HIGH: u1,
            GPIO14_EDGE_LOW: u1,
            GPIO14_EDGE_HIGH: u1,
            GPIO15_LEVEL_LOW: u1,
            GPIO15_LEVEL_HIGH: u1,
            GPIO15_EDGE_LOW: u1,
            GPIO15_EDGE_HIGH: u1,
        }), base_address + 0x134);

        /// address: 0x40014138
        /// Interrupt Enable for proc1
        pub const PROC1_INTE2 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO16_LEVEL_LOW: u1,
            GPIO16_LEVEL_HIGH: u1,
            GPIO16_EDGE_LOW: u1,
            GPIO16_EDGE_HIGH: u1,
            GPIO17_LEVEL_LOW: u1,
            GPIO17_LEVEL_HIGH: u1,
            GPIO17_EDGE_LOW: u1,
            GPIO17_EDGE_HIGH: u1,
            GPIO18_LEVEL_LOW: u1,
            GPIO18_LEVEL_HIGH: u1,
            GPIO18_EDGE_LOW: u1,
            GPIO18_EDGE_HIGH: u1,
            GPIO19_LEVEL_LOW: u1,
            GPIO19_LEVEL_HIGH: u1,
            GPIO19_EDGE_LOW: u1,
            GPIO19_EDGE_HIGH: u1,
            GPIO20_LEVEL_LOW: u1,
            GPIO20_LEVEL_HIGH: u1,
            GPIO20_EDGE_LOW: u1,
            GPIO20_EDGE_HIGH: u1,
            GPIO21_LEVEL_LOW: u1,
            GPIO21_LEVEL_HIGH: u1,
            GPIO21_EDGE_LOW: u1,
            GPIO21_EDGE_HIGH: u1,
            GPIO22_LEVEL_LOW: u1,
            GPIO22_LEVEL_HIGH: u1,
            GPIO22_EDGE_LOW: u1,
            GPIO22_EDGE_HIGH: u1,
            GPIO23_LEVEL_LOW: u1,
            GPIO23_LEVEL_HIGH: u1,
            GPIO23_EDGE_LOW: u1,
            GPIO23_EDGE_HIGH: u1,
        }), base_address + 0x138);

        /// address: 0x4001413c
        /// Interrupt Enable for proc1
        pub const PROC1_INTE3 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO24_LEVEL_LOW: u1,
            GPIO24_LEVEL_HIGH: u1,
            GPIO24_EDGE_LOW: u1,
            GPIO24_EDGE_HIGH: u1,
            GPIO25_LEVEL_LOW: u1,
            GPIO25_LEVEL_HIGH: u1,
            GPIO25_EDGE_LOW: u1,
            GPIO25_EDGE_HIGH: u1,
            GPIO26_LEVEL_LOW: u1,
            GPIO26_LEVEL_HIGH: u1,
            GPIO26_EDGE_LOW: u1,
            GPIO26_EDGE_HIGH: u1,
            GPIO27_LEVEL_LOW: u1,
            GPIO27_LEVEL_HIGH: u1,
            GPIO27_EDGE_LOW: u1,
            GPIO27_EDGE_HIGH: u1,
            GPIO28_LEVEL_LOW: u1,
            GPIO28_LEVEL_HIGH: u1,
            GPIO28_EDGE_LOW: u1,
            GPIO28_EDGE_HIGH: u1,
            GPIO29_LEVEL_LOW: u1,
            GPIO29_LEVEL_HIGH: u1,
            GPIO29_EDGE_LOW: u1,
            GPIO29_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x13c);

        /// address: 0x40014140
        /// Interrupt Force for proc1
        pub const PROC1_INTF0 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO0_LEVEL_LOW: u1,
            GPIO0_LEVEL_HIGH: u1,
            GPIO0_EDGE_LOW: u1,
            GPIO0_EDGE_HIGH: u1,
            GPIO1_LEVEL_LOW: u1,
            GPIO1_LEVEL_HIGH: u1,
            GPIO1_EDGE_LOW: u1,
            GPIO1_EDGE_HIGH: u1,
            GPIO2_LEVEL_LOW: u1,
            GPIO2_LEVEL_HIGH: u1,
            GPIO2_EDGE_LOW: u1,
            GPIO2_EDGE_HIGH: u1,
            GPIO3_LEVEL_LOW: u1,
            GPIO3_LEVEL_HIGH: u1,
            GPIO3_EDGE_LOW: u1,
            GPIO3_EDGE_HIGH: u1,
            GPIO4_LEVEL_LOW: u1,
            GPIO4_LEVEL_HIGH: u1,
            GPIO4_EDGE_LOW: u1,
            GPIO4_EDGE_HIGH: u1,
            GPIO5_LEVEL_LOW: u1,
            GPIO5_LEVEL_HIGH: u1,
            GPIO5_EDGE_LOW: u1,
            GPIO5_EDGE_HIGH: u1,
            GPIO6_LEVEL_LOW: u1,
            GPIO6_LEVEL_HIGH: u1,
            GPIO6_EDGE_LOW: u1,
            GPIO6_EDGE_HIGH: u1,
            GPIO7_LEVEL_LOW: u1,
            GPIO7_LEVEL_HIGH: u1,
            GPIO7_EDGE_LOW: u1,
            GPIO7_EDGE_HIGH: u1,
        }), base_address + 0x140);

        /// address: 0x40014144
        /// Interrupt Force for proc1
        pub const PROC1_INTF1 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO8_LEVEL_LOW: u1,
            GPIO8_LEVEL_HIGH: u1,
            GPIO8_EDGE_LOW: u1,
            GPIO8_EDGE_HIGH: u1,
            GPIO9_LEVEL_LOW: u1,
            GPIO9_LEVEL_HIGH: u1,
            GPIO9_EDGE_LOW: u1,
            GPIO9_EDGE_HIGH: u1,
            GPIO10_LEVEL_LOW: u1,
            GPIO10_LEVEL_HIGH: u1,
            GPIO10_EDGE_LOW: u1,
            GPIO10_EDGE_HIGH: u1,
            GPIO11_LEVEL_LOW: u1,
            GPIO11_LEVEL_HIGH: u1,
            GPIO11_EDGE_LOW: u1,
            GPIO11_EDGE_HIGH: u1,
            GPIO12_LEVEL_LOW: u1,
            GPIO12_LEVEL_HIGH: u1,
            GPIO12_EDGE_LOW: u1,
            GPIO12_EDGE_HIGH: u1,
            GPIO13_LEVEL_LOW: u1,
            GPIO13_LEVEL_HIGH: u1,
            GPIO13_EDGE_LOW: u1,
            GPIO13_EDGE_HIGH: u1,
            GPIO14_LEVEL_LOW: u1,
            GPIO14_LEVEL_HIGH: u1,
            GPIO14_EDGE_LOW: u1,
            GPIO14_EDGE_HIGH: u1,
            GPIO15_LEVEL_LOW: u1,
            GPIO15_LEVEL_HIGH: u1,
            GPIO15_EDGE_LOW: u1,
            GPIO15_EDGE_HIGH: u1,
        }), base_address + 0x144);

        /// address: 0x40014148
        /// Interrupt Force for proc1
        pub const PROC1_INTF2 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO16_LEVEL_LOW: u1,
            GPIO16_LEVEL_HIGH: u1,
            GPIO16_EDGE_LOW: u1,
            GPIO16_EDGE_HIGH: u1,
            GPIO17_LEVEL_LOW: u1,
            GPIO17_LEVEL_HIGH: u1,
            GPIO17_EDGE_LOW: u1,
            GPIO17_EDGE_HIGH: u1,
            GPIO18_LEVEL_LOW: u1,
            GPIO18_LEVEL_HIGH: u1,
            GPIO18_EDGE_LOW: u1,
            GPIO18_EDGE_HIGH: u1,
            GPIO19_LEVEL_LOW: u1,
            GPIO19_LEVEL_HIGH: u1,
            GPIO19_EDGE_LOW: u1,
            GPIO19_EDGE_HIGH: u1,
            GPIO20_LEVEL_LOW: u1,
            GPIO20_LEVEL_HIGH: u1,
            GPIO20_EDGE_LOW: u1,
            GPIO20_EDGE_HIGH: u1,
            GPIO21_LEVEL_LOW: u1,
            GPIO21_LEVEL_HIGH: u1,
            GPIO21_EDGE_LOW: u1,
            GPIO21_EDGE_HIGH: u1,
            GPIO22_LEVEL_LOW: u1,
            GPIO22_LEVEL_HIGH: u1,
            GPIO22_EDGE_LOW: u1,
            GPIO22_EDGE_HIGH: u1,
            GPIO23_LEVEL_LOW: u1,
            GPIO23_LEVEL_HIGH: u1,
            GPIO23_EDGE_LOW: u1,
            GPIO23_EDGE_HIGH: u1,
        }), base_address + 0x148);

        /// address: 0x4001414c
        /// Interrupt Force for proc1
        pub const PROC1_INTF3 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO24_LEVEL_LOW: u1,
            GPIO24_LEVEL_HIGH: u1,
            GPIO24_EDGE_LOW: u1,
            GPIO24_EDGE_HIGH: u1,
            GPIO25_LEVEL_LOW: u1,
            GPIO25_LEVEL_HIGH: u1,
            GPIO25_EDGE_LOW: u1,
            GPIO25_EDGE_HIGH: u1,
            GPIO26_LEVEL_LOW: u1,
            GPIO26_LEVEL_HIGH: u1,
            GPIO26_EDGE_LOW: u1,
            GPIO26_EDGE_HIGH: u1,
            GPIO27_LEVEL_LOW: u1,
            GPIO27_LEVEL_HIGH: u1,
            GPIO27_EDGE_LOW: u1,
            GPIO27_EDGE_HIGH: u1,
            GPIO28_LEVEL_LOW: u1,
            GPIO28_LEVEL_HIGH: u1,
            GPIO28_EDGE_LOW: u1,
            GPIO28_EDGE_HIGH: u1,
            GPIO29_LEVEL_LOW: u1,
            GPIO29_LEVEL_HIGH: u1,
            GPIO29_EDGE_LOW: u1,
            GPIO29_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x14c);

        /// address: 0x40014150
        /// Interrupt status after masking & forcing for proc1
        pub const PROC1_INTS0 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO0_LEVEL_LOW: u1,
            GPIO0_LEVEL_HIGH: u1,
            GPIO0_EDGE_LOW: u1,
            GPIO0_EDGE_HIGH: u1,
            GPIO1_LEVEL_LOW: u1,
            GPIO1_LEVEL_HIGH: u1,
            GPIO1_EDGE_LOW: u1,
            GPIO1_EDGE_HIGH: u1,
            GPIO2_LEVEL_LOW: u1,
            GPIO2_LEVEL_HIGH: u1,
            GPIO2_EDGE_LOW: u1,
            GPIO2_EDGE_HIGH: u1,
            GPIO3_LEVEL_LOW: u1,
            GPIO3_LEVEL_HIGH: u1,
            GPIO3_EDGE_LOW: u1,
            GPIO3_EDGE_HIGH: u1,
            GPIO4_LEVEL_LOW: u1,
            GPIO4_LEVEL_HIGH: u1,
            GPIO4_EDGE_LOW: u1,
            GPIO4_EDGE_HIGH: u1,
            GPIO5_LEVEL_LOW: u1,
            GPIO5_LEVEL_HIGH: u1,
            GPIO5_EDGE_LOW: u1,
            GPIO5_EDGE_HIGH: u1,
            GPIO6_LEVEL_LOW: u1,
            GPIO6_LEVEL_HIGH: u1,
            GPIO6_EDGE_LOW: u1,
            GPIO6_EDGE_HIGH: u1,
            GPIO7_LEVEL_LOW: u1,
            GPIO7_LEVEL_HIGH: u1,
            GPIO7_EDGE_LOW: u1,
            GPIO7_EDGE_HIGH: u1,
        }), base_address + 0x150);

        /// address: 0x40014154
        /// Interrupt status after masking & forcing for proc1
        pub const PROC1_INTS1 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO8_LEVEL_LOW: u1,
            GPIO8_LEVEL_HIGH: u1,
            GPIO8_EDGE_LOW: u1,
            GPIO8_EDGE_HIGH: u1,
            GPIO9_LEVEL_LOW: u1,
            GPIO9_LEVEL_HIGH: u1,
            GPIO9_EDGE_LOW: u1,
            GPIO9_EDGE_HIGH: u1,
            GPIO10_LEVEL_LOW: u1,
            GPIO10_LEVEL_HIGH: u1,
            GPIO10_EDGE_LOW: u1,
            GPIO10_EDGE_HIGH: u1,
            GPIO11_LEVEL_LOW: u1,
            GPIO11_LEVEL_HIGH: u1,
            GPIO11_EDGE_LOW: u1,
            GPIO11_EDGE_HIGH: u1,
            GPIO12_LEVEL_LOW: u1,
            GPIO12_LEVEL_HIGH: u1,
            GPIO12_EDGE_LOW: u1,
            GPIO12_EDGE_HIGH: u1,
            GPIO13_LEVEL_LOW: u1,
            GPIO13_LEVEL_HIGH: u1,
            GPIO13_EDGE_LOW: u1,
            GPIO13_EDGE_HIGH: u1,
            GPIO14_LEVEL_LOW: u1,
            GPIO14_LEVEL_HIGH: u1,
            GPIO14_EDGE_LOW: u1,
            GPIO14_EDGE_HIGH: u1,
            GPIO15_LEVEL_LOW: u1,
            GPIO15_LEVEL_HIGH: u1,
            GPIO15_EDGE_LOW: u1,
            GPIO15_EDGE_HIGH: u1,
        }), base_address + 0x154);

        /// address: 0x40014158
        /// Interrupt status after masking & forcing for proc1
        pub const PROC1_INTS2 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO16_LEVEL_LOW: u1,
            GPIO16_LEVEL_HIGH: u1,
            GPIO16_EDGE_LOW: u1,
            GPIO16_EDGE_HIGH: u1,
            GPIO17_LEVEL_LOW: u1,
            GPIO17_LEVEL_HIGH: u1,
            GPIO17_EDGE_LOW: u1,
            GPIO17_EDGE_HIGH: u1,
            GPIO18_LEVEL_LOW: u1,
            GPIO18_LEVEL_HIGH: u1,
            GPIO18_EDGE_LOW: u1,
            GPIO18_EDGE_HIGH: u1,
            GPIO19_LEVEL_LOW: u1,
            GPIO19_LEVEL_HIGH: u1,
            GPIO19_EDGE_LOW: u1,
            GPIO19_EDGE_HIGH: u1,
            GPIO20_LEVEL_LOW: u1,
            GPIO20_LEVEL_HIGH: u1,
            GPIO20_EDGE_LOW: u1,
            GPIO20_EDGE_HIGH: u1,
            GPIO21_LEVEL_LOW: u1,
            GPIO21_LEVEL_HIGH: u1,
            GPIO21_EDGE_LOW: u1,
            GPIO21_EDGE_HIGH: u1,
            GPIO22_LEVEL_LOW: u1,
            GPIO22_LEVEL_HIGH: u1,
            GPIO22_EDGE_LOW: u1,
            GPIO22_EDGE_HIGH: u1,
            GPIO23_LEVEL_LOW: u1,
            GPIO23_LEVEL_HIGH: u1,
            GPIO23_EDGE_LOW: u1,
            GPIO23_EDGE_HIGH: u1,
        }), base_address + 0x158);

        /// address: 0x4001415c
        /// Interrupt status after masking & forcing for proc1
        pub const PROC1_INTS3 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO24_LEVEL_LOW: u1,
            GPIO24_LEVEL_HIGH: u1,
            GPIO24_EDGE_LOW: u1,
            GPIO24_EDGE_HIGH: u1,
            GPIO25_LEVEL_LOW: u1,
            GPIO25_LEVEL_HIGH: u1,
            GPIO25_EDGE_LOW: u1,
            GPIO25_EDGE_HIGH: u1,
            GPIO26_LEVEL_LOW: u1,
            GPIO26_LEVEL_HIGH: u1,
            GPIO26_EDGE_LOW: u1,
            GPIO26_EDGE_HIGH: u1,
            GPIO27_LEVEL_LOW: u1,
            GPIO27_LEVEL_HIGH: u1,
            GPIO27_EDGE_LOW: u1,
            GPIO27_EDGE_HIGH: u1,
            GPIO28_LEVEL_LOW: u1,
            GPIO28_LEVEL_HIGH: u1,
            GPIO28_EDGE_LOW: u1,
            GPIO28_EDGE_HIGH: u1,
            GPIO29_LEVEL_LOW: u1,
            GPIO29_LEVEL_HIGH: u1,
            GPIO29_EDGE_LOW: u1,
            GPIO29_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x15c);

        /// address: 0x40014160
        /// Interrupt Enable for dormant_wake
        pub const DORMANT_WAKE_INTE0 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO0_LEVEL_LOW: u1,
            GPIO0_LEVEL_HIGH: u1,
            GPIO0_EDGE_LOW: u1,
            GPIO0_EDGE_HIGH: u1,
            GPIO1_LEVEL_LOW: u1,
            GPIO1_LEVEL_HIGH: u1,
            GPIO1_EDGE_LOW: u1,
            GPIO1_EDGE_HIGH: u1,
            GPIO2_LEVEL_LOW: u1,
            GPIO2_LEVEL_HIGH: u1,
            GPIO2_EDGE_LOW: u1,
            GPIO2_EDGE_HIGH: u1,
            GPIO3_LEVEL_LOW: u1,
            GPIO3_LEVEL_HIGH: u1,
            GPIO3_EDGE_LOW: u1,
            GPIO3_EDGE_HIGH: u1,
            GPIO4_LEVEL_LOW: u1,
            GPIO4_LEVEL_HIGH: u1,
            GPIO4_EDGE_LOW: u1,
            GPIO4_EDGE_HIGH: u1,
            GPIO5_LEVEL_LOW: u1,
            GPIO5_LEVEL_HIGH: u1,
            GPIO5_EDGE_LOW: u1,
            GPIO5_EDGE_HIGH: u1,
            GPIO6_LEVEL_LOW: u1,
            GPIO6_LEVEL_HIGH: u1,
            GPIO6_EDGE_LOW: u1,
            GPIO6_EDGE_HIGH: u1,
            GPIO7_LEVEL_LOW: u1,
            GPIO7_LEVEL_HIGH: u1,
            GPIO7_EDGE_LOW: u1,
            GPIO7_EDGE_HIGH: u1,
        }), base_address + 0x160);

        /// address: 0x40014164
        /// Interrupt Enable for dormant_wake
        pub const DORMANT_WAKE_INTE1 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO8_LEVEL_LOW: u1,
            GPIO8_LEVEL_HIGH: u1,
            GPIO8_EDGE_LOW: u1,
            GPIO8_EDGE_HIGH: u1,
            GPIO9_LEVEL_LOW: u1,
            GPIO9_LEVEL_HIGH: u1,
            GPIO9_EDGE_LOW: u1,
            GPIO9_EDGE_HIGH: u1,
            GPIO10_LEVEL_LOW: u1,
            GPIO10_LEVEL_HIGH: u1,
            GPIO10_EDGE_LOW: u1,
            GPIO10_EDGE_HIGH: u1,
            GPIO11_LEVEL_LOW: u1,
            GPIO11_LEVEL_HIGH: u1,
            GPIO11_EDGE_LOW: u1,
            GPIO11_EDGE_HIGH: u1,
            GPIO12_LEVEL_LOW: u1,
            GPIO12_LEVEL_HIGH: u1,
            GPIO12_EDGE_LOW: u1,
            GPIO12_EDGE_HIGH: u1,
            GPIO13_LEVEL_LOW: u1,
            GPIO13_LEVEL_HIGH: u1,
            GPIO13_EDGE_LOW: u1,
            GPIO13_EDGE_HIGH: u1,
            GPIO14_LEVEL_LOW: u1,
            GPIO14_LEVEL_HIGH: u1,
            GPIO14_EDGE_LOW: u1,
            GPIO14_EDGE_HIGH: u1,
            GPIO15_LEVEL_LOW: u1,
            GPIO15_LEVEL_HIGH: u1,
            GPIO15_EDGE_LOW: u1,
            GPIO15_EDGE_HIGH: u1,
        }), base_address + 0x164);

        /// address: 0x40014168
        /// Interrupt Enable for dormant_wake
        pub const DORMANT_WAKE_INTE2 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO16_LEVEL_LOW: u1,
            GPIO16_LEVEL_HIGH: u1,
            GPIO16_EDGE_LOW: u1,
            GPIO16_EDGE_HIGH: u1,
            GPIO17_LEVEL_LOW: u1,
            GPIO17_LEVEL_HIGH: u1,
            GPIO17_EDGE_LOW: u1,
            GPIO17_EDGE_HIGH: u1,
            GPIO18_LEVEL_LOW: u1,
            GPIO18_LEVEL_HIGH: u1,
            GPIO18_EDGE_LOW: u1,
            GPIO18_EDGE_HIGH: u1,
            GPIO19_LEVEL_LOW: u1,
            GPIO19_LEVEL_HIGH: u1,
            GPIO19_EDGE_LOW: u1,
            GPIO19_EDGE_HIGH: u1,
            GPIO20_LEVEL_LOW: u1,
            GPIO20_LEVEL_HIGH: u1,
            GPIO20_EDGE_LOW: u1,
            GPIO20_EDGE_HIGH: u1,
            GPIO21_LEVEL_LOW: u1,
            GPIO21_LEVEL_HIGH: u1,
            GPIO21_EDGE_LOW: u1,
            GPIO21_EDGE_HIGH: u1,
            GPIO22_LEVEL_LOW: u1,
            GPIO22_LEVEL_HIGH: u1,
            GPIO22_EDGE_LOW: u1,
            GPIO22_EDGE_HIGH: u1,
            GPIO23_LEVEL_LOW: u1,
            GPIO23_LEVEL_HIGH: u1,
            GPIO23_EDGE_LOW: u1,
            GPIO23_EDGE_HIGH: u1,
        }), base_address + 0x168);

        /// address: 0x4001416c
        /// Interrupt Enable for dormant_wake
        pub const DORMANT_WAKE_INTE3 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO24_LEVEL_LOW: u1,
            GPIO24_LEVEL_HIGH: u1,
            GPIO24_EDGE_LOW: u1,
            GPIO24_EDGE_HIGH: u1,
            GPIO25_LEVEL_LOW: u1,
            GPIO25_LEVEL_HIGH: u1,
            GPIO25_EDGE_LOW: u1,
            GPIO25_EDGE_HIGH: u1,
            GPIO26_LEVEL_LOW: u1,
            GPIO26_LEVEL_HIGH: u1,
            GPIO26_EDGE_LOW: u1,
            GPIO26_EDGE_HIGH: u1,
            GPIO27_LEVEL_LOW: u1,
            GPIO27_LEVEL_HIGH: u1,
            GPIO27_EDGE_LOW: u1,
            GPIO27_EDGE_HIGH: u1,
            GPIO28_LEVEL_LOW: u1,
            GPIO28_LEVEL_HIGH: u1,
            GPIO28_EDGE_LOW: u1,
            GPIO28_EDGE_HIGH: u1,
            GPIO29_LEVEL_LOW: u1,
            GPIO29_LEVEL_HIGH: u1,
            GPIO29_EDGE_LOW: u1,
            GPIO29_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x16c);

        /// address: 0x40014170
        /// Interrupt Force for dormant_wake
        pub const DORMANT_WAKE_INTF0 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO0_LEVEL_LOW: u1,
            GPIO0_LEVEL_HIGH: u1,
            GPIO0_EDGE_LOW: u1,
            GPIO0_EDGE_HIGH: u1,
            GPIO1_LEVEL_LOW: u1,
            GPIO1_LEVEL_HIGH: u1,
            GPIO1_EDGE_LOW: u1,
            GPIO1_EDGE_HIGH: u1,
            GPIO2_LEVEL_LOW: u1,
            GPIO2_LEVEL_HIGH: u1,
            GPIO2_EDGE_LOW: u1,
            GPIO2_EDGE_HIGH: u1,
            GPIO3_LEVEL_LOW: u1,
            GPIO3_LEVEL_HIGH: u1,
            GPIO3_EDGE_LOW: u1,
            GPIO3_EDGE_HIGH: u1,
            GPIO4_LEVEL_LOW: u1,
            GPIO4_LEVEL_HIGH: u1,
            GPIO4_EDGE_LOW: u1,
            GPIO4_EDGE_HIGH: u1,
            GPIO5_LEVEL_LOW: u1,
            GPIO5_LEVEL_HIGH: u1,
            GPIO5_EDGE_LOW: u1,
            GPIO5_EDGE_HIGH: u1,
            GPIO6_LEVEL_LOW: u1,
            GPIO6_LEVEL_HIGH: u1,
            GPIO6_EDGE_LOW: u1,
            GPIO6_EDGE_HIGH: u1,
            GPIO7_LEVEL_LOW: u1,
            GPIO7_LEVEL_HIGH: u1,
            GPIO7_EDGE_LOW: u1,
            GPIO7_EDGE_HIGH: u1,
        }), base_address + 0x170);

        /// address: 0x40014174
        /// Interrupt Force for dormant_wake
        pub const DORMANT_WAKE_INTF1 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO8_LEVEL_LOW: u1,
            GPIO8_LEVEL_HIGH: u1,
            GPIO8_EDGE_LOW: u1,
            GPIO8_EDGE_HIGH: u1,
            GPIO9_LEVEL_LOW: u1,
            GPIO9_LEVEL_HIGH: u1,
            GPIO9_EDGE_LOW: u1,
            GPIO9_EDGE_HIGH: u1,
            GPIO10_LEVEL_LOW: u1,
            GPIO10_LEVEL_HIGH: u1,
            GPIO10_EDGE_LOW: u1,
            GPIO10_EDGE_HIGH: u1,
            GPIO11_LEVEL_LOW: u1,
            GPIO11_LEVEL_HIGH: u1,
            GPIO11_EDGE_LOW: u1,
            GPIO11_EDGE_HIGH: u1,
            GPIO12_LEVEL_LOW: u1,
            GPIO12_LEVEL_HIGH: u1,
            GPIO12_EDGE_LOW: u1,
            GPIO12_EDGE_HIGH: u1,
            GPIO13_LEVEL_LOW: u1,
            GPIO13_LEVEL_HIGH: u1,
            GPIO13_EDGE_LOW: u1,
            GPIO13_EDGE_HIGH: u1,
            GPIO14_LEVEL_LOW: u1,
            GPIO14_LEVEL_HIGH: u1,
            GPIO14_EDGE_LOW: u1,
            GPIO14_EDGE_HIGH: u1,
            GPIO15_LEVEL_LOW: u1,
            GPIO15_LEVEL_HIGH: u1,
            GPIO15_EDGE_LOW: u1,
            GPIO15_EDGE_HIGH: u1,
        }), base_address + 0x174);

        /// address: 0x40014178
        /// Interrupt Force for dormant_wake
        pub const DORMANT_WAKE_INTF2 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO16_LEVEL_LOW: u1,
            GPIO16_LEVEL_HIGH: u1,
            GPIO16_EDGE_LOW: u1,
            GPIO16_EDGE_HIGH: u1,
            GPIO17_LEVEL_LOW: u1,
            GPIO17_LEVEL_HIGH: u1,
            GPIO17_EDGE_LOW: u1,
            GPIO17_EDGE_HIGH: u1,
            GPIO18_LEVEL_LOW: u1,
            GPIO18_LEVEL_HIGH: u1,
            GPIO18_EDGE_LOW: u1,
            GPIO18_EDGE_HIGH: u1,
            GPIO19_LEVEL_LOW: u1,
            GPIO19_LEVEL_HIGH: u1,
            GPIO19_EDGE_LOW: u1,
            GPIO19_EDGE_HIGH: u1,
            GPIO20_LEVEL_LOW: u1,
            GPIO20_LEVEL_HIGH: u1,
            GPIO20_EDGE_LOW: u1,
            GPIO20_EDGE_HIGH: u1,
            GPIO21_LEVEL_LOW: u1,
            GPIO21_LEVEL_HIGH: u1,
            GPIO21_EDGE_LOW: u1,
            GPIO21_EDGE_HIGH: u1,
            GPIO22_LEVEL_LOW: u1,
            GPIO22_LEVEL_HIGH: u1,
            GPIO22_EDGE_LOW: u1,
            GPIO22_EDGE_HIGH: u1,
            GPIO23_LEVEL_LOW: u1,
            GPIO23_LEVEL_HIGH: u1,
            GPIO23_EDGE_LOW: u1,
            GPIO23_EDGE_HIGH: u1,
        }), base_address + 0x178);

        /// address: 0x4001417c
        /// Interrupt Force for dormant_wake
        pub const DORMANT_WAKE_INTF3 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO24_LEVEL_LOW: u1,
            GPIO24_LEVEL_HIGH: u1,
            GPIO24_EDGE_LOW: u1,
            GPIO24_EDGE_HIGH: u1,
            GPIO25_LEVEL_LOW: u1,
            GPIO25_LEVEL_HIGH: u1,
            GPIO25_EDGE_LOW: u1,
            GPIO25_EDGE_HIGH: u1,
            GPIO26_LEVEL_LOW: u1,
            GPIO26_LEVEL_HIGH: u1,
            GPIO26_EDGE_LOW: u1,
            GPIO26_EDGE_HIGH: u1,
            GPIO27_LEVEL_LOW: u1,
            GPIO27_LEVEL_HIGH: u1,
            GPIO27_EDGE_LOW: u1,
            GPIO27_EDGE_HIGH: u1,
            GPIO28_LEVEL_LOW: u1,
            GPIO28_LEVEL_HIGH: u1,
            GPIO28_EDGE_LOW: u1,
            GPIO28_EDGE_HIGH: u1,
            GPIO29_LEVEL_LOW: u1,
            GPIO29_LEVEL_HIGH: u1,
            GPIO29_EDGE_LOW: u1,
            GPIO29_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x17c);

        /// address: 0x40014180
        /// Interrupt status after masking & forcing for dormant_wake
        pub const DORMANT_WAKE_INTS0 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO0_LEVEL_LOW: u1,
            GPIO0_LEVEL_HIGH: u1,
            GPIO0_EDGE_LOW: u1,
            GPIO0_EDGE_HIGH: u1,
            GPIO1_LEVEL_LOW: u1,
            GPIO1_LEVEL_HIGH: u1,
            GPIO1_EDGE_LOW: u1,
            GPIO1_EDGE_HIGH: u1,
            GPIO2_LEVEL_LOW: u1,
            GPIO2_LEVEL_HIGH: u1,
            GPIO2_EDGE_LOW: u1,
            GPIO2_EDGE_HIGH: u1,
            GPIO3_LEVEL_LOW: u1,
            GPIO3_LEVEL_HIGH: u1,
            GPIO3_EDGE_LOW: u1,
            GPIO3_EDGE_HIGH: u1,
            GPIO4_LEVEL_LOW: u1,
            GPIO4_LEVEL_HIGH: u1,
            GPIO4_EDGE_LOW: u1,
            GPIO4_EDGE_HIGH: u1,
            GPIO5_LEVEL_LOW: u1,
            GPIO5_LEVEL_HIGH: u1,
            GPIO5_EDGE_LOW: u1,
            GPIO5_EDGE_HIGH: u1,
            GPIO6_LEVEL_LOW: u1,
            GPIO6_LEVEL_HIGH: u1,
            GPIO6_EDGE_LOW: u1,
            GPIO6_EDGE_HIGH: u1,
            GPIO7_LEVEL_LOW: u1,
            GPIO7_LEVEL_HIGH: u1,
            GPIO7_EDGE_LOW: u1,
            GPIO7_EDGE_HIGH: u1,
        }), base_address + 0x180);

        /// address: 0x40014184
        /// Interrupt status after masking & forcing for dormant_wake
        pub const DORMANT_WAKE_INTS1 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO8_LEVEL_LOW: u1,
            GPIO8_LEVEL_HIGH: u1,
            GPIO8_EDGE_LOW: u1,
            GPIO8_EDGE_HIGH: u1,
            GPIO9_LEVEL_LOW: u1,
            GPIO9_LEVEL_HIGH: u1,
            GPIO9_EDGE_LOW: u1,
            GPIO9_EDGE_HIGH: u1,
            GPIO10_LEVEL_LOW: u1,
            GPIO10_LEVEL_HIGH: u1,
            GPIO10_EDGE_LOW: u1,
            GPIO10_EDGE_HIGH: u1,
            GPIO11_LEVEL_LOW: u1,
            GPIO11_LEVEL_HIGH: u1,
            GPIO11_EDGE_LOW: u1,
            GPIO11_EDGE_HIGH: u1,
            GPIO12_LEVEL_LOW: u1,
            GPIO12_LEVEL_HIGH: u1,
            GPIO12_EDGE_LOW: u1,
            GPIO12_EDGE_HIGH: u1,
            GPIO13_LEVEL_LOW: u1,
            GPIO13_LEVEL_HIGH: u1,
            GPIO13_EDGE_LOW: u1,
            GPIO13_EDGE_HIGH: u1,
            GPIO14_LEVEL_LOW: u1,
            GPIO14_LEVEL_HIGH: u1,
            GPIO14_EDGE_LOW: u1,
            GPIO14_EDGE_HIGH: u1,
            GPIO15_LEVEL_LOW: u1,
            GPIO15_LEVEL_HIGH: u1,
            GPIO15_EDGE_LOW: u1,
            GPIO15_EDGE_HIGH: u1,
        }), base_address + 0x184);

        /// address: 0x40014188
        /// Interrupt status after masking & forcing for dormant_wake
        pub const DORMANT_WAKE_INTS2 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO16_LEVEL_LOW: u1,
            GPIO16_LEVEL_HIGH: u1,
            GPIO16_EDGE_LOW: u1,
            GPIO16_EDGE_HIGH: u1,
            GPIO17_LEVEL_LOW: u1,
            GPIO17_LEVEL_HIGH: u1,
            GPIO17_EDGE_LOW: u1,
            GPIO17_EDGE_HIGH: u1,
            GPIO18_LEVEL_LOW: u1,
            GPIO18_LEVEL_HIGH: u1,
            GPIO18_EDGE_LOW: u1,
            GPIO18_EDGE_HIGH: u1,
            GPIO19_LEVEL_LOW: u1,
            GPIO19_LEVEL_HIGH: u1,
            GPIO19_EDGE_LOW: u1,
            GPIO19_EDGE_HIGH: u1,
            GPIO20_LEVEL_LOW: u1,
            GPIO20_LEVEL_HIGH: u1,
            GPIO20_EDGE_LOW: u1,
            GPIO20_EDGE_HIGH: u1,
            GPIO21_LEVEL_LOW: u1,
            GPIO21_LEVEL_HIGH: u1,
            GPIO21_EDGE_LOW: u1,
            GPIO21_EDGE_HIGH: u1,
            GPIO22_LEVEL_LOW: u1,
            GPIO22_LEVEL_HIGH: u1,
            GPIO22_EDGE_LOW: u1,
            GPIO22_EDGE_HIGH: u1,
            GPIO23_LEVEL_LOW: u1,
            GPIO23_LEVEL_HIGH: u1,
            GPIO23_EDGE_LOW: u1,
            GPIO23_EDGE_HIGH: u1,
        }), base_address + 0x188);

        /// address: 0x4001418c
        /// Interrupt status after masking & forcing for dormant_wake
        pub const DORMANT_WAKE_INTS3 = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO24_LEVEL_LOW: u1,
            GPIO24_LEVEL_HIGH: u1,
            GPIO24_EDGE_LOW: u1,
            GPIO24_EDGE_HIGH: u1,
            GPIO25_LEVEL_LOW: u1,
            GPIO25_LEVEL_HIGH: u1,
            GPIO25_EDGE_LOW: u1,
            GPIO25_EDGE_HIGH: u1,
            GPIO26_LEVEL_LOW: u1,
            GPIO26_LEVEL_HIGH: u1,
            GPIO26_EDGE_LOW: u1,
            GPIO26_EDGE_HIGH: u1,
            GPIO27_LEVEL_LOW: u1,
            GPIO27_LEVEL_HIGH: u1,
            GPIO27_EDGE_LOW: u1,
            GPIO27_EDGE_HIGH: u1,
            GPIO28_LEVEL_LOW: u1,
            GPIO28_LEVEL_HIGH: u1,
            GPIO28_EDGE_LOW: u1,
            GPIO28_EDGE_HIGH: u1,
            GPIO29_LEVEL_LOW: u1,
            GPIO29_LEVEL_HIGH: u1,
            GPIO29_EDGE_LOW: u1,
            GPIO29_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x18c);
    };
    pub const IO_QSPI = struct {
        pub const base_address = 0x40018000;
        pub const version = "1";

        /// address: 0x40018000
        /// GPIO status
        pub const GPIO_QSPI_SCLK_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40018004
        /// GPIO control including function select and overrides.
        pub const GPIO_QSPI_SCLK_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40018008
        /// GPIO status
        pub const GPIO_QSPI_SS_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x4001800c
        /// GPIO control including function select and overrides.
        pub const GPIO_QSPI_SS_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0xc);

        /// address: 0x40018010
        /// GPIO status
        pub const GPIO_QSPI_SD0_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x10);

        /// address: 0x40018014
        /// GPIO control including function select and overrides.
        pub const GPIO_QSPI_SD0_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x14);

        /// address: 0x40018018
        /// GPIO status
        pub const GPIO_QSPI_SD1_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x4001801c
        /// GPIO control including function select and overrides.
        pub const GPIO_QSPI_SD1_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x1c);

        /// address: 0x40018020
        /// GPIO status
        pub const GPIO_QSPI_SD2_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x20);

        /// address: 0x40018024
        /// GPIO control including function select and overrides.
        pub const GPIO_QSPI_SD2_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x24);

        /// address: 0x40018028
        /// GPIO status
        pub const GPIO_QSPI_SD3_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// output signal from selected peripheral, before register override is applied
            OUTFROMPERI: u1,
            /// output signal to pad after register override is applied
            OUTTOPAD: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// output enable from selected peripheral, before register override is applied
            OEFROMPERI: u1,
            /// output enable to pad after register override is applied
            OETOPAD: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            /// input signal from pad, before override is applied
            INFROMPAD: u1,
            reserved13: u1 = 0,
            /// input signal to peripheral, after override is applied
            INTOPERI: u1,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// interrupt from pad before override is applied
            IRQFROMPAD: u1,
            reserved18: u1 = 0,
            /// interrupt to processors, after override is applied
            IRQTOPROC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x28);

        /// address: 0x4001802c
        /// GPIO control including function select and overrides.
        pub const GPIO_QSPI_SD3_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0-31 -> selects pin function according to the gpio table\n
            /// 31 == NULL
            FUNCSEL: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            OUTOVER: u2,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            OEOVER: u2,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            INOVER: u2,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            IRQOVER: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x2c);

        /// address: 0x40018030
        /// Raw Interrupts
        pub const INTR = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO_QSPI_SCLK_LEVEL_LOW: u1,
            GPIO_QSPI_SCLK_LEVEL_HIGH: u1,
            GPIO_QSPI_SCLK_EDGE_LOW: u1,
            GPIO_QSPI_SCLK_EDGE_HIGH: u1,
            GPIO_QSPI_SS_LEVEL_LOW: u1,
            GPIO_QSPI_SS_LEVEL_HIGH: u1,
            GPIO_QSPI_SS_EDGE_LOW: u1,
            GPIO_QSPI_SS_EDGE_HIGH: u1,
            GPIO_QSPI_SD0_LEVEL_LOW: u1,
            GPIO_QSPI_SD0_LEVEL_HIGH: u1,
            GPIO_QSPI_SD0_EDGE_LOW: u1,
            GPIO_QSPI_SD0_EDGE_HIGH: u1,
            GPIO_QSPI_SD1_LEVEL_LOW: u1,
            GPIO_QSPI_SD1_LEVEL_HIGH: u1,
            GPIO_QSPI_SD1_EDGE_LOW: u1,
            GPIO_QSPI_SD1_EDGE_HIGH: u1,
            GPIO_QSPI_SD2_LEVEL_LOW: u1,
            GPIO_QSPI_SD2_LEVEL_HIGH: u1,
            GPIO_QSPI_SD2_EDGE_LOW: u1,
            GPIO_QSPI_SD2_EDGE_HIGH: u1,
            GPIO_QSPI_SD3_LEVEL_LOW: u1,
            GPIO_QSPI_SD3_LEVEL_HIGH: u1,
            GPIO_QSPI_SD3_EDGE_LOW: u1,
            GPIO_QSPI_SD3_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x30);

        /// address: 0x40018034
        /// Interrupt Enable for proc0
        pub const PROC0_INTE = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO_QSPI_SCLK_LEVEL_LOW: u1,
            GPIO_QSPI_SCLK_LEVEL_HIGH: u1,
            GPIO_QSPI_SCLK_EDGE_LOW: u1,
            GPIO_QSPI_SCLK_EDGE_HIGH: u1,
            GPIO_QSPI_SS_LEVEL_LOW: u1,
            GPIO_QSPI_SS_LEVEL_HIGH: u1,
            GPIO_QSPI_SS_EDGE_LOW: u1,
            GPIO_QSPI_SS_EDGE_HIGH: u1,
            GPIO_QSPI_SD0_LEVEL_LOW: u1,
            GPIO_QSPI_SD0_LEVEL_HIGH: u1,
            GPIO_QSPI_SD0_EDGE_LOW: u1,
            GPIO_QSPI_SD0_EDGE_HIGH: u1,
            GPIO_QSPI_SD1_LEVEL_LOW: u1,
            GPIO_QSPI_SD1_LEVEL_HIGH: u1,
            GPIO_QSPI_SD1_EDGE_LOW: u1,
            GPIO_QSPI_SD1_EDGE_HIGH: u1,
            GPIO_QSPI_SD2_LEVEL_LOW: u1,
            GPIO_QSPI_SD2_LEVEL_HIGH: u1,
            GPIO_QSPI_SD2_EDGE_LOW: u1,
            GPIO_QSPI_SD2_EDGE_HIGH: u1,
            GPIO_QSPI_SD3_LEVEL_LOW: u1,
            GPIO_QSPI_SD3_LEVEL_HIGH: u1,
            GPIO_QSPI_SD3_EDGE_LOW: u1,
            GPIO_QSPI_SD3_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x34);

        /// address: 0x40018038
        /// Interrupt Force for proc0
        pub const PROC0_INTF = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO_QSPI_SCLK_LEVEL_LOW: u1,
            GPIO_QSPI_SCLK_LEVEL_HIGH: u1,
            GPIO_QSPI_SCLK_EDGE_LOW: u1,
            GPIO_QSPI_SCLK_EDGE_HIGH: u1,
            GPIO_QSPI_SS_LEVEL_LOW: u1,
            GPIO_QSPI_SS_LEVEL_HIGH: u1,
            GPIO_QSPI_SS_EDGE_LOW: u1,
            GPIO_QSPI_SS_EDGE_HIGH: u1,
            GPIO_QSPI_SD0_LEVEL_LOW: u1,
            GPIO_QSPI_SD0_LEVEL_HIGH: u1,
            GPIO_QSPI_SD0_EDGE_LOW: u1,
            GPIO_QSPI_SD0_EDGE_HIGH: u1,
            GPIO_QSPI_SD1_LEVEL_LOW: u1,
            GPIO_QSPI_SD1_LEVEL_HIGH: u1,
            GPIO_QSPI_SD1_EDGE_LOW: u1,
            GPIO_QSPI_SD1_EDGE_HIGH: u1,
            GPIO_QSPI_SD2_LEVEL_LOW: u1,
            GPIO_QSPI_SD2_LEVEL_HIGH: u1,
            GPIO_QSPI_SD2_EDGE_LOW: u1,
            GPIO_QSPI_SD2_EDGE_HIGH: u1,
            GPIO_QSPI_SD3_LEVEL_LOW: u1,
            GPIO_QSPI_SD3_LEVEL_HIGH: u1,
            GPIO_QSPI_SD3_EDGE_LOW: u1,
            GPIO_QSPI_SD3_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x38);

        /// address: 0x4001803c
        /// Interrupt status after masking & forcing for proc0
        pub const PROC0_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO_QSPI_SCLK_LEVEL_LOW: u1,
            GPIO_QSPI_SCLK_LEVEL_HIGH: u1,
            GPIO_QSPI_SCLK_EDGE_LOW: u1,
            GPIO_QSPI_SCLK_EDGE_HIGH: u1,
            GPIO_QSPI_SS_LEVEL_LOW: u1,
            GPIO_QSPI_SS_LEVEL_HIGH: u1,
            GPIO_QSPI_SS_EDGE_LOW: u1,
            GPIO_QSPI_SS_EDGE_HIGH: u1,
            GPIO_QSPI_SD0_LEVEL_LOW: u1,
            GPIO_QSPI_SD0_LEVEL_HIGH: u1,
            GPIO_QSPI_SD0_EDGE_LOW: u1,
            GPIO_QSPI_SD0_EDGE_HIGH: u1,
            GPIO_QSPI_SD1_LEVEL_LOW: u1,
            GPIO_QSPI_SD1_LEVEL_HIGH: u1,
            GPIO_QSPI_SD1_EDGE_LOW: u1,
            GPIO_QSPI_SD1_EDGE_HIGH: u1,
            GPIO_QSPI_SD2_LEVEL_LOW: u1,
            GPIO_QSPI_SD2_LEVEL_HIGH: u1,
            GPIO_QSPI_SD2_EDGE_LOW: u1,
            GPIO_QSPI_SD2_EDGE_HIGH: u1,
            GPIO_QSPI_SD3_LEVEL_LOW: u1,
            GPIO_QSPI_SD3_LEVEL_HIGH: u1,
            GPIO_QSPI_SD3_EDGE_LOW: u1,
            GPIO_QSPI_SD3_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x3c);

        /// address: 0x40018040
        /// Interrupt Enable for proc1
        pub const PROC1_INTE = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO_QSPI_SCLK_LEVEL_LOW: u1,
            GPIO_QSPI_SCLK_LEVEL_HIGH: u1,
            GPIO_QSPI_SCLK_EDGE_LOW: u1,
            GPIO_QSPI_SCLK_EDGE_HIGH: u1,
            GPIO_QSPI_SS_LEVEL_LOW: u1,
            GPIO_QSPI_SS_LEVEL_HIGH: u1,
            GPIO_QSPI_SS_EDGE_LOW: u1,
            GPIO_QSPI_SS_EDGE_HIGH: u1,
            GPIO_QSPI_SD0_LEVEL_LOW: u1,
            GPIO_QSPI_SD0_LEVEL_HIGH: u1,
            GPIO_QSPI_SD0_EDGE_LOW: u1,
            GPIO_QSPI_SD0_EDGE_HIGH: u1,
            GPIO_QSPI_SD1_LEVEL_LOW: u1,
            GPIO_QSPI_SD1_LEVEL_HIGH: u1,
            GPIO_QSPI_SD1_EDGE_LOW: u1,
            GPIO_QSPI_SD1_EDGE_HIGH: u1,
            GPIO_QSPI_SD2_LEVEL_LOW: u1,
            GPIO_QSPI_SD2_LEVEL_HIGH: u1,
            GPIO_QSPI_SD2_EDGE_LOW: u1,
            GPIO_QSPI_SD2_EDGE_HIGH: u1,
            GPIO_QSPI_SD3_LEVEL_LOW: u1,
            GPIO_QSPI_SD3_LEVEL_HIGH: u1,
            GPIO_QSPI_SD3_EDGE_LOW: u1,
            GPIO_QSPI_SD3_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x40);

        /// address: 0x40018044
        /// Interrupt Force for proc1
        pub const PROC1_INTF = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO_QSPI_SCLK_LEVEL_LOW: u1,
            GPIO_QSPI_SCLK_LEVEL_HIGH: u1,
            GPIO_QSPI_SCLK_EDGE_LOW: u1,
            GPIO_QSPI_SCLK_EDGE_HIGH: u1,
            GPIO_QSPI_SS_LEVEL_LOW: u1,
            GPIO_QSPI_SS_LEVEL_HIGH: u1,
            GPIO_QSPI_SS_EDGE_LOW: u1,
            GPIO_QSPI_SS_EDGE_HIGH: u1,
            GPIO_QSPI_SD0_LEVEL_LOW: u1,
            GPIO_QSPI_SD0_LEVEL_HIGH: u1,
            GPIO_QSPI_SD0_EDGE_LOW: u1,
            GPIO_QSPI_SD0_EDGE_HIGH: u1,
            GPIO_QSPI_SD1_LEVEL_LOW: u1,
            GPIO_QSPI_SD1_LEVEL_HIGH: u1,
            GPIO_QSPI_SD1_EDGE_LOW: u1,
            GPIO_QSPI_SD1_EDGE_HIGH: u1,
            GPIO_QSPI_SD2_LEVEL_LOW: u1,
            GPIO_QSPI_SD2_LEVEL_HIGH: u1,
            GPIO_QSPI_SD2_EDGE_LOW: u1,
            GPIO_QSPI_SD2_EDGE_HIGH: u1,
            GPIO_QSPI_SD3_LEVEL_LOW: u1,
            GPIO_QSPI_SD3_LEVEL_HIGH: u1,
            GPIO_QSPI_SD3_EDGE_LOW: u1,
            GPIO_QSPI_SD3_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x44);

        /// address: 0x40018048
        /// Interrupt status after masking & forcing for proc1
        pub const PROC1_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO_QSPI_SCLK_LEVEL_LOW: u1,
            GPIO_QSPI_SCLK_LEVEL_HIGH: u1,
            GPIO_QSPI_SCLK_EDGE_LOW: u1,
            GPIO_QSPI_SCLK_EDGE_HIGH: u1,
            GPIO_QSPI_SS_LEVEL_LOW: u1,
            GPIO_QSPI_SS_LEVEL_HIGH: u1,
            GPIO_QSPI_SS_EDGE_LOW: u1,
            GPIO_QSPI_SS_EDGE_HIGH: u1,
            GPIO_QSPI_SD0_LEVEL_LOW: u1,
            GPIO_QSPI_SD0_LEVEL_HIGH: u1,
            GPIO_QSPI_SD0_EDGE_LOW: u1,
            GPIO_QSPI_SD0_EDGE_HIGH: u1,
            GPIO_QSPI_SD1_LEVEL_LOW: u1,
            GPIO_QSPI_SD1_LEVEL_HIGH: u1,
            GPIO_QSPI_SD1_EDGE_LOW: u1,
            GPIO_QSPI_SD1_EDGE_HIGH: u1,
            GPIO_QSPI_SD2_LEVEL_LOW: u1,
            GPIO_QSPI_SD2_LEVEL_HIGH: u1,
            GPIO_QSPI_SD2_EDGE_LOW: u1,
            GPIO_QSPI_SD2_EDGE_HIGH: u1,
            GPIO_QSPI_SD3_LEVEL_LOW: u1,
            GPIO_QSPI_SD3_LEVEL_HIGH: u1,
            GPIO_QSPI_SD3_EDGE_LOW: u1,
            GPIO_QSPI_SD3_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x48);

        /// address: 0x4001804c
        /// Interrupt Enable for dormant_wake
        pub const DORMANT_WAKE_INTE = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO_QSPI_SCLK_LEVEL_LOW: u1,
            GPIO_QSPI_SCLK_LEVEL_HIGH: u1,
            GPIO_QSPI_SCLK_EDGE_LOW: u1,
            GPIO_QSPI_SCLK_EDGE_HIGH: u1,
            GPIO_QSPI_SS_LEVEL_LOW: u1,
            GPIO_QSPI_SS_LEVEL_HIGH: u1,
            GPIO_QSPI_SS_EDGE_LOW: u1,
            GPIO_QSPI_SS_EDGE_HIGH: u1,
            GPIO_QSPI_SD0_LEVEL_LOW: u1,
            GPIO_QSPI_SD0_LEVEL_HIGH: u1,
            GPIO_QSPI_SD0_EDGE_LOW: u1,
            GPIO_QSPI_SD0_EDGE_HIGH: u1,
            GPIO_QSPI_SD1_LEVEL_LOW: u1,
            GPIO_QSPI_SD1_LEVEL_HIGH: u1,
            GPIO_QSPI_SD1_EDGE_LOW: u1,
            GPIO_QSPI_SD1_EDGE_HIGH: u1,
            GPIO_QSPI_SD2_LEVEL_LOW: u1,
            GPIO_QSPI_SD2_LEVEL_HIGH: u1,
            GPIO_QSPI_SD2_EDGE_LOW: u1,
            GPIO_QSPI_SD2_EDGE_HIGH: u1,
            GPIO_QSPI_SD3_LEVEL_LOW: u1,
            GPIO_QSPI_SD3_LEVEL_HIGH: u1,
            GPIO_QSPI_SD3_EDGE_LOW: u1,
            GPIO_QSPI_SD3_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x4c);

        /// address: 0x40018050
        /// Interrupt Force for dormant_wake
        pub const DORMANT_WAKE_INTF = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO_QSPI_SCLK_LEVEL_LOW: u1,
            GPIO_QSPI_SCLK_LEVEL_HIGH: u1,
            GPIO_QSPI_SCLK_EDGE_LOW: u1,
            GPIO_QSPI_SCLK_EDGE_HIGH: u1,
            GPIO_QSPI_SS_LEVEL_LOW: u1,
            GPIO_QSPI_SS_LEVEL_HIGH: u1,
            GPIO_QSPI_SS_EDGE_LOW: u1,
            GPIO_QSPI_SS_EDGE_HIGH: u1,
            GPIO_QSPI_SD0_LEVEL_LOW: u1,
            GPIO_QSPI_SD0_LEVEL_HIGH: u1,
            GPIO_QSPI_SD0_EDGE_LOW: u1,
            GPIO_QSPI_SD0_EDGE_HIGH: u1,
            GPIO_QSPI_SD1_LEVEL_LOW: u1,
            GPIO_QSPI_SD1_LEVEL_HIGH: u1,
            GPIO_QSPI_SD1_EDGE_LOW: u1,
            GPIO_QSPI_SD1_EDGE_HIGH: u1,
            GPIO_QSPI_SD2_LEVEL_LOW: u1,
            GPIO_QSPI_SD2_LEVEL_HIGH: u1,
            GPIO_QSPI_SD2_EDGE_LOW: u1,
            GPIO_QSPI_SD2_EDGE_HIGH: u1,
            GPIO_QSPI_SD3_LEVEL_LOW: u1,
            GPIO_QSPI_SD3_LEVEL_HIGH: u1,
            GPIO_QSPI_SD3_EDGE_LOW: u1,
            GPIO_QSPI_SD3_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x50);

        /// address: 0x40018054
        /// Interrupt status after masking & forcing for dormant_wake
        pub const DORMANT_WAKE_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            GPIO_QSPI_SCLK_LEVEL_LOW: u1,
            GPIO_QSPI_SCLK_LEVEL_HIGH: u1,
            GPIO_QSPI_SCLK_EDGE_LOW: u1,
            GPIO_QSPI_SCLK_EDGE_HIGH: u1,
            GPIO_QSPI_SS_LEVEL_LOW: u1,
            GPIO_QSPI_SS_LEVEL_HIGH: u1,
            GPIO_QSPI_SS_EDGE_LOW: u1,
            GPIO_QSPI_SS_EDGE_HIGH: u1,
            GPIO_QSPI_SD0_LEVEL_LOW: u1,
            GPIO_QSPI_SD0_LEVEL_HIGH: u1,
            GPIO_QSPI_SD0_EDGE_LOW: u1,
            GPIO_QSPI_SD0_EDGE_HIGH: u1,
            GPIO_QSPI_SD1_LEVEL_LOW: u1,
            GPIO_QSPI_SD1_LEVEL_HIGH: u1,
            GPIO_QSPI_SD1_EDGE_LOW: u1,
            GPIO_QSPI_SD1_EDGE_HIGH: u1,
            GPIO_QSPI_SD2_LEVEL_LOW: u1,
            GPIO_QSPI_SD2_LEVEL_HIGH: u1,
            GPIO_QSPI_SD2_EDGE_LOW: u1,
            GPIO_QSPI_SD2_EDGE_HIGH: u1,
            GPIO_QSPI_SD3_LEVEL_LOW: u1,
            GPIO_QSPI_SD3_LEVEL_HIGH: u1,
            GPIO_QSPI_SD3_EDGE_LOW: u1,
            GPIO_QSPI_SD3_EDGE_HIGH: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x54);
    };
    pub const PADS_BANK0 = struct {
        pub const base_address = 0x4001c000;
        pub const version = "1";

        /// address: 0x4001c000
        /// Voltage select. Per bank control
        pub const VOLTAGE_SELECT = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x0);

        /// address: 0x4001c004
        /// Pad control register
        pub const GPIO0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x4001c008
        /// Pad control register
        pub const GPIO1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x4001c00c
        /// Pad control register
        pub const GPIO2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xc);

        /// address: 0x4001c010
        /// Pad control register
        pub const GPIO3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x10);

        /// address: 0x4001c014
        /// Pad control register
        pub const GPIO4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x14);

        /// address: 0x4001c018
        /// Pad control register
        pub const GPIO5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x4001c01c
        /// Pad control register
        pub const GPIO6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x1c);

        /// address: 0x4001c020
        /// Pad control register
        pub const GPIO7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x20);

        /// address: 0x4001c024
        /// Pad control register
        pub const GPIO8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x24);

        /// address: 0x4001c028
        /// Pad control register
        pub const GPIO9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x28);

        /// address: 0x4001c02c
        /// Pad control register
        pub const GPIO10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x2c);

        /// address: 0x4001c030
        /// Pad control register
        pub const GPIO11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x30);

        /// address: 0x4001c034
        /// Pad control register
        pub const GPIO12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x34);

        /// address: 0x4001c038
        /// Pad control register
        pub const GPIO13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x38);

        /// address: 0x4001c03c
        /// Pad control register
        pub const GPIO14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x3c);

        /// address: 0x4001c040
        /// Pad control register
        pub const GPIO15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x40);

        /// address: 0x4001c044
        /// Pad control register
        pub const GPIO16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x44);

        /// address: 0x4001c048
        /// Pad control register
        pub const GPIO17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x48);

        /// address: 0x4001c04c
        /// Pad control register
        pub const GPIO18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x4c);

        /// address: 0x4001c050
        /// Pad control register
        pub const GPIO19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x50);

        /// address: 0x4001c054
        /// Pad control register
        pub const GPIO20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x54);

        /// address: 0x4001c058
        /// Pad control register
        pub const GPIO21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x58);

        /// address: 0x4001c05c
        /// Pad control register
        pub const GPIO22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x5c);

        /// address: 0x4001c060
        /// Pad control register
        pub const GPIO23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x60);

        /// address: 0x4001c064
        /// Pad control register
        pub const GPIO24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x64);

        /// address: 0x4001c068
        /// Pad control register
        pub const GPIO25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x68);

        /// address: 0x4001c06c
        /// Pad control register
        pub const GPIO26 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x6c);

        /// address: 0x4001c070
        /// Pad control register
        pub const GPIO27 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x70);

        /// address: 0x4001c074
        /// Pad control register
        pub const GPIO28 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x74);

        /// address: 0x4001c078
        /// Pad control register
        pub const GPIO29 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x78);

        /// address: 0x4001c07c
        /// Pad control register
        pub const SWCLK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x7c);

        /// address: 0x4001c080
        /// Pad control register
        pub const SWD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x80);
    };
    pub const PADS_QSPI = struct {
        pub const base_address = 0x40020000;
        pub const version = "1";

        /// address: 0x40020000
        /// Voltage select. Per bank control
        pub const VOLTAGE_SELECT = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x0);

        /// address: 0x40020004
        /// Pad control register
        pub const GPIO_QSPI_SCLK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40020008
        /// Pad control register
        pub const GPIO_QSPI_SD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x4002000c
        /// Pad control register
        pub const GPIO_QSPI_SD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xc);

        /// address: 0x40020010
        /// Pad control register
        pub const GPIO_QSPI_SD2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x10);

        /// address: 0x40020014
        /// Pad control register
        pub const GPIO_QSPI_SD3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x14);

        /// address: 0x40020018
        /// Pad control register
        pub const GPIO_QSPI_SS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slew rate control. 1 = Fast, 0 = Slow
            SLEWFAST: u1,
            /// Enable schmitt trigger
            SCHMITT: u1,
            /// Pull down enable
            PDE: u1,
            /// Pull up enable
            PUE: u1,
            /// Drive strength.
            DRIVE: u2,
            /// Input enable
            IE: u1,
            /// Output disable. Has priority over output enable from peripherals
            OD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x18);
    };

    /// Controls the crystal oscillator
    pub const XOSC = struct {
        pub const base_address = 0x40024000;
        pub const version = "1";

        /// address: 0x40024000
        /// Crystal Oscillator Control
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frequency range. This resets to 0xAA0 and cannot be changed.
            FREQ_RANGE: u12,
            /// On power-up this field is initialised to DISABLE and the chip runs from the
            /// ROSC.\n
            /// If the chip has subsequently been programmed to run from the XOSC then setting
            /// this field to DISABLE may lock-up the chip. If this is a concern then run the
            /// clk_ref from the ROSC and enable the clk_sys RESUS feature.\n
            /// The 12-bit code is intended to give some protection against accidental writes.
            /// An invalid setting will enable the oscillator.
            ENABLE: u12,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40024004
        /// Crystal Oscillator Status
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// The current frequency range setting, always reads 0
            FREQ_RANGE: u2,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            /// Oscillator is enabled but not necessarily running and stable, resets to 0
            ENABLED: u1,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            reserved18: u1 = 0,
            reserved19: u1 = 0,
            reserved20: u1 = 0,
            /// An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or DORMANT
            BADWRITE: u1,
            reserved21: u1 = 0,
            reserved22: u1 = 0,
            reserved23: u1 = 0,
            reserved24: u1 = 0,
            reserved25: u1 = 0,
            reserved26: u1 = 0,
            /// Oscillator is running and stable
            STABLE: u1,
        }), base_address + 0x4);

        /// address: 0x40024008
        /// Crystal Oscillator pause control\n
        /// This is used to save power by pausing the XOSC\n
        /// On power-up this field is initialised to WAKE\n
        /// An invalid write will also select WAKE\n
        /// WARNING: stop the PLLs before selecting dormant mode\n
        /// WARNING: setup the irq before selecting dormant mode
        pub const DORMANT = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4002400c
        /// Controls the startup delay
        pub const STARTUP = @intToPtr(*volatile Mmio(32, packed struct {
            /// in multiples of 256*xtal_period. The reset value of 0xc4 corresponds to approx
            /// 50 000 cycles.
            DELAY: u14,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            /// Multiplies the startup_delay by 4. This is of little value to the user given
            /// that the delay can be programmed directly.
            X4: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
        }), base_address + 0xc);

        /// address: 0x4002401c
        /// A down counter running at the xosc frequency which counts to zero and stops.\n
        /// To start the counter write a non-zero value.\n
        /// Can be used for short software pauses when setting up time sensitive hardware.
        pub const COUNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x1c);
    };
    pub const PLL_SYS = struct {
        pub const base_address = 0x40028000;
        pub const version = "1";

        /// address: 0x40028000
        /// Control and Status\n
        /// GENERAL CONSTRAINTS:\n
        /// Reference clock frequency min=5MHz, max=800MHz\n
        /// Feedback divider min=16, max=320\n
        /// VCO frequency min=400MHz, max=1600MHz
        pub const CS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divides the PLL input reference clock.\n
            /// Behaviour is undefined for div=0.\n
            /// PLL output will be unpredictable during refdiv changes, wait for lock=1 before
            /// using it.
            REFDIV: u6,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// Passes the reference clock to the output instead of the divided VCO. The VCO
            /// continues to run so the user can switch between the reference clock and the
            /// divided VCO but the output will glitch when doing so.
            BYPASS: u1,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            reserved18: u1 = 0,
            reserved19: u1 = 0,
            reserved20: u1 = 0,
            reserved21: u1 = 0,
            reserved22: u1 = 0,
            reserved23: u1 = 0,
            /// PLL is locked
            LOCK: u1,
        }), base_address + 0x0);

        /// address: 0x40028004
        /// Controls the PLL power modes.
        pub const PWR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL powerdown\n
            /// To save power set high when PLL output not required.
            PD: u1,
            reserved0: u1 = 0,
            /// PLL DSM powerdown\n
            /// Nothing is achieved by setting this low.
            DSMPD: u1,
            /// PLL post divider powerdown\n
            /// To save power set high when PLL output not required or bypass=1.
            POSTDIVPD: u1,
            reserved1: u1 = 0,
            /// PLL VCO powerdown\n
            /// To save power set high when PLL output not required or bypass=1.
            VCOPD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40028008
        /// Feedback divisor\n
        /// (note: this PLL does not support fractional division)
        pub const FBDIV_INT = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x8);

        /// address: 0x4002800c
        /// Controls the PLL post dividers for the primary output\n
        /// (note: this PLL does not have a secondary output)\n
        /// the primary output is driven from VCO divided by postdiv1*postdiv2
        pub const PRIM = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            /// divide by 1-7
            POSTDIV2: u3,
            reserved12: u1 = 0,
            /// divide by 1-7
            POSTDIV1: u3,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
        }), base_address + 0xc);
    };
    pub const PLL_USB = struct {
        pub const base_address = 0x4002c000;

        /// address: 0x4002c000
        /// Control and Status\n
        /// GENERAL CONSTRAINTS:\n
        /// Reference clock frequency min=5MHz, max=800MHz\n
        /// Feedback divider min=16, max=320\n
        /// VCO frequency min=400MHz, max=1600MHz
        pub const CS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divides the PLL input reference clock.\n
            /// Behaviour is undefined for div=0.\n
            /// PLL output will be unpredictable during refdiv changes, wait for lock=1 before
            /// using it.
            REFDIV: u6,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// Passes the reference clock to the output instead of the divided VCO. The VCO
            /// continues to run so the user can switch between the reference clock and the
            /// divided VCO but the output will glitch when doing so.
            BYPASS: u1,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            reserved18: u1 = 0,
            reserved19: u1 = 0,
            reserved20: u1 = 0,
            reserved21: u1 = 0,
            reserved22: u1 = 0,
            reserved23: u1 = 0,
            /// PLL is locked
            LOCK: u1,
        }), base_address + 0x0);

        /// address: 0x4002c004
        /// Controls the PLL power modes.
        pub const PWR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL powerdown\n
            /// To save power set high when PLL output not required.
            PD: u1,
            reserved0: u1 = 0,
            /// PLL DSM powerdown\n
            /// Nothing is achieved by setting this low.
            DSMPD: u1,
            /// PLL post divider powerdown\n
            /// To save power set high when PLL output not required or bypass=1.
            POSTDIVPD: u1,
            reserved1: u1 = 0,
            /// PLL VCO powerdown\n
            /// To save power set high when PLL output not required or bypass=1.
            VCOPD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x4002c008
        /// Feedback divisor\n
        /// (note: this PLL does not support fractional division)
        pub const FBDIV_INT = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x8);

        /// address: 0x4002c00c
        /// Controls the PLL post dividers for the primary output\n
        /// (note: this PLL does not have a secondary output)\n
        /// the primary output is driven from VCO divided by postdiv1*postdiv2
        pub const PRIM = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            /// divide by 1-7
            POSTDIV2: u3,
            reserved12: u1 = 0,
            /// divide by 1-7
            POSTDIV1: u3,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
        }), base_address + 0xc);
    };

    /// Register block for busfabric control signals and performance counters
    pub const BUSCTRL = struct {
        pub const base_address = 0x40030000;
        pub const version = "1";

        /// address: 0x40030000
        /// Set the priority of each master for bus arbitration.
        pub const BUS_PRIORITY = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0 - low priority, 1 - high priority
            PROC0: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            /// 0 - low priority, 1 - high priority
            PROC1: u1,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            /// 0 - low priority, 1 - high priority
            DMA_R: u1,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// 0 - low priority, 1 - high priority
            DMA_W: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40030004
        /// Bus priority acknowledge
        pub const BUS_PRIORITY_ACK = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x4);

        /// address: 0x40030008
        /// Bus fabric performance counter 0
        pub const PERFCTR0 = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x8);

        /// address: 0x4003000c
        /// Bus fabric performance event select for PERFCTR0
        pub const PERFSEL0 = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xc);

        /// address: 0x40030010
        /// Bus fabric performance counter 1
        pub const PERFCTR1 = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x10);

        /// address: 0x40030014
        /// Bus fabric performance event select for PERFCTR1
        pub const PERFSEL1 = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x14);

        /// address: 0x40030018
        /// Bus fabric performance counter 2
        pub const PERFCTR2 = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x18);

        /// address: 0x4003001c
        /// Bus fabric performance event select for PERFCTR2
        pub const PERFSEL2 = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x1c);

        /// address: 0x40030020
        /// Bus fabric performance counter 3
        pub const PERFCTR3 = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x20);

        /// address: 0x40030024
        /// Bus fabric performance event select for PERFCTR3
        pub const PERFSEL3 = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x24);
    };
    pub const UART0 = struct {
        pub const base_address = 0x40034000;
        pub const version = "1";

        /// address: 0x40034000
        /// Data Register, UARTDR
        pub const UARTDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive (read) data character. Transmit (write) data character.
            DATA: u8,
            /// Framing error. When set to 1, it indicates that the received character did not
            /// have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is
            /// associated with the character at the top of the FIFO.
            FE: u1,
            /// Parity error. When set to 1, it indicates that the parity of the received data
            /// character does not match the parity that the EPS and SPS bits in the Line
            /// Control Register, UARTLCR_H. In FIFO mode, this error is associated with the
            /// character at the top of the FIFO.
            PE: u1,
            /// Break error. This bit is set to 1 if a break condition was detected, indicating
            /// that the received data input was held LOW for longer than a full-word
            /// transmission time (defined as start, data, parity and stop bits). In FIFO mode,
            /// this error is associated with the character at the top of the FIFO. When a break
            /// occurs, only one 0 character is loaded into the FIFO. The next character is only
            /// enabled after the receive data input goes to a 1 (marking state), and the next
            /// valid start bit is received.
            BE: u1,
            /// Overrun error. This bit is set to 1 if data is received and the receive FIFO is
            /// already full. This is cleared to 0 once there is an empty space in the FIFO and
            /// a new character can be written to it.
            OE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40034004
        /// Receive Status Register/Error Clear Register, UARTRSR/UARTECR
        pub const UARTRSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Framing error. When set to 1, it indicates that the received character did not
            /// have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a
            /// write to UARTECR. In FIFO mode, this error is associated with the character at
            /// the top of the FIFO.
            FE: u1,
            /// Parity error. When set to 1, it indicates that the parity of the received data
            /// character does not match the parity that the EPS and SPS bits in the Line
            /// Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In
            /// FIFO mode, this error is associated with the character at the top of the FIFO.
            PE: u1,
            /// Break error. This bit is set to 1 if a break condition was detected, indicating
            /// that the received data input was held LOW for longer than a full-word
            /// transmission time (defined as start, data, parity, and stop bits). This bit is
            /// cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated
            /// with the character at the top of the FIFO. When a break occurs, only one 0
            /// character is loaded into the FIFO. The next character is only enabled after the
            /// receive data input goes to a 1 (marking state) and the next valid start bit is
            /// received.
            BE: u1,
            /// Overrun error. This bit is set to 1 if data is received and the FIFO is already
            /// full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain
            /// valid because no more data is written when the FIFO is full, only the contents
            /// of the shift register are overwritten. The CPU must now read the data, to empty
            /// the FIFO.
            OE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40034018
        /// Flag Register, UARTFR
        pub const UARTFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear to send. This bit is the complement of the UART clear to send, nUARTCTS,
            /// modem status input. That is, the bit is 1 when nUARTCTS is LOW.
            CTS: u1,
            /// Data set ready. This bit is the complement of the UART data set ready, nUARTDSR,
            /// modem status input. That is, the bit is 1 when nUARTDSR is LOW.
            DSR: u1,
            /// Data carrier detect. This bit is the complement of the UART data carrier detect,
            /// nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW.
            DCD: u1,
            /// UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit
            /// remains set until the complete byte, including all the stop bits, has been sent
            /// from the shift register. This bit is set as soon as the transmit FIFO becomes
            /// non-empty, regardless of whether the UART is enabled or not.
            BUSY: u1,
            /// Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit
            /// in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the
            /// receive holding register is empty. If the FIFO is enabled, the RXFE bit is set
            /// when the receive FIFO is empty.
            RXFE: u1,
            /// Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit
            /// in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the
            /// transmit holding register is full. If the FIFO is enabled, the TXFF bit is set
            /// when the transmit FIFO is full.
            TXFF: u1,
            /// Receive FIFO full. The meaning of this bit depends on the state of the FEN bit
            /// in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the
            /// receive holding register is full. If the FIFO is enabled, the RXFF bit is set
            /// when the receive FIFO is full.
            RXFF: u1,
            /// Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit
            /// in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is
            /// set when the transmit holding register is empty. If the FIFO is enabled, the
            /// TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if
            /// there is data in the transmit shift register.
            TXFE: u1,
            /// Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI,
            /// modem status input. That is, the bit is 1 when nUARTRI is LOW.
            RI: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x40034020
        /// IrDA Low-Power Counter Register, UARTILPR
        pub const UARTILPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit low-power divisor value. These bits are cleared to 0 at reset.
            ILPDVSR: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x20);

        /// address: 0x40034024
        /// Integer Baud Rate Register, UARTIBRD
        pub const UARTIBRD = @intToPtr(*volatile Mmio(32, packed struct {
            /// The integer baud rate divisor. These bits are cleared to 0 on reset.
            BAUD_DIVINT: u16,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0x24);

        /// address: 0x40034028
        /// Fractional Baud Rate Register, UARTFBRD
        pub const UARTFBRD = @intToPtr(*volatile Mmio(32, packed struct {
            /// The fractional baud rate divisor. These bits are cleared to 0 on reset.
            BAUD_DIVFRAC: u6,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
        }), base_address + 0x28);

        /// address: 0x4003402c
        /// Line Control Register, UARTLCR_H
        pub const UARTLCR_H = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send break. If this bit is set to 1, a low-level is continually output on the
            /// UARTTXD output, after completing transmission of the current character. For the
            /// proper execution of the break command, the software must set this bit for at
            /// least two complete frames. For normal use, this bit must be cleared to 0.
            BRK: u1,
            /// Parity enable: 0 = parity is disabled and no parity bit added to the data frame
            /// 1 = parity checking and generation is enabled.
            PEN: u1,
            /// Even parity select. Controls the type of parity the UART uses during
            /// transmission and reception: 0 = odd parity. The UART generates or checks for an
            /// odd number of 1s in the data and parity bits. 1 = even parity. The UART
            /// generates or checks for an even number of 1s in the data and parity bits. This
            /// bit has no effect when the PEN bit disables parity checking and generation.
            EPS: u1,
            /// Two stop bits select. If this bit is set to 1, two stop bits are transmitted at
            /// the end of the frame. The receive logic does not check for two stop bits being
            /// received.
            STP2: u1,
            /// Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become
            /// 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled
            /// (FIFO mode).
            FEN: u1,
            /// Word length. These bits indicate the number of data bits transmitted or received
            /// in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits.
            WLEN: u2,
            /// Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit
            /// is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1
            /// then the parity bit is transmitted and checked as a 0. This bit has no effect
            /// when the PEN bit disables parity checking and generation.
            SPS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x2c);

        /// address: 0x40034030
        /// Control Register, UARTCR
        pub const UARTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// UART enable: 0 = UART is disabled. If the UART is disabled in the middle of
            /// transmission or reception, it completes the current character before stopping. 1
            /// = the UART is enabled. Data transmission and reception occurs for either UART
            /// signals or SIR signals depending on the setting of the SIREN bit.
            UARTEN: u1,
            /// SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse
            /// generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC
            /// is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD
            /// remains HIGH, in the marking state. Signal transitions on UARTRXD or modem
            /// status inputs have no effect. This bit has no effect if the UARTEN bit disables
            /// the UART.
            SIREN: u1,
            /// SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is
            /// cleared to 0, low-level bits are transmitted as an active high pulse with a
            /// width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are
            /// transmitted with a pulse width that is 3 times the period of the IrLPBaud16
            /// input signal, regardless of the selected bit rate. Setting this bit uses less
            /// power, but might reduce transmission distances.
            SIRLP: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the
            /// SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT
            /// path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test
            /// register must be set to 1 to override the normal half-duplex SIR operation. This
            /// must be the requirement for accessing the test registers during normal
            /// operation, and SIRTEST must be cleared to 0 when loopback testing is finished.
            /// This feature reduces the amount of external coupling required during system
            /// test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path
            /// is fed through to the UARTRXD path. In either SIR mode or UART mode, when this
            /// bit is set, the modem outputs are also fed through to the modem inputs. This bit
            /// is cleared to 0 on reset, to disable loopback.
            LBE: u1,
            /// Transmit enable. If this bit is set to 1, the transmit section of the UART is
            /// enabled. Data transmission occurs for either UART signals, or SIR signals
            /// depending on the setting of the SIREN bit. When the UART is disabled in the
            /// middle of transmission, it completes the current character before stopping.
            TXE: u1,
            /// Receive enable. If this bit is set to 1, the receive section of the UART is
            /// enabled. Data reception occurs for either UART signals or SIR signals depending
            /// on the setting of the SIREN bit. When the UART is disabled in the middle of
            /// reception, it completes the current character before stopping.
            RXE: u1,
            /// Data transmit ready. This bit is the complement of the UART data transmit ready,
            /// nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then
            /// nUARTDTR is LOW.
            DTR: u1,
            /// Request to send. This bit is the complement of the UART request to send,
            /// nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then
            /// nUARTRTS is LOW.
            RTS: u1,
            /// This bit is the complement of the UART Out1 (nUARTOut1) modem status output.
            /// That is, when the bit is programmed to a 1 the output is 0. For DTE this can be
            /// used as Data Carrier Detect (DCD).
            OUT1: u1,
            /// This bit is the complement of the UART Out2 (nUARTOut2) modem status output.
            /// That is, when the bit is programmed to a 1, the output is 0. For DTE this can be
            /// used as Ring Indicator (RI).
            OUT2: u1,
            /// RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow
            /// control is enabled. Data is only requested when there is space in the receive
            /// FIFO for it to be received.
            RTSEN: u1,
            /// CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow
            /// control is enabled. Data is only transmitted when the nUARTCTS signal is
            /// asserted.
            CTSEN: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0x30);

        /// address: 0x40034034
        /// Interrupt FIFO Level Select Register, UARTIFLS
        pub const UARTIFLS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit interrupt FIFO level select. The trigger points for the transmit
            /// interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8 full b001 =
            /// Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full
            /// b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit FIFO becomes <= 7 / 8
            /// full b101-b111 = reserved.
            TXIFLSEL: u3,
            /// Receive interrupt FIFO level select. The trigger points for the receive
            /// interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001 =
            /// Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full
            /// b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO becomes >= 7 / 8
            /// full b101-b111 = reserved.
            RXIFLSEL: u3,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
        }), base_address + 0x34);

        /// address: 0x40034038
        /// Interrupt Mask Set/Clear Register, UARTIMSC
        pub const UARTIMSC = @intToPtr(*volatile Mmio(32, packed struct {
            /// nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR
            /// interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write
            /// of 0 clears the mask.
            RIMIM: u1,
            /// nUARTCTS modem interrupt mask. A read returns the current mask for the
            /// UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is
            /// set. A write of 0 clears the mask.
            CTSMIM: u1,
            /// nUARTDCD modem interrupt mask. A read returns the current mask for the
            /// UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is
            /// set. A write of 0 clears the mask.
            DCDMIM: u1,
            /// nUARTDSR modem interrupt mask. A read returns the current mask for the
            /// UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is
            /// set. A write of 0 clears the mask.
            DSRMIM: u1,
            /// Receive interrupt mask. A read returns the current mask for the UARTRXINTR
            /// interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write
            /// of 0 clears the mask.
            RXIM: u1,
            /// Transmit interrupt mask. A read returns the current mask for the UARTTXINTR
            /// interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write
            /// of 0 clears the mask.
            TXIM: u1,
            /// Receive timeout interrupt mask. A read returns the current mask for the
            /// UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is
            /// set. A write of 0 clears the mask.
            RTIM: u1,
            /// Framing error interrupt mask. A read returns the current mask for the UARTFEINTR
            /// interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write
            /// of 0 clears the mask.
            FEIM: u1,
            /// Parity error interrupt mask. A read returns the current mask for the UARTPEINTR
            /// interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write
            /// of 0 clears the mask.
            PEIM: u1,
            /// Break error interrupt mask. A read returns the current mask for the UARTBEINTR
            /// interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write
            /// of 0 clears the mask.
            BEIM: u1,
            /// Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR
            /// interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write
            /// of 0 clears the mask.
            OEIM: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
        }), base_address + 0x38);

        /// address: 0x4003403c
        /// Raw Interrupt Status Register, UARTRIS
        pub const UARTRIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// nUARTRI modem interrupt status. Returns the raw interrupt state of the
            /// UARTRIINTR interrupt.
            RIRMIS: u1,
            /// nUARTCTS modem interrupt status. Returns the raw interrupt state of the
            /// UARTCTSINTR interrupt.
            CTSRMIS: u1,
            /// nUARTDCD modem interrupt status. Returns the raw interrupt state of the
            /// UARTDCDINTR interrupt.
            DCDRMIS: u1,
            /// nUARTDSR modem interrupt status. Returns the raw interrupt state of the
            /// UARTDSRINTR interrupt.
            DSRRMIS: u1,
            /// Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR
            /// interrupt.
            RXRIS: u1,
            /// Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR
            /// interrupt.
            TXRIS: u1,
            /// Receive timeout interrupt status. Returns the raw interrupt state of the
            /// UARTRTINTR interrupt. a
            RTRIS: u1,
            /// Framing error interrupt status. Returns the raw interrupt state of the
            /// UARTFEINTR interrupt.
            FERIS: u1,
            /// Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR
            /// interrupt.
            PERIS: u1,
            /// Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR
            /// interrupt.
            BERIS: u1,
            /// Overrun error interrupt status. Returns the raw interrupt state of the
            /// UARTOEINTR interrupt.
            OERIS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
        }), base_address + 0x3c);

        /// address: 0x40034040
        /// Masked Interrupt Status Register, UARTMIS
        pub const UARTMIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// nUARTRI modem masked interrupt status. Returns the masked interrupt state of the
            /// UARTRIINTR interrupt.
            RIMMIS: u1,
            /// nUARTCTS modem masked interrupt status. Returns the masked interrupt state of
            /// the UARTCTSINTR interrupt.
            CTSMMIS: u1,
            /// nUARTDCD modem masked interrupt status. Returns the masked interrupt state of
            /// the UARTDCDINTR interrupt.
            DCDMMIS: u1,
            /// nUARTDSR modem masked interrupt status. Returns the masked interrupt state of
            /// the UARTDSRINTR interrupt.
            DSRMMIS: u1,
            /// Receive masked interrupt status. Returns the masked interrupt state of the
            /// UARTRXINTR interrupt.
            RXMIS: u1,
            /// Transmit masked interrupt status. Returns the masked interrupt state of the
            /// UARTTXINTR interrupt.
            TXMIS: u1,
            /// Receive timeout masked interrupt status. Returns the masked interrupt state of
            /// the UARTRTINTR interrupt.
            RTMIS: u1,
            /// Framing error masked interrupt status. Returns the masked interrupt state of the
            /// UARTFEINTR interrupt.
            FEMIS: u1,
            /// Parity error masked interrupt status. Returns the masked interrupt state of the
            /// UARTPEINTR interrupt.
            PEMIS: u1,
            /// Break error masked interrupt status. Returns the masked interrupt state of the
            /// UARTBEINTR interrupt.
            BEMIS: u1,
            /// Overrun error masked interrupt status. Returns the masked interrupt state of the
            /// UARTOEINTR interrupt.
            OEMIS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
        }), base_address + 0x40);

        /// address: 0x40034044
        /// Interrupt Clear Register, UARTICR
        pub const UARTICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
            RIMIC: u1,
            /// nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
            CTSMIC: u1,
            /// nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
            DCDMIC: u1,
            /// nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
            DSRMIC: u1,
            /// Receive interrupt clear. Clears the UARTRXINTR interrupt.
            RXIC: u1,
            /// Transmit interrupt clear. Clears the UARTTXINTR interrupt.
            TXIC: u1,
            /// Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
            RTIC: u1,
            /// Framing error interrupt clear. Clears the UARTFEINTR interrupt.
            FEIC: u1,
            /// Parity error interrupt clear. Clears the UARTPEINTR interrupt.
            PEIC: u1,
            /// Break error interrupt clear. Clears the UARTBEINTR interrupt.
            BEIC: u1,
            /// Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
            OEIC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
        }), base_address + 0x44);

        /// address: 0x40034048
        /// DMA Control Register, UARTDMACR
        pub const UARTDMACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is
            /// enabled.
            RXDMAE: u1,
            /// Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is
            /// enabled.
            TXDMAE: u1,
            /// DMA on error. If this bit is set to 1, the DMA receive request outputs,
            /// UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is
            /// asserted.
            DMAONERR: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
        }), base_address + 0x48);

        /// address: 0x40034fe0
        /// UARTPeriphID0 Register
        pub const UARTPERIPHID0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x11
            PARTNUMBER0: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfe0);

        /// address: 0x40034fe4
        /// UARTPeriphID1 Register
        pub const UARTPERIPHID1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x0
            PARTNUMBER1: u4,
            /// These bits read back as 0x1
            DESIGNER0: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfe4);

        /// address: 0x40034fe8
        /// UARTPeriphID2 Register
        pub const UARTPERIPHID2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x4
            DESIGNER1: u4,
            /// This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4
            /// 0x2 r1p5 0x3
            REVISION: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfe8);

        /// address: 0x40034fec
        /// UARTPeriphID3 Register
        pub const UARTPERIPHID3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x00
            CONFIGURATION: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfec);

        /// address: 0x40034ff0
        /// UARTPCellID0 Register
        pub const UARTPCELLID0 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xff0);

        /// address: 0x40034ff4
        /// UARTPCellID1 Register
        pub const UARTPCELLID1 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xff4);

        /// address: 0x40034ff8
        /// UARTPCellID2 Register
        pub const UARTPCELLID2 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xff8);

        /// address: 0x40034ffc
        /// UARTPCellID3 Register
        pub const UARTPCELLID3 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xffc);
    };
    pub const UART1 = struct {
        pub const base_address = 0x40038000;

        /// address: 0x40038000
        /// Data Register, UARTDR
        pub const UARTDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive (read) data character. Transmit (write) data character.
            DATA: u8,
            /// Framing error. When set to 1, it indicates that the received character did not
            /// have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is
            /// associated with the character at the top of the FIFO.
            FE: u1,
            /// Parity error. When set to 1, it indicates that the parity of the received data
            /// character does not match the parity that the EPS and SPS bits in the Line
            /// Control Register, UARTLCR_H. In FIFO mode, this error is associated with the
            /// character at the top of the FIFO.
            PE: u1,
            /// Break error. This bit is set to 1 if a break condition was detected, indicating
            /// that the received data input was held LOW for longer than a full-word
            /// transmission time (defined as start, data, parity and stop bits). In FIFO mode,
            /// this error is associated with the character at the top of the FIFO. When a break
            /// occurs, only one 0 character is loaded into the FIFO. The next character is only
            /// enabled after the receive data input goes to a 1 (marking state), and the next
            /// valid start bit is received.
            BE: u1,
            /// Overrun error. This bit is set to 1 if data is received and the receive FIFO is
            /// already full. This is cleared to 0 once there is an empty space in the FIFO and
            /// a new character can be written to it.
            OE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40038004
        /// Receive Status Register/Error Clear Register, UARTRSR/UARTECR
        pub const UARTRSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Framing error. When set to 1, it indicates that the received character did not
            /// have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a
            /// write to UARTECR. In FIFO mode, this error is associated with the character at
            /// the top of the FIFO.
            FE: u1,
            /// Parity error. When set to 1, it indicates that the parity of the received data
            /// character does not match the parity that the EPS and SPS bits in the Line
            /// Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In
            /// FIFO mode, this error is associated with the character at the top of the FIFO.
            PE: u1,
            /// Break error. This bit is set to 1 if a break condition was detected, indicating
            /// that the received data input was held LOW for longer than a full-word
            /// transmission time (defined as start, data, parity, and stop bits). This bit is
            /// cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated
            /// with the character at the top of the FIFO. When a break occurs, only one 0
            /// character is loaded into the FIFO. The next character is only enabled after the
            /// receive data input goes to a 1 (marking state) and the next valid start bit is
            /// received.
            BE: u1,
            /// Overrun error. This bit is set to 1 if data is received and the FIFO is already
            /// full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain
            /// valid because no more data is written when the FIFO is full, only the contents
            /// of the shift register are overwritten. The CPU must now read the data, to empty
            /// the FIFO.
            OE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40038018
        /// Flag Register, UARTFR
        pub const UARTFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear to send. This bit is the complement of the UART clear to send, nUARTCTS,
            /// modem status input. That is, the bit is 1 when nUARTCTS is LOW.
            CTS: u1,
            /// Data set ready. This bit is the complement of the UART data set ready, nUARTDSR,
            /// modem status input. That is, the bit is 1 when nUARTDSR is LOW.
            DSR: u1,
            /// Data carrier detect. This bit is the complement of the UART data carrier detect,
            /// nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW.
            DCD: u1,
            /// UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit
            /// remains set until the complete byte, including all the stop bits, has been sent
            /// from the shift register. This bit is set as soon as the transmit FIFO becomes
            /// non-empty, regardless of whether the UART is enabled or not.
            BUSY: u1,
            /// Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit
            /// in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the
            /// receive holding register is empty. If the FIFO is enabled, the RXFE bit is set
            /// when the receive FIFO is empty.
            RXFE: u1,
            /// Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit
            /// in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the
            /// transmit holding register is full. If the FIFO is enabled, the TXFF bit is set
            /// when the transmit FIFO is full.
            TXFF: u1,
            /// Receive FIFO full. The meaning of this bit depends on the state of the FEN bit
            /// in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the
            /// receive holding register is full. If the FIFO is enabled, the RXFF bit is set
            /// when the receive FIFO is full.
            RXFF: u1,
            /// Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit
            /// in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is
            /// set when the transmit holding register is empty. If the FIFO is enabled, the
            /// TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if
            /// there is data in the transmit shift register.
            TXFE: u1,
            /// Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI,
            /// modem status input. That is, the bit is 1 when nUARTRI is LOW.
            RI: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x40038020
        /// IrDA Low-Power Counter Register, UARTILPR
        pub const UARTILPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit low-power divisor value. These bits are cleared to 0 at reset.
            ILPDVSR: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x20);

        /// address: 0x40038024
        /// Integer Baud Rate Register, UARTIBRD
        pub const UARTIBRD = @intToPtr(*volatile Mmio(32, packed struct {
            /// The integer baud rate divisor. These bits are cleared to 0 on reset.
            BAUD_DIVINT: u16,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0x24);

        /// address: 0x40038028
        /// Fractional Baud Rate Register, UARTFBRD
        pub const UARTFBRD = @intToPtr(*volatile Mmio(32, packed struct {
            /// The fractional baud rate divisor. These bits are cleared to 0 on reset.
            BAUD_DIVFRAC: u6,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
        }), base_address + 0x28);

        /// address: 0x4003802c
        /// Line Control Register, UARTLCR_H
        pub const UARTLCR_H = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send break. If this bit is set to 1, a low-level is continually output on the
            /// UARTTXD output, after completing transmission of the current character. For the
            /// proper execution of the break command, the software must set this bit for at
            /// least two complete frames. For normal use, this bit must be cleared to 0.
            BRK: u1,
            /// Parity enable: 0 = parity is disabled and no parity bit added to the data frame
            /// 1 = parity checking and generation is enabled.
            PEN: u1,
            /// Even parity select. Controls the type of parity the UART uses during
            /// transmission and reception: 0 = odd parity. The UART generates or checks for an
            /// odd number of 1s in the data and parity bits. 1 = even parity. The UART
            /// generates or checks for an even number of 1s in the data and parity bits. This
            /// bit has no effect when the PEN bit disables parity checking and generation.
            EPS: u1,
            /// Two stop bits select. If this bit is set to 1, two stop bits are transmitted at
            /// the end of the frame. The receive logic does not check for two stop bits being
            /// received.
            STP2: u1,
            /// Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become
            /// 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled
            /// (FIFO mode).
            FEN: u1,
            /// Word length. These bits indicate the number of data bits transmitted or received
            /// in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits.
            WLEN: u2,
            /// Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit
            /// is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1
            /// then the parity bit is transmitted and checked as a 0. This bit has no effect
            /// when the PEN bit disables parity checking and generation.
            SPS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x2c);

        /// address: 0x40038030
        /// Control Register, UARTCR
        pub const UARTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// UART enable: 0 = UART is disabled. If the UART is disabled in the middle of
            /// transmission or reception, it completes the current character before stopping. 1
            /// = the UART is enabled. Data transmission and reception occurs for either UART
            /// signals or SIR signals depending on the setting of the SIREN bit.
            UARTEN: u1,
            /// SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse
            /// generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC
            /// is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD
            /// remains HIGH, in the marking state. Signal transitions on UARTRXD or modem
            /// status inputs have no effect. This bit has no effect if the UARTEN bit disables
            /// the UART.
            SIREN: u1,
            /// SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is
            /// cleared to 0, low-level bits are transmitted as an active high pulse with a
            /// width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are
            /// transmitted with a pulse width that is 3 times the period of the IrLPBaud16
            /// input signal, regardless of the selected bit rate. Setting this bit uses less
            /// power, but might reduce transmission distances.
            SIRLP: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the
            /// SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT
            /// path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test
            /// register must be set to 1 to override the normal half-duplex SIR operation. This
            /// must be the requirement for accessing the test registers during normal
            /// operation, and SIRTEST must be cleared to 0 when loopback testing is finished.
            /// This feature reduces the amount of external coupling required during system
            /// test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path
            /// is fed through to the UARTRXD path. In either SIR mode or UART mode, when this
            /// bit is set, the modem outputs are also fed through to the modem inputs. This bit
            /// is cleared to 0 on reset, to disable loopback.
            LBE: u1,
            /// Transmit enable. If this bit is set to 1, the transmit section of the UART is
            /// enabled. Data transmission occurs for either UART signals, or SIR signals
            /// depending on the setting of the SIREN bit. When the UART is disabled in the
            /// middle of transmission, it completes the current character before stopping.
            TXE: u1,
            /// Receive enable. If this bit is set to 1, the receive section of the UART is
            /// enabled. Data reception occurs for either UART signals or SIR signals depending
            /// on the setting of the SIREN bit. When the UART is disabled in the middle of
            /// reception, it completes the current character before stopping.
            RXE: u1,
            /// Data transmit ready. This bit is the complement of the UART data transmit ready,
            /// nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then
            /// nUARTDTR is LOW.
            DTR: u1,
            /// Request to send. This bit is the complement of the UART request to send,
            /// nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then
            /// nUARTRTS is LOW.
            RTS: u1,
            /// This bit is the complement of the UART Out1 (nUARTOut1) modem status output.
            /// That is, when the bit is programmed to a 1 the output is 0. For DTE this can be
            /// used as Data Carrier Detect (DCD).
            OUT1: u1,
            /// This bit is the complement of the UART Out2 (nUARTOut2) modem status output.
            /// That is, when the bit is programmed to a 1, the output is 0. For DTE this can be
            /// used as Ring Indicator (RI).
            OUT2: u1,
            /// RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow
            /// control is enabled. Data is only requested when there is space in the receive
            /// FIFO for it to be received.
            RTSEN: u1,
            /// CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow
            /// control is enabled. Data is only transmitted when the nUARTCTS signal is
            /// asserted.
            CTSEN: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0x30);

        /// address: 0x40038034
        /// Interrupt FIFO Level Select Register, UARTIFLS
        pub const UARTIFLS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit interrupt FIFO level select. The trigger points for the transmit
            /// interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8 full b001 =
            /// Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full
            /// b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit FIFO becomes <= 7 / 8
            /// full b101-b111 = reserved.
            TXIFLSEL: u3,
            /// Receive interrupt FIFO level select. The trigger points for the receive
            /// interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001 =
            /// Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full
            /// b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO becomes >= 7 / 8
            /// full b101-b111 = reserved.
            RXIFLSEL: u3,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
        }), base_address + 0x34);

        /// address: 0x40038038
        /// Interrupt Mask Set/Clear Register, UARTIMSC
        pub const UARTIMSC = @intToPtr(*volatile Mmio(32, packed struct {
            /// nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR
            /// interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write
            /// of 0 clears the mask.
            RIMIM: u1,
            /// nUARTCTS modem interrupt mask. A read returns the current mask for the
            /// UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is
            /// set. A write of 0 clears the mask.
            CTSMIM: u1,
            /// nUARTDCD modem interrupt mask. A read returns the current mask for the
            /// UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is
            /// set. A write of 0 clears the mask.
            DCDMIM: u1,
            /// nUARTDSR modem interrupt mask. A read returns the current mask for the
            /// UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is
            /// set. A write of 0 clears the mask.
            DSRMIM: u1,
            /// Receive interrupt mask. A read returns the current mask for the UARTRXINTR
            /// interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write
            /// of 0 clears the mask.
            RXIM: u1,
            /// Transmit interrupt mask. A read returns the current mask for the UARTTXINTR
            /// interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write
            /// of 0 clears the mask.
            TXIM: u1,
            /// Receive timeout interrupt mask. A read returns the current mask for the
            /// UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is
            /// set. A write of 0 clears the mask.
            RTIM: u1,
            /// Framing error interrupt mask. A read returns the current mask for the UARTFEINTR
            /// interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write
            /// of 0 clears the mask.
            FEIM: u1,
            /// Parity error interrupt mask. A read returns the current mask for the UARTPEINTR
            /// interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write
            /// of 0 clears the mask.
            PEIM: u1,
            /// Break error interrupt mask. A read returns the current mask for the UARTBEINTR
            /// interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write
            /// of 0 clears the mask.
            BEIM: u1,
            /// Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR
            /// interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write
            /// of 0 clears the mask.
            OEIM: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
        }), base_address + 0x38);

        /// address: 0x4003803c
        /// Raw Interrupt Status Register, UARTRIS
        pub const UARTRIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// nUARTRI modem interrupt status. Returns the raw interrupt state of the
            /// UARTRIINTR interrupt.
            RIRMIS: u1,
            /// nUARTCTS modem interrupt status. Returns the raw interrupt state of the
            /// UARTCTSINTR interrupt.
            CTSRMIS: u1,
            /// nUARTDCD modem interrupt status. Returns the raw interrupt state of the
            /// UARTDCDINTR interrupt.
            DCDRMIS: u1,
            /// nUARTDSR modem interrupt status. Returns the raw interrupt state of the
            /// UARTDSRINTR interrupt.
            DSRRMIS: u1,
            /// Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR
            /// interrupt.
            RXRIS: u1,
            /// Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR
            /// interrupt.
            TXRIS: u1,
            /// Receive timeout interrupt status. Returns the raw interrupt state of the
            /// UARTRTINTR interrupt. a
            RTRIS: u1,
            /// Framing error interrupt status. Returns the raw interrupt state of the
            /// UARTFEINTR interrupt.
            FERIS: u1,
            /// Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR
            /// interrupt.
            PERIS: u1,
            /// Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR
            /// interrupt.
            BERIS: u1,
            /// Overrun error interrupt status. Returns the raw interrupt state of the
            /// UARTOEINTR interrupt.
            OERIS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
        }), base_address + 0x3c);

        /// address: 0x40038040
        /// Masked Interrupt Status Register, UARTMIS
        pub const UARTMIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// nUARTRI modem masked interrupt status. Returns the masked interrupt state of the
            /// UARTRIINTR interrupt.
            RIMMIS: u1,
            /// nUARTCTS modem masked interrupt status. Returns the masked interrupt state of
            /// the UARTCTSINTR interrupt.
            CTSMMIS: u1,
            /// nUARTDCD modem masked interrupt status. Returns the masked interrupt state of
            /// the UARTDCDINTR interrupt.
            DCDMMIS: u1,
            /// nUARTDSR modem masked interrupt status. Returns the masked interrupt state of
            /// the UARTDSRINTR interrupt.
            DSRMMIS: u1,
            /// Receive masked interrupt status. Returns the masked interrupt state of the
            /// UARTRXINTR interrupt.
            RXMIS: u1,
            /// Transmit masked interrupt status. Returns the masked interrupt state of the
            /// UARTTXINTR interrupt.
            TXMIS: u1,
            /// Receive timeout masked interrupt status. Returns the masked interrupt state of
            /// the UARTRTINTR interrupt.
            RTMIS: u1,
            /// Framing error masked interrupt status. Returns the masked interrupt state of the
            /// UARTFEINTR interrupt.
            FEMIS: u1,
            /// Parity error masked interrupt status. Returns the masked interrupt state of the
            /// UARTPEINTR interrupt.
            PEMIS: u1,
            /// Break error masked interrupt status. Returns the masked interrupt state of the
            /// UARTBEINTR interrupt.
            BEMIS: u1,
            /// Overrun error masked interrupt status. Returns the masked interrupt state of the
            /// UARTOEINTR interrupt.
            OEMIS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
        }), base_address + 0x40);

        /// address: 0x40038044
        /// Interrupt Clear Register, UARTICR
        pub const UARTICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
            RIMIC: u1,
            /// nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
            CTSMIC: u1,
            /// nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
            DCDMIC: u1,
            /// nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
            DSRMIC: u1,
            /// Receive interrupt clear. Clears the UARTRXINTR interrupt.
            RXIC: u1,
            /// Transmit interrupt clear. Clears the UARTTXINTR interrupt.
            TXIC: u1,
            /// Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
            RTIC: u1,
            /// Framing error interrupt clear. Clears the UARTFEINTR interrupt.
            FEIC: u1,
            /// Parity error interrupt clear. Clears the UARTPEINTR interrupt.
            PEIC: u1,
            /// Break error interrupt clear. Clears the UARTBEINTR interrupt.
            BEIC: u1,
            /// Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
            OEIC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
        }), base_address + 0x44);

        /// address: 0x40038048
        /// DMA Control Register, UARTDMACR
        pub const UARTDMACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is
            /// enabled.
            RXDMAE: u1,
            /// Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is
            /// enabled.
            TXDMAE: u1,
            /// DMA on error. If this bit is set to 1, the DMA receive request outputs,
            /// UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is
            /// asserted.
            DMAONERR: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
        }), base_address + 0x48);

        /// address: 0x40038fe0
        /// UARTPeriphID0 Register
        pub const UARTPERIPHID0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x11
            PARTNUMBER0: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfe0);

        /// address: 0x40038fe4
        /// UARTPeriphID1 Register
        pub const UARTPERIPHID1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x0
            PARTNUMBER1: u4,
            /// These bits read back as 0x1
            DESIGNER0: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfe4);

        /// address: 0x40038fe8
        /// UARTPeriphID2 Register
        pub const UARTPERIPHID2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x4
            DESIGNER1: u4,
            /// This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4
            /// 0x2 r1p5 0x3
            REVISION: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfe8);

        /// address: 0x40038fec
        /// UARTPeriphID3 Register
        pub const UARTPERIPHID3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x00
            CONFIGURATION: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfec);

        /// address: 0x40038ff0
        /// UARTPCellID0 Register
        pub const UARTPCELLID0 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xff0);

        /// address: 0x40038ff4
        /// UARTPCellID1 Register
        pub const UARTPCELLID1 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xff4);

        /// address: 0x40038ff8
        /// UARTPCellID2 Register
        pub const UARTPCELLID2 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xff8);

        /// address: 0x40038ffc
        /// UARTPCellID3 Register
        pub const UARTPCELLID3 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xffc);
    };
    pub const SPI0 = struct {
        pub const base_address = 0x4003c000;
        pub const version = "1";

        /// address: 0x4003c000
        /// Control register 0, SSPCR0 on page 3-4
        pub const SSPCR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined
            /// operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data.
            /// 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit
            /// data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data.
            /// 1110 15-bit data. 1111 16-bit data.
            DSS: u4,
            /// Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame
            /// format. 10 National Microwire frame format. 11 Reserved, undefined operation.
            FRF: u2,
            /// SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola
            /// SPI frame format on page 2-10.
            SPO: u1,
            /// SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI
            /// frame format on page 2-10.
            SPH: u1,
            /// Serial clock rate. The value SCR is used to generate the transmit and receive
            /// bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where
            /// CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and
            /// SCR is a value from 0-255.
            SCR: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x4003c004
        /// Control register 1, SSPCR1 on page 3-5
        pub const SSPCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit
            /// serial shifter is connected to input of receive serial shifter internally.
            LBM: u1,
            /// Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation
            /// enabled.
            SSE: u1,
            /// Master or slave mode select. This bit can be modified only when the PrimeCell
            /// SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device
            /// configured as slave.
            MS: u1,
            /// Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In
            /// multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast
            /// a message to all slaves in the system while ensuring that only one slave drives
            /// data onto its serial output line. In such systems the RXD lines from multiple
            /// slaves could be tied together. To operate in such systems, the SOD bit can be
            /// set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP
            /// can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD
            /// output in slave mode.
            SOD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x4003c008
        /// Data register, SSPDR on page 3-6
        pub const SSPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must
            /// right-justify data when the PrimeCell SSP is programmed for a data size that is
            /// less than 16 bits. Unused bits at the top are ignored by transmit logic. The
            /// receive logic automatically right-justifies.
            DATA: u16,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x4003c00c
        /// Status register, SSPSR on page 3-7
        pub const SSPSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty.
            TFE: u1,
            /// Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not
            /// full.
            TNF: u1,
            /// Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not
            /// empty.
            RNE: u1,
            /// Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full.
            RFF: u1,
            /// PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting
            /// and/or receiving a frame or the transmit FIFO is not empty.
            BSY: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
        }), base_address + 0xc);

        /// address: 0x4003c010
        /// Clock prescale register, SSPCPSR on page 3-8
        pub const SSPCPSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock prescale divisor. Must be an even number from 2-254, depending on the
            /// frequency of SSPCLK. The least significant bit always returns zero on reads.
            CPSDVSR: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x10);

        /// address: 0x4003c014
        /// Interrupt mask set or clear register, SSPIMSC on page 3-9
        pub const SSPIMSC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive overrun interrupt mask: 0 Receive FIFO written to while full condition
            /// interrupt is masked. 1 Receive FIFO written to while full condition interrupt is
            /// not masked.
            RORIM: u1,
            /// Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to
            /// timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior
            /// to timeout period interrupt is not masked.
            RTIM: u1,
            /// Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition
            /// interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not
            /// masked.
            RXIM: u1,
            /// Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition
            /// interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is
            /// not masked.
            TXIM: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x14);

        /// address: 0x4003c018
        /// Raw interrupt status register, SSPRIS on page 3-10
        pub const SSPRIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt
            RORRIS: u1,
            /// Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt
            RTRIS: u1,
            /// Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt
            RXRIS: u1,
            /// Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt
            TXRIS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x4003c01c
        /// Masked interrupt status register, SSPMIS on page 3-11
        pub const SSPMIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gives the receive over run masked interrupt status, after masking, of the
            /// SSPRORINTR interrupt
            RORMIS: u1,
            /// Gives the receive timeout masked interrupt state, after masking, of the
            /// SSPRTINTR interrupt
            RTMIS: u1,
            /// Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR
            /// interrupt
            RXMIS: u1,
            /// Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR
            /// interrupt
            TXMIS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x1c);

        /// address: 0x4003c020
        /// Interrupt clear register, SSPICR on page 3-11
        pub const SSPICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clears the SSPRORINTR interrupt
            RORIC: u1,
            /// Clears the SSPRTINTR interrupt
            RTIC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
        }), base_address + 0x20);

        /// address: 0x4003c024
        /// DMA control register, SSPDMACR on page 3-12
        pub const SSPDMACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is
            /// enabled.
            RXDMAE: u1,
            /// Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is
            /// enabled.
            TXDMAE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
        }), base_address + 0x24);

        /// address: 0x4003cfe0
        /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
        pub const SSPPERIPHID0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x22
            PARTNUMBER0: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfe0);

        /// address: 0x4003cfe4
        /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
        pub const SSPPERIPHID1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x0
            PARTNUMBER1: u4,
            /// These bits read back as 0x1
            DESIGNER0: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfe4);

        /// address: 0x4003cfe8
        /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
        pub const SSPPERIPHID2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x4
            DESIGNER1: u4,
            /// These bits return the peripheral revision
            REVISION: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfe8);

        /// address: 0x4003cfec
        /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
        pub const SSPPERIPHID3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x00
            CONFIGURATION: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfec);

        /// address: 0x4003cff0
        /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
        pub const SSPPCELLID0 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xff0);

        /// address: 0x4003cff4
        /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
        pub const SSPPCELLID1 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xff4);

        /// address: 0x4003cff8
        /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
        pub const SSPPCELLID2 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xff8);

        /// address: 0x4003cffc
        /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
        pub const SSPPCELLID3 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xffc);
    };
    pub const SPI1 = struct {
        pub const base_address = 0x40040000;

        /// address: 0x40040000
        /// Control register 0, SSPCR0 on page 3-4
        pub const SSPCR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined
            /// operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data.
            /// 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit
            /// data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data.
            /// 1110 15-bit data. 1111 16-bit data.
            DSS: u4,
            /// Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame
            /// format. 10 National Microwire frame format. 11 Reserved, undefined operation.
            FRF: u2,
            /// SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola
            /// SPI frame format on page 2-10.
            SPO: u1,
            /// SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI
            /// frame format on page 2-10.
            SPH: u1,
            /// Serial clock rate. The value SCR is used to generate the transmit and receive
            /// bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where
            /// CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and
            /// SCR is a value from 0-255.
            SCR: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40040004
        /// Control register 1, SSPCR1 on page 3-5
        pub const SSPCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit
            /// serial shifter is connected to input of receive serial shifter internally.
            LBM: u1,
            /// Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation
            /// enabled.
            SSE: u1,
            /// Master or slave mode select. This bit can be modified only when the PrimeCell
            /// SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device
            /// configured as slave.
            MS: u1,
            /// Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In
            /// multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast
            /// a message to all slaves in the system while ensuring that only one slave drives
            /// data onto its serial output line. In such systems the RXD lines from multiple
            /// slaves could be tied together. To operate in such systems, the SOD bit can be
            /// set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP
            /// can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD
            /// output in slave mode.
            SOD: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40040008
        /// Data register, SSPDR on page 3-6
        pub const SSPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must
            /// right-justify data when the PrimeCell SSP is programmed for a data size that is
            /// less than 16 bits. Unused bits at the top are ignored by transmit logic. The
            /// receive logic automatically right-justifies.
            DATA: u16,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x4004000c
        /// Status register, SSPSR on page 3-7
        pub const SSPSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty.
            TFE: u1,
            /// Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not
            /// full.
            TNF: u1,
            /// Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not
            /// empty.
            RNE: u1,
            /// Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full.
            RFF: u1,
            /// PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting
            /// and/or receiving a frame or the transmit FIFO is not empty.
            BSY: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
        }), base_address + 0xc);

        /// address: 0x40040010
        /// Clock prescale register, SSPCPSR on page 3-8
        pub const SSPCPSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock prescale divisor. Must be an even number from 2-254, depending on the
            /// frequency of SSPCLK. The least significant bit always returns zero on reads.
            CPSDVSR: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x10);

        /// address: 0x40040014
        /// Interrupt mask set or clear register, SSPIMSC on page 3-9
        pub const SSPIMSC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive overrun interrupt mask: 0 Receive FIFO written to while full condition
            /// interrupt is masked. 1 Receive FIFO written to while full condition interrupt is
            /// not masked.
            RORIM: u1,
            /// Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to
            /// timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior
            /// to timeout period interrupt is not masked.
            RTIM: u1,
            /// Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition
            /// interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not
            /// masked.
            RXIM: u1,
            /// Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition
            /// interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is
            /// not masked.
            TXIM: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x14);

        /// address: 0x40040018
        /// Raw interrupt status register, SSPRIS on page 3-10
        pub const SSPRIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt
            RORRIS: u1,
            /// Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt
            RTRIS: u1,
            /// Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt
            RXRIS: u1,
            /// Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt
            TXRIS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x4004001c
        /// Masked interrupt status register, SSPMIS on page 3-11
        pub const SSPMIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gives the receive over run masked interrupt status, after masking, of the
            /// SSPRORINTR interrupt
            RORMIS: u1,
            /// Gives the receive timeout masked interrupt state, after masking, of the
            /// SSPRTINTR interrupt
            RTMIS: u1,
            /// Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR
            /// interrupt
            RXMIS: u1,
            /// Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR
            /// interrupt
            TXMIS: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x1c);

        /// address: 0x40040020
        /// Interrupt clear register, SSPICR on page 3-11
        pub const SSPICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clears the SSPRORINTR interrupt
            RORIC: u1,
            /// Clears the SSPRTINTR interrupt
            RTIC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
        }), base_address + 0x20);

        /// address: 0x40040024
        /// DMA control register, SSPDMACR on page 3-12
        pub const SSPDMACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is
            /// enabled.
            RXDMAE: u1,
            /// Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is
            /// enabled.
            TXDMAE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
        }), base_address + 0x24);

        /// address: 0x40040fe0
        /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
        pub const SSPPERIPHID0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x22
            PARTNUMBER0: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfe0);

        /// address: 0x40040fe4
        /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
        pub const SSPPERIPHID1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x0
            PARTNUMBER1: u4,
            /// These bits read back as 0x1
            DESIGNER0: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfe4);

        /// address: 0x40040fe8
        /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
        pub const SSPPERIPHID2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x4
            DESIGNER1: u4,
            /// These bits return the peripheral revision
            REVISION: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfe8);

        /// address: 0x40040fec
        /// Peripheral identification registers, SSPPeriphID0-3 on page 3-13
        pub const SSPPERIPHID3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits read back as 0x00
            CONFIGURATION: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xfec);

        /// address: 0x40040ff0
        /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
        pub const SSPPCELLID0 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xff0);

        /// address: 0x40040ff4
        /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
        pub const SSPPCELLID1 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xff4);

        /// address: 0x40040ff8
        /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
        pub const SSPPCELLID2 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xff8);

        /// address: 0x40040ffc
        /// PrimeCell identification registers, SSPPCellID0-3 on page 3-16
        pub const SSPPCELLID3 = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xffc);
    };

    /// DW_apb_i2c address block\n\n
    /// List of configuration constants for the Synopsys I2C hardware (you may see
    /// references to these in I2C register header; these are *fixed* values, set at
    /// hardware design time):\n\n
    /// IC_ULTRA_FAST_MODE ................ 0x0\n
    /// IC_UFM_TBUF_CNT_DEFAULT ........... 0x8\n
    /// IC_UFM_SCL_LOW_COUNT .............. 0x0008\n
    /// IC_UFM_SCL_HIGH_COUNT ............. 0x0006\n
    /// IC_TX_TL .......................... 0x0\n
    /// IC_TX_CMD_BLOCK ................... 0x1\n
    /// IC_HAS_DMA ........................ 0x1\n
    /// IC_HAS_ASYNC_FIFO ................. 0x0\n
    /// IC_SMBUS_ARP ...................... 0x0\n
    /// IC_FIRST_DATA_BYTE_STATUS ......... 0x1\n
    /// IC_INTR_IO ........................ 0x1\n
    /// IC_MASTER_MODE .................... 0x1\n
    /// IC_DEFAULT_ACK_GENERAL_CALL ....... 0x1\n
    /// IC_INTR_POL ....................... 0x1\n
    /// IC_OPTIONAL_SAR ................... 0x0\n
    /// IC_DEFAULT_TAR_SLAVE_ADDR ......... 0x055\n
    /// IC_DEFAULT_SLAVE_ADDR ............. 0x055\n
    /// IC_DEFAULT_HS_SPKLEN .............. 0x1\n
    /// IC_FS_SCL_HIGH_COUNT .............. 0x0006\n
    /// IC_HS_SCL_LOW_COUNT ............... 0x0008\n
    /// IC_DEVICE_ID_VALUE ................ 0x0\n
    /// IC_10BITADDR_MASTER ............... 0x0\n
    /// IC_CLK_FREQ_OPTIMIZATION .......... 0x0\n
    /// IC_DEFAULT_FS_SPKLEN .............. 0x7\n
    /// IC_ADD_ENCODED_PARAMS ............. 0x0\n
    /// IC_DEFAULT_SDA_HOLD ............... 0x000001\n
    /// IC_DEFAULT_SDA_SETUP .............. 0x64\n
    /// IC_AVOID_RX_FIFO_FLUSH_ON_TX_ABRT . 0x0\n
    /// IC_CLOCK_PERIOD ................... 100\n
    /// IC_EMPTYFIFO_HOLD_MASTER_EN ....... 1\n
    /// IC_RESTART_EN ..................... 0x1\n
    /// IC_TX_CMD_BLOCK_DEFAULT ........... 0x0\n
    /// IC_BUS_CLEAR_FEATURE .............. 0x0\n
    /// IC_CAP_LOADING .................... 100\n
    /// IC_FS_SCL_LOW_COUNT ............... 0x000d\n
    /// APB_DATA_WIDTH .................... 32\n
    /// IC_SDA_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff\n
    /// IC_SLV_DATA_NACK_ONLY ............. 0x1\n
    /// IC_10BITADDR_SLAVE ................ 0x0\n
    /// IC_CLK_TYPE ....................... 0x0\n
    /// IC_SMBUS_UDID_MSB ................. 0x0\n
    /// IC_SMBUS_SUSPEND_ALERT ............ 0x0\n
    /// IC_HS_SCL_HIGH_COUNT .............. 0x0006\n
    /// IC_SLV_RESTART_DET_EN ............. 0x1\n
    /// IC_SMBUS .......................... 0x0\n
    /// IC_OPTIONAL_SAR_DEFAULT ........... 0x0\n
    /// IC_PERSISTANT_SLV_ADDR_DEFAULT .... 0x0\n
    /// IC_USE_COUNTS ..................... 0x0\n
    /// IC_RX_BUFFER_DEPTH ................ 16\n
    /// IC_SCL_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff\n
    /// IC_RX_FULL_HLD_BUS_EN ............. 0x1\n
    /// IC_SLAVE_DISABLE .................. 0x1\n
    /// IC_RX_TL .......................... 0x0\n
    /// IC_DEVICE_ID ...................... 0x0\n
    /// IC_HC_COUNT_VALUES ................ 0x0\n
    /// I2C_DYNAMIC_TAR_UPDATE ............ 0\n
    /// IC_SMBUS_CLK_LOW_MEXT_DEFAULT ..... 0xffffffff\n
    /// IC_SMBUS_CLK_LOW_SEXT_DEFAULT ..... 0xffffffff\n
    /// IC_HS_MASTER_CODE ................. 0x1\n
    /// IC_SMBUS_RST_IDLE_CNT_DEFAULT ..... 0xffff\n
    /// IC_SMBUS_UDID_LSB_DEFAULT ......... 0xffffffff\n
    /// IC_SS_SCL_HIGH_COUNT .............. 0x0028\n
    /// IC_SS_SCL_LOW_COUNT ............... 0x002f\n
    /// IC_MAX_SPEED_MODE ................. 0x2\n
    /// IC_STAT_FOR_CLK_STRETCH ........... 0x0\n
    /// IC_STOP_DET_IF_MASTER_ACTIVE ...... 0x0\n
    /// IC_DEFAULT_UFM_SPKLEN ............. 0x1\n
    /// IC_TX_BUFFER_DEPTH ................ 16
    pub const I2C0 = struct {
        pub const base_address = 0x40044000;
        pub const version = "1";

        /// address: 0x40044000
        /// I2C Control Register. This register can be written only when the DW_apb_i2c is
        /// disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes
        /// at other times have no effect.\n\n
        /// Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read
        /// only - bit 17 is read only - bits 18 and 19 are read only.
        pub const IC_CON = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit controls whether the DW_apb_i2c master is enabled.\n\n
            /// NOTE: Software should ensure that if this bit is written with '1' then bit 6
            /// should also be written with a '1'.
            MASTER_MODE: u1,
            /// These bits control at which speed the DW_apb_i2c operates; its setting is
            /// relevant only if one is operating the DW_apb_i2c in master mode. Hardware
            /// protects against illegal values being programmed by software. These bits must be
            /// programmed appropriately for slave mode also, as it is used to capture correct
            /// value of spike filter as per the speed mode.\n\n
            /// This register should be programmed only with a value in the range of 1 to
            /// IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of
            /// IC_MAX_SPEED_MODE.\n\n
            /// 1: standard mode (100 kbit/s)\n\n
            /// 2: fast mode (<=400 kbit/s) or fast mode plus (<=1000Kbit/s)\n\n
            /// 3: high speed mode (3.4 Mbit/s)\n\n
            /// Note: This field is not applicable when IC_ULTRA_FAST_MODE=1
            SPEED: u2,
            /// When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7-
            /// or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions
            /// that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of
            /// the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c
            /// responds to only 10-bit addressing transfers that match the full 10 bits of the
            /// IC_SAR register.
            IC_10BITADDR_SLAVE: u1,
            /// Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing
            /// mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing
            IC_10BITADDR_MASTER: u1,
            /// Determines whether RESTART conditions may be sent when acting as a master. Some
            /// older slaves do not support handling RESTART conditions; however, RESTART
            /// conditions are used in several DW_apb_i2c operations. When RESTART is disabled,
            /// the master is prohibited from performing the following functions: - Sending a
            /// START BYTE - Performing any high-speed mode operation - High-speed mode
            /// operation - Performing direction changes in combined format mode - Performing a
            /// read operation with a 10-bit address By replacing RESTART condition followed by
            /// a STOP and a subsequent START condition, split operations are broken down into
            /// multiple DW_apb_i2c transfers. If the above operations are performed, it will
            /// result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.\n\n
            /// Reset value: ENABLED
            IC_RESTART_EN: u1,
            /// This bit controls whether I2C has its slave disabled, which means once the
            /// presetn signal is applied, then this bit is set and the slave is disabled.\n\n
            /// If this bit is set (slave is disabled), DW_apb_i2c functions only as a master
            /// and does not perform any action that requires a slave.\n\n
            /// NOTE: Software should ensure that if this bit is written with 0, then bit 0
            /// should also be written with a 0.
            IC_SLAVE_DISABLE: u1,
            /// In slave mode: - 1'b1: issues the STOP_DET interrupt only when it is addressed.
            /// - 1'b0: issues the STOP_DET irrespective of whether it's addressed or not. Reset
            /// value: 0x0\n\n
            /// NOTE: During a general call address, this slave does not issue the STOP_DET
            /// interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the
            /// general call address by generating ACK. The STOP_DET interrupt is generated only
            /// when the transmitted address matches the slave address (SAR).
            STOP_DET_IFADDRESSED: u1,
            /// This bit controls the generation of the TX_EMPTY interrupt, as described in the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0.
            TX_EMPTY_CTRL: u1,
            /// This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is
            /// physically full to its RX_BUFFER_DEPTH, as described in the
            /// IC_RX_FULL_HLD_BUS_EN parameter.\n\n
            /// Reset value: 0x0.
            RX_FIFO_FULL_HLD_CTRL: u1,
            /// Master issues the STOP_DET interrupt irrespective of whether master is active or
            /// not
            STOP_DET_IF_MASTER_ACTIVE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40044004
        /// I2C Target Address Register\n\n
        /// This register is 12 bits wide, and bits 31:12 are reserved. This register can be
        /// written to only when IC_ENABLE[0] is set to 0.\n\n
        /// Note: If the software or application is aware that the DW_apb_i2c is not using
        /// the TAR address for the pending commands in the Tx FIFO, then it is possible to
        /// update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). -
        /// It is not necessary to perform any write to this register if DW_apb_i2c is
        /// enabled as an I2C slave only.
        pub const IC_TAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// This is the target address for any master transaction. When transmitting a
            /// General Call, these bits are ignored. To generate a START BYTE, the CPU needs to
            /// write only once into these bits.\n\n
            /// If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared
            /// between master and slave, so full loopback is not feasible. Only one direction
            /// loopback mode is supported (simplex), not duplex. A master cannot transmit to
            /// itself; it can transmit to only a slave.
            IC_TAR: u10,
            /// If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit
            /// indicates whether a General Call or START byte command is to be performed by the
            /// DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only
            /// writes may be performed. Attempting to issue a read command results in setting
            /// bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in
            /// General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START
            /// BYTE Reset value: 0x0
            GC_OR_START: u1,
            /// This bit indicates whether software performs a Device-ID or General Call or
            /// START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1:
            /// perform special I2C command as specified in Device_ID or GC_OR_START bit Reset
            /// value: 0x0
            SPECIAL: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40044008
        /// I2C Slave Address Register
        pub const IC_SAR = @intToPtr(*volatile MmioInt(32, u10), base_address + 0x8);

        /// address: 0x40044010
        /// I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes
        /// to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX
        /// FIFO.\n\n
        /// The size of the register changes as follows:\n\n
        /// Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when
        /// IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1
        /// - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to
        /// continue acknowledging reads, a read command should be written for every byte
        /// that is to be received; otherwise the DW_apb_i2c will stop acknowledging.
        pub const IC_DATA_CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register contains the data to be transmitted or received on the I2C bus. If
            /// you are writing to this register and want to perform a read, bits 7:0 (DAT) are
            /// ignored by the DW_apb_i2c. However, when you read this register, these bits
            /// return the value of data received on the DW_apb_i2c interface.\n\n
            /// Reset value: 0x0
            DAT: u8,
            /// This bit controls whether a read or a write is performed. This bit does not
            /// control the direction when the DW_apb_i2con acts as a slave. It controls only
            /// the direction when it acts as a master.\n\n
            /// When a command is entered in the TX FIFO, this bit distinguishes the write and
            /// read commands. In slave-receiver mode, this bit is a 'don't care' because writes
            /// to this register are not required. In slave-transmitter mode, a '0' indicates
            /// that the data in IC_DATA_CMD is to be transmitted.\n\n
            /// When programming this bit, you should remember the following: attempting to
            /// perform a read operation after a General Call command has been sent results in a
            /// TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11
            /// (SPECIAL) in the IC_TAR register has been cleared. If a '1' is written to this
            /// bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n
            /// Reset value: 0x0
            CMD: u1,
            /// This bit controls whether a STOP is issued after the byte is sent or
            /// received.\n\n
            /// - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO
            /// is empty. If the Tx FIFO is not empty, the master immediately tries to start a
            /// new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not
            /// issued after this byte, regardless of whether or not the Tx FIFO is empty. If
            /// the Tx FIFO is not empty, the master continues the current transfer by
            /// sending/receiving data bytes according to the value of the CMD bit. If the Tx
            /// FIFO is empty, the master holds the SCL line low and stalls the bus until a new
            /// command is available in the Tx FIFO. Reset value: 0x0
            STOP: u1,
            /// This bit controls whether a RESTART is issued before the byte is sent or
            /// received.\n\n
            /// 1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received
            /// (according to the value of CMD), regardless of whether or not the transfer
            /// direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP
            /// followed by a START is issued instead.\n\n
            /// 0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is
            /// changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a
            /// START is issued instead.\n\n
            /// Reset value: 0x0
            RESTART: u1,
            /// Indicates the first data byte received after the address phase for receive
            /// transfer in Master receiver or Slave receiver mode.\n\n
            /// Reset value : 0x0\n\n
            /// NOTE: In case of APB_DATA_WIDTH=8,\n\n
            /// 1. The user has to perform two APB Reads to IC_DATA_CMD in order to get status
            /// on 11 bit.\n\n
            /// 2. In order to read the 11 bit, the user has to perform the first data byte read
            /// [7:0] (offset 0x10) and then perform the second read [15:8] (offset 0x11) in
            /// order to know the status of 11 bit (whether the data received in previous read
            /// is a first data byte or not).\n\n
            /// 3. The 11th bit is an optional read field, user can ignore 2nd byte read [15:8]
            /// (offset 0x11) if not interested in FIRST_DATA_BYTE status.
            FIRST_DATA_BYTE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x10);

        /// address: 0x40044014
        /// Standard Speed I2C Clock SCL High Count Register
        pub const IC_SS_SCL_HCNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x14);

        /// address: 0x40044018
        /// Standard Speed I2C Clock SCL Low Count Register
        pub const IC_SS_SCL_LCNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x18);

        /// address: 0x4004401c
        /// Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
        pub const IC_FS_SCL_HCNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x1c);

        /// address: 0x40044020
        /// Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
        pub const IC_FS_SCL_LCNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x20);

        /// address: 0x4004402c
        /// I2C Interrupt Status Register\n\n
        /// Each bit in this register has a corresponding mask bit in the IC_INTR_MASK
        /// register. These bits are cleared by reading the matching interrupt clear
        /// register. The unmasked raw versions of these bits are available in the
        /// IC_RAW_INTR_STAT register.
        pub const IC_INTR_STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.\n\n
            /// Reset value: 0x0
            R_RX_UNDER: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.\n\n
            /// Reset value: 0x0
            R_RX_OVER: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.\n\n
            /// Reset value: 0x0
            R_RX_FULL: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.\n\n
            /// Reset value: 0x0
            R_TX_OVER: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.\n\n
            /// Reset value: 0x0
            R_TX_EMPTY: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.\n\n
            /// Reset value: 0x0
            R_RD_REQ: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.\n\n
            /// Reset value: 0x0
            R_TX_ABRT: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.\n\n
            /// Reset value: 0x0
            R_RX_DONE: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.\n\n
            /// Reset value: 0x0
            R_ACTIVITY: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.\n\n
            /// Reset value: 0x0
            R_STOP_DET: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.\n\n
            /// Reset value: 0x0
            R_START_DET: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.\n\n
            /// Reset value: 0x0
            R_GEN_CALL: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.\n\n
            /// Reset value: 0x0
            R_RESTART_DET: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
        }), base_address + 0x2c);

        /// address: 0x40044030
        /// I2C Interrupt Mask Register.\n\n
        /// These bits mask their corresponding interrupt status bits. This register is
        /// active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the
        /// interrupt.
        pub const IC_INTR_MASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_RX_UNDER: u1,
            /// This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_RX_OVER: u1,
            /// This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_RX_FULL: u1,
            /// This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_TX_OVER: u1,
            /// This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_TX_EMPTY: u1,
            /// This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_RD_REQ: u1,
            /// This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_TX_ABRT: u1,
            /// This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_RX_DONE: u1,
            /// This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x0
            M_ACTIVITY: u1,
            /// This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x0
            M_STOP_DET: u1,
            /// This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x0
            M_START_DET: u1,
            /// This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_GEN_CALL: u1,
            /// This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x0
            M_RESTART_DET: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
        }), base_address + 0x30);

        /// address: 0x40044034
        /// I2C Raw Interrupt Status Register\n\n
        /// Unlike the IC_INTR_STAT register, these bits are not masked so they always show
        /// the true status of the DW_apb_i2c.
        pub const IC_RAW_INTR_STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set if the processor attempts to read the receive buffer when it is empty by
            /// reading from the IC_DATA_CMD register. If the module is disabled
            /// (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state
            /// machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n
            /// Reset value: 0x0
            RX_UNDER: u1,
            /// Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an
            /// additional byte is received from an external I2C device. The DW_apb_i2c
            /// acknowledges this, but any data bytes received after the FIFO is full are lost.
            /// If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the
            /// master or slave state machines go into idle, and when ic_en goes to 0, this
            /// interrupt is cleared.\n\n
            /// Note: If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to
            /// HIGH, then the RX_OVER interrupt never occurs, because the Rx FIFO never
            /// overflows.\n\n
            /// Reset value: 0x0
            RX_OVER: u1,
            /// Set when the receive buffer reaches or goes above the RX_TL threshold in the
            /// IC_RX_TL register. It is automatically cleared by hardware when buffer level
            /// goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX
            /// FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this
            /// bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of
            /// the activity that continues.\n\n
            /// Reset value: 0x0
            RX_FULL: u1,
            /// Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and
            /// the processor attempts to issue another I2C command by writing to the
            /// IC_DATA_CMD register. When the module is disabled, this bit keeps its level
            /// until the master or slave state machines go into idle, and when ic_en goes to 0,
            /// this interrupt is cleared.\n\n
            /// Reset value: 0x0
            TX_OVER: u1,
            /// The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL
            /// selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1
            /// when the transmit buffer is at or below the threshold value set in the IC_TX_TL
            /// register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit
            /// buffer is at or below the threshold value set in the IC_TX_TL register and the
            /// transmission of the address/data from the internal shift register for the most
            /// recently popped command is completed. It is automatically cleared by hardware
            /// when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0,
            /// the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no
            /// data within it, so this bit is set to 1, provided there is activity in the
            /// master or slave state machines. When there is no longer any activity, then with
            /// ic_en=0, this bit is set to 0.\n\n
            /// Reset value: 0x0.
            TX_EMPTY: u1,
            /// This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master
            /// is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in
            /// a wait state (SCL=0) until this interrupt is serviced, which means that the
            /// slave has been addressed by a remote master that is asking for data to be
            /// transferred. The processor must respond to this interrupt and then write the
            /// requested data to the IC_DATA_CMD register. This bit is set to 0 just after the
            /// processor reads the IC_CLR_RD_REQ register.\n\n
            /// Reset value: 0x0
            RD_REQ: u1,
            /// This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete
            /// the intended actions on the contents of the transmit FIFO. This situation can
            /// occur both as an I2C master or an I2C slave, and is referred to as a 'transmit
            /// abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the
            /// reason why the transmit abort takes places.\n\n
            /// Note: The DW_apb_i2c flushes/resets/empties the TX_FIFO and RX_FIFO whenever
            /// there is a transmit abort caused by any of the events tracked by the
            /// IC_TX_ABRT_SOURCE register. The FIFOs remains in this flushed state until the
            /// register IC_CLR_TX_ABRT is read. Once this read is performed, the Tx FIFO is
            /// then ready to accept more data bytes from the APB interface.\n\n
            /// Reset value: 0x0
            TX_ABRT: u1,
            /// When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if
            /// the master does not acknowledge a transmitted byte. This occurs on the last byte
            /// of the transmission, indicating that the transmission is done.\n\n
            /// Reset value: 0x0
            RX_DONE: u1,
            /// This bit captures DW_apb_i2c activity and stays set until it is cleared. There
            /// are four ways to clear it: - Disabling the DW_apb_i2c - Reading the
            /// IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once
            /// this bit is set, it stays set unless one of the four methods is used to clear
            /// it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared,
            /// indicating that there was activity on the bus.\n\n
            /// Reset value: 0x0
            ACTIVITY: u1,
            /// Indicates whether a STOP condition has occurred on the I2C interface regardless
            /// of whether DW_apb_i2c is operating in slave or master mode.\n\n
            /// In Slave Mode: - If IC_CON[7]=1'b1 (STOP_DET_IFADDRESSED), the STOP_DET
            /// interrupt will be issued only if slave is addressed. Note: During a general call
            /// address, this slave does not issue a STOP_DET interrupt if
            /// STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to the general call
            /// address by generating ACK. The STOP_DET interrupt is generated only when the
            /// transmitted address matches the slave address (SAR). - If IC_CON[7]=1'b0
            /// (STOP_DET_IFADDRESSED), the STOP_DET interrupt is issued irrespective of whether
            /// it is being addressed. In Master Mode: - If IC_CON[10]=1'b1
            /// (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will be issued only if Master
            /// is active. - If IC_CON[10]=1'b0 (STOP_DET_IFADDRESSED),the STOP_DET interrupt
            /// will be issued irrespective of whether master is active or not. Reset value: 0x0
            STOP_DET: u1,
            /// Indicates whether a START or RESTART condition has occurred on the I2C interface
            /// regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n
            /// Reset value: 0x0
            START_DET: u1,
            /// Set only when a General Call address is received and it is acknowledged. It
            /// stays set until it is cleared either by disabling DW_apb_i2c or when the CPU
            /// reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data
            /// in the Rx buffer.\n\n
            /// Reset value: 0x0
            GEN_CALL: u1,
            /// Indicates whether a RESTART condition has occurred on the I2C interface when
            /// DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled
            /// only when IC_SLV_RESTART_DET_EN=1.\n\n
            /// Note: However, in high-speed mode or during a START BYTE transfer, the RESTART
            /// comes before the address field as per the I2C protocol. In this case, the slave
            /// is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does
            /// not generate the RESTART_DET interrupt.\n\n
            /// Reset value: 0x0
            RESTART_DET: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
        }), base_address + 0x34);

        /// address: 0x40044038
        /// I2C Receive FIFO Threshold Register
        pub const IC_RX_TL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive FIFO Threshold Level.\n\n
            /// Controls the level of entries (or above) that triggers the RX_FULL interrupt
            /// (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the
            /// additional restriction that hardware does not allow this value to be set to a
            /// value larger than the depth of the buffer. If an attempt is made to do that, the
            /// actual value set will be the maximum depth of the buffer. A value of 0 sets the
            /// threshold for 1 entry, and a value of 255 sets the threshold for 256 entries.
            RX_TL: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x38);

        /// address: 0x4004403c
        /// I2C Transmit FIFO Threshold Register
        pub const IC_TX_TL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO Threshold Level.\n\n
            /// Controls the level of entries (or below) that trigger the TX_EMPTY interrupt
            /// (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the
            /// additional restriction that it may not be set to value larger than the depth of
            /// the buffer. If an attempt is made to do that, the actual value set will be the
            /// maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and
            /// a value of 255 sets the threshold for 255 entries.
            TX_TL: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x3c);

        /// address: 0x40044040
        /// Clear Combined and Individual Interrupt Register
        pub const IC_CLR_INTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the combined interrupt, all individual interrupts,
            /// and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable
            /// interrupts but software clearable interrupts. Refer to Bit 9 of the
            /// IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n
            /// Reset value: 0x0
            CLR_INTR: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x40);

        /// address: 0x40044044
        /// Clear RX_UNDER Interrupt Register
        pub const IC_CLR_RX_UNDER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the RX_UNDER interrupt (bit 0) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_RX_UNDER: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x44);

        /// address: 0x40044048
        /// Clear RX_OVER Interrupt Register
        pub const IC_CLR_RX_OVER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the RX_OVER interrupt (bit 1) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_RX_OVER: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x48);

        /// address: 0x4004404c
        /// Clear TX_OVER Interrupt Register
        pub const IC_CLR_TX_OVER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the TX_OVER interrupt (bit 3) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_TX_OVER: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x4c);

        /// address: 0x40044050
        /// Clear RD_REQ Interrupt Register
        pub const IC_CLR_RD_REQ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT
            /// register.\n\n
            /// Reset value: 0x0
            CLR_RD_REQ: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x50);

        /// address: 0x40044054
        /// Clear TX_ABRT Interrupt Register
        pub const IC_CLR_TX_ABRT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the TX_ABRT interrupt (bit 6) of the
            /// IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also
            /// releases the TX FIFO from the flushed/reset state, allowing more writes to the
            /// TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to
            /// clearing IC_TX_ABRT_SOURCE.\n\n
            /// Reset value: 0x0
            CLR_TX_ABRT: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x54);

        /// address: 0x40044058
        /// Clear RX_DONE Interrupt Register
        pub const IC_CLR_RX_DONE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the RX_DONE interrupt (bit 7) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_RX_DONE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x58);

        /// address: 0x4004405c
        /// Clear ACTIVITY Interrupt Register
        pub const IC_CLR_ACTIVITY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reading this register clears the ACTIVITY interrupt if the I2C is not active
            /// anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt
            /// bit continues to be set. It is automatically cleared by hardware if the module
            /// is disabled and if there is no further activity on the bus. The value read from
            /// this register to get status of the ACTIVITY interrupt (bit 8) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_ACTIVITY: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x5c);

        /// address: 0x40044060
        /// Clear STOP_DET Interrupt Register
        pub const IC_CLR_STOP_DET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the STOP_DET interrupt (bit 9) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_STOP_DET: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x60);

        /// address: 0x40044064
        /// Clear START_DET Interrupt Register
        pub const IC_CLR_START_DET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the START_DET interrupt (bit 10) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_START_DET: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x64);

        /// address: 0x40044068
        /// Clear GEN_CALL Interrupt Register
        pub const IC_CLR_GEN_CALL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT
            /// register.\n\n
            /// Reset value: 0x0
            CLR_GEN_CALL: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x68);

        /// address: 0x4004406c
        /// I2C Enable Register
        pub const IC_ENABLE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX
            /// FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable
            /// DW_apb_i2c while it is active. However, it is important that care be taken to
            /// ensure that DW_apb_i2c is disabled properly. A recommended procedure is
            /// described in 'Disabling DW_apb_i2c'.\n\n
            /// When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get
            /// flushed. - Status bits in the IC_INTR_STAT register are still active until
            /// DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well
            /// as deletes the contents of the transmit buffer after the current transfer is
            /// complete. If the module is receiving, the DW_apb_i2c stops the current transfer
            /// at the end of the current byte and does not acknowledge the transfer.\n\n
            /// In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to
            /// asynchronous (1), there is a two ic_clk delay when enabling or disabling the
            /// DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to
            /// 'Disabling DW_apb_i2c'\n\n
            /// Reset value: 0x0
            ENABLE: u1,
            /// When set, the controller initiates the transfer abort. - 0: ABORT not initiated
            /// or ABORT done - 1: ABORT operation in progress The software can abort the I2C
            /// transfer in master mode by setting this bit. The software can set this bit only
            /// when ENABLE is already set; otherwise, the controller ignores any write to ABORT
            /// bit. The software cannot clear the ABORT bit once set. In response to an ABORT,
            /// the controller issues a STOP and flushes the Tx FIFO after completing the
            /// current transfer, then sets the TX_ABORT interrupt after the abort operation.
            /// The ABORT bit is cleared automatically after the abort operation.\n\n
            /// For a detailed description on how to abort I2C transfers, refer to 'Aborting I2C
            /// Transfers'.\n\n
            /// Reset value: 0x0
            ABORT: u1,
            /// In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx
            /// FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus
            /// automatically, as soon as the first data is available in the Tx FIFO. Note: To
            /// block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx
            /// FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0).
            /// Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit
            /// is unset. Reset value: IC_TX_CMD_BLOCK_DEFAULT
            TX_CMD_BLOCK: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
        }), base_address + 0x6c);

        /// address: 0x40044070
        /// I2C Status Register\n\n
        /// This is a read-only register used to indicate the current transfer status and
        /// FIFO status. The status register may be read at any time. None of the bits in
        /// this register request an interrupt.\n\n
        /// When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits
        /// 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state
        /// machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0
        pub const IC_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2C Activity Status. Reset value: 0x0
            ACTIVITY: u1,
            /// Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty
            /// locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1:
            /// Transmit FIFO is not full Reset value: 0x1
            TFNF: u1,
            /// Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this
            /// bit is set. When it contains one or more valid entries, this bit is cleared.
            /// This bit field does not request an interrupt. - 0: Transmit FIFO is not empty -
            /// 1: Transmit FIFO is empty Reset value: 0x1
            TFE: u1,
            /// Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or
            /// more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is
            /// empty - 1: Receive FIFO is not empty Reset value: 0x0
            RFNE: u1,
            /// Receive FIFO Completely Full. When the receive FIFO is completely full, this bit
            /// is set. When the receive FIFO contains one or more empty location, this bit is
            /// cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value:
            /// 0x0
            RFF: u1,
            /// Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in
            /// the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master
            /// part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the
            /// Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is
            /// the OR of SLV_ACTIVITY and MST_ACTIVITY bits.\n\n
            /// Reset value: 0x0
            MST_ACTIVITY: u1,
            /// Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in
            /// the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave
            /// part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the
            /// Slave part of DW_apb_i2c is Active Reset value: 0x0
            SLV_ACTIVITY: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
        }), base_address + 0x70);

        /// address: 0x40044074
        /// I2C Transmit FIFO Level Register This register contains the number of valid data
        /// entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is
        /// disabled - There is a transmit abort - that is, TX_ABRT bit is set in the
        /// IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register
        /// increments whenever data is placed into the transmit FIFO and decrements when
        /// data is taken from the transmit FIFO.
        pub const IC_TXFLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO Level. Contains the number of valid data entries in the transmit
            /// FIFO.\n\n
            /// Reset value: 0x0
            TXFLR: u5,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
        }), base_address + 0x74);

        /// address: 0x40044078
        /// I2C Receive FIFO Level Register This register contains the number of valid data
        /// entries in the receive FIFO buffer. It is cleared whenever: - The I2C is
        /// disabled - Whenever there is a transmit abort caused by any of the events
        /// tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed
        /// into the receive FIFO and decrements when data is taken from the receive FIFO.
        pub const IC_RXFLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive FIFO Level. Contains the number of valid data entries in the receive
            /// FIFO.\n\n
            /// Reset value: 0x0
            RXFLR: u5,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
        }), base_address + 0x78);

        /// address: 0x4004407c
        /// I2C SDA Hold Time Length Register\n\n
        /// The bits [15:0] of this register are used to control the hold time of SDA during
        /// transmit in both slave and master mode (after SCL goes from HIGH to LOW).\n\n
        /// The bits [23:16] of this register are used to extend the SDA transition (if any)
        /// whenever SCL is HIGH in the receiver in either master or slave mode.\n\n
        /// Writes to this register succeed only when IC_ENABLE[0]=0.\n\n
        /// The values in this register are in units of ic_clk period. The value programmed
        /// in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one
        /// cycle in master mode, seven cycles in slave mode) for the value to be
        /// implemented.\n\n
        /// The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at
        /// any time the duration of the low part of scl. Therefore the programmed value
        /// cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low
        /// part of the scl period measured in ic_clk cycles.
        pub const IC_SDA_HOLD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts
            /// as a transmitter.\n\n
            /// Reset value: IC_DEFAULT_SDA_HOLD[15:0].
            IC_SDA_TX_HOLD: u16,
            /// Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts
            /// as a receiver.\n\n
            /// Reset value: IC_DEFAULT_SDA_HOLD[23:16].
            IC_SDA_RX_HOLD: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x7c);

        /// address: 0x40044080
        /// I2C Transmit Abort Source Register\n\n
        /// This register has 32 bits that indicate the source of the TX_ABRT bit. Except
        /// for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the
        /// IC_CLR_INTR register is read. To clear Bit 9, the source of the
        /// ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1),
        /// the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be
        /// cleared (IC_TAR[10]).\n\n
        /// Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared
        /// in the same manner as other bits in this register. If the source of the
        /// ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9
        /// clears for one cycle and is then re-asserted.
        pub const IC_TX_ABRT_SOURCE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This field indicates that the Master is in 7-bit addressing mode and the address
            /// sent was not acknowledged by any slave.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            ABRT_7B_ADDR_NOACK: u1,
            /// This field indicates that the Master is in 10-bit address mode and the first
            /// 10-bit address byte was not acknowledged by any slave.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            ABRT_10ADDR1_NOACK: u1,
            /// This field indicates that the Master is in 10-bit address mode and that the
            /// second address byte of the 10-bit address was not acknowledged by any slave.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            ABRT_10ADDR2_NOACK: u1,
            /// This field indicates the master-mode only bit. When the master receives an
            /// acknowledgement for the address, but when it sends data byte(s) following the
            /// address, it did not receive an acknowledge from the remote slave(s).\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter
            ABRT_TXDATA_NOACK: u1,
            /// This field indicates that DW_apb_i2c in master mode has sent a General Call and
            /// no slave on the bus acknowledged the General Call.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter
            ABRT_GCALL_NOACK: u1,
            /// This field indicates that DW_apb_i2c in the master mode has sent a General Call
            /// but the user programmed the byte following the General Call to be a read from
            /// the bus (IC_DATA_CMD[9] is set to 1).\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter
            ABRT_GCALL_READ: u1,
            /// This field indicates that the Master is in High Speed mode and the High Speed
            /// Master code was acknowledged (wrong behavior).\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master
            ABRT_HS_ACKDET: u1,
            /// This field indicates that the Master has sent a START Byte and the START Byte
            /// was acknowledged (wrong behavior).\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master
            ABRT_SBYTE_ACKDET: u1,
            /// This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5])
            /// =0) and the user is trying to use the master to transfer data in High Speed
            /// mode.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            ABRT_HS_NORSTRT: u1,
            /// To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first;
            /// restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared
            /// (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the
            /// source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the
            /// same manner as other bits in this register. If the source of the
            /// ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9
            /// clears for one cycle and then gets reasserted. When this field is set to 1, the
            /// restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to
            /// send a START Byte.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master
            ABRT_SBYTE_NORSTRT: u1,
            /// This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5])
            /// =0) and the master sends a read command in 10-bit addressing mode.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Receiver
            ABRT_10B_RD_NORSTRT: u1,
            /// This field indicates that the User tries to initiate a Master operation with the
            /// Master mode disabled.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            ABRT_MASTER_DIS: u1,
            /// This field specifies that the Master has lost arbitration, or if
            /// IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost
            /// arbitration.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
            ARB_LOST: u1,
            /// This field specifies that the Slave has received a read command and some data
            /// exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data
            /// in TX FIFO.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Slave-Transmitter
            ABRT_SLVFLUSH_TXFIFO: u1,
            /// This field indicates that a Slave has lost the bus while transmitting data to a
            /// remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though
            /// the slave never 'owns' the bus, something could go wrong on the bus. This is a
            /// fail safe check. For instance, during a data transmission at the low-to-high
            /// transition of SCL, if what is on the data bus is not what is supposed to be
            /// transmitted, then DW_apb_i2c no longer own the bus.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Slave-Transmitter
            ABRT_SLV_ARBLOST: u1,
            /// 1: When the processor side responds to a slave mode request for data to be
            /// transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD
            /// register.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Slave-Transmitter
            ABRT_SLVRD_INTX: u1,
            /// This is a master-mode-only bit. Master has detected the transfer abort
            /// (IC_ENABLE[1])\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter
            ABRT_USER_ABRT: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            /// This field indicates the number of Tx FIFO Data Commands which are flushed due
            /// to TX_ABRT interrupt. It is cleared whenever I2C is disabled.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
            TX_FLUSH_CNT: u9,
        }), base_address + 0x80);

        /// address: 0x40044084
        /// Generate Slave Data NACK Register\n\n
        /// The register is used to generate a NACK for the data part of a transfer when
        /// DW_apb_i2c is acting as a slave-receiver. This register only exists when the
        /// IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this
        /// register does not exist and writing to the register's address has no effect.\n\n
        /// A write can occur on this register if both of the following conditions are met:
        /// - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive
        /// (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for
        /// the internal slv_activity signal; the user should poll this before writing the
        /// ic_slv_data_nack_only bit.
        pub const IC_SLV_DATA_NACK_ONLY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Generate NACK. This NACK generation only occurs when DW_apb_i2c is a
            /// slave-receiver. If this register is set to a value of 1, it can only generate a
            /// NACK after a data byte is received; hence, the data transfer is aborted and the
            /// data received is not pushed to the receive buffer.\n\n
            /// When the register is set to a value of 0, it generates NACK/ACK, depending on
            /// normal criteria. - 1: generate NACK after data byte received - 0: generate
            /// NACK/ACK normally Reset value: 0x0
            NACK: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x84);

        /// address: 0x40044088
        /// DMA Control Register\n\n
        /// The register is used to enable the DMA Controller interface operation. There is
        /// a separate bit for transmit and receive. This can be programmed regardless of
        /// the state of IC_ENABLE.
        pub const IC_DMA_CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.
            /// Reset value: 0x0
            RDMAE: u1,
            /// Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel.
            /// Reset value: 0x0
            TDMAE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
        }), base_address + 0x88);

        /// address: 0x4004408c
        /// DMA Transmit Data Level Register
        pub const IC_DMA_TDLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Data Level. This bit field controls the level at which a DMA request is
            /// made by the transmit logic. It is equal to the watermark level; that is, the
            /// dma_tx_req signal is generated when the number of valid data entries in the
            /// transmit FIFO is equal to or below this field value, and TDMAE = 1.\n\n
            /// Reset value: 0x0
            DMATDL: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x8c);

        /// address: 0x40044090
        /// I2C Receive Data Level Register
        pub const IC_DMA_RDLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Data Level. This bit field controls the level at which a DMA request is
            /// made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req
            /// is generated when the number of valid data entries in the receive FIFO is equal
            /// to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is
            /// 0, then dma_rx_req is asserted when 1 or more data entries are present in the
            /// receive FIFO.\n\n
            /// Reset value: 0x0
            DMARDL: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x90);

        /// address: 0x40044094
        /// I2C SDA Setup Register\n\n
        /// This register controls the amount of time delay (in terms of number of ic_clk
        /// clock periods) introduced in the rising edge of SCL - relative to SDA changing -
        /// when DW_apb_i2c services a read request in a slave-transmitter operation. The
        /// relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus
        /// Specification. This register must be programmed with a value equal to or greater
        /// than 2.\n\n
        /// Writes to this register succeed only when IC_ENABLE[0] = 0.\n\n
        /// Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) *
        /// (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they
        /// should program a value of 11. The IC_SDA_SETUP register is only used by the
        /// DW_apb_i2c when operating as a slave transmitter.
        pub const IC_SDA_SETUP = @intToPtr(*volatile Mmio(32, packed struct {
            /// SDA Setup. It is recommended that if the required delay is 1000ns, then for an
            /// ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.
            /// IC_SDA_SETUP must be programmed with a minimum value of 2.
            SDA_SETUP: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x94);

        /// address: 0x40044098
        /// I2C ACK General Call Register\n\n
        /// The register controls whether DW_apb_i2c responds with a ACK or NACK when it
        /// receives an I2C General Call address.\n\n
        /// This register is applicable only when the DW_apb_i2c is in slave mode.
        pub const IC_ACK_GENERAL_CALL = @intToPtr(*volatile Mmio(32, packed struct {
            /// ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting
            /// ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with
            /// a NACK (by negating ic_data_oe).
            ACK_GEN_CALL: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x98);

        /// address: 0x4004409c
        /// I2C Enable Status Register\n\n
        /// The register is used to report the DW_apb_i2c hardware status when the
        /// IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is
        /// disabled.\n\n
        /// If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced
        /// to 1.\n\n
        /// If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is
        /// read as '0'.\n\n
        /// Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read
        /// as 0 because disabling the DW_apb_i2c depends on I2C bus activities.
        pub const IC_ENABLE_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// ic_en Status. This bit always reflects the value driven on the output port
            /// ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When
            /// read as 0, DW_apb_i2c is deemed completely inactive. Note: The CPU can safely
            /// read this bit anytime. When this bit is read as 0, the CPU can safely read
            /// SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).\n\n
            /// Reset value: 0x0
            IC_EN: u1,
            /// Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential
            /// or active Slave operation has been aborted due to the setting bit 0 of the
            /// IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the
            /// IC_ENABLE register while:\n\n
            /// (a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter operation
            /// from a remote master;\n\n
            /// OR,\n\n
            /// (b) address and data bytes of the Slave-Receiver operation from a remote
            /// master.\n\n
            /// When read as 1, DW_apb_i2c is deemed to have forced a NACK during any part of an
            /// I2C transfer, irrespective of whether the I2C address matches the slave address
            /// set in DW_apb_i2c (IC_SAR register) OR if the transfer is completed before
            /// IC_ENABLE is set to 0 but has not taken effect.\n\n
            /// Note: If the remote I2C master terminates the transfer with a STOP condition
            /// before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been
            /// set to 0, then this bit will also be set to 1.\n\n
            /// When read as 0, DW_apb_i2c is deemed to have been disabled when there is master
            /// activity, or when the I2C bus is idle.\n\n
            /// Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n
            /// Reset value: 0x0
            SLV_DISABLED_WHILE_BUSY: u1,
            /// Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has
            /// been aborted with at least one data byte received from an I2C transfer due to
            /// the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed
            /// to have been actively engaged in an aborted I2C transfer (with matching address)
            /// and the data phase of the I2C transfer has been entered, even though a data byte
            /// has been responded with a NACK.\n\n
            /// Note: If the remote I2C master terminates the transfer with a STOP condition
            /// before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been
            /// set to 0, then this bit is also set to 1.\n\n
            /// When read as 0, DW_apb_i2c is deemed to have been disabled without being
            /// actively involved in the data phase of a Slave-Receiver transfer.\n\n
            /// Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n
            /// Reset value: 0x0
            SLV_RX_DATA_LOST: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
        }), base_address + 0x9c);

        /// address: 0x400440a0
        /// I2C SS, FS or FM+ spike suppression limit\n\n
        /// This register is used to store the duration, measured in ic_clk cycles, of the
        /// longest spike that is filtered out by the spike suppression logic when the
        /// component is operating in SS, FS or FM+ modes. The relevant I2C requirement is
        /// tSP (table 4) as detailed in the I2C Bus Specification. This register must be
        /// programmed with a minimum value of 1.
        pub const IC_FS_SPKLEN = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xa0);

        /// address: 0x400440a8
        /// Clear RESTART_DET Interrupt Register
        pub const IC_CLR_RESTART_DET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the RESTART_DET interrupt (bit 12) of
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_RESTART_DET: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0xa8);

        /// address: 0x400440f4
        /// Component Parameter Register 1\n\n
        /// Note This register is not implemented and therefore reads as 0. If it was
        /// implemented it would be a constant read-only register that contains encoded
        /// information about the component's parameter settings. Fields shown below are the
        /// settings for those parameters
        pub const IC_COMP_PARAM_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// APB data bus width is 32 bits
            APB_DATA_WIDTH: u2,
            /// MAX SPEED MODE = FAST MODE
            MAX_SPEED_MODE: u2,
            /// Programmable count values for each mode.
            HC_COUNT_VALUES: u1,
            /// COMBINED Interrupt outputs
            INTR_IO: u1,
            /// DMA handshaking signals are enabled
            HAS_DMA: u1,
            /// Encoded parameters not visible
            ADD_ENCODED_PARAMS: u1,
            /// RX Buffer Depth = 16
            RX_BUFFER_DEPTH: u8,
            /// TX Buffer Depth = 16
            TX_BUFFER_DEPTH: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0xf4);

        /// address: 0x400440f8
        /// I2C Component Version Register
        pub const IC_COMP_VERSION = @intToPtr(*volatile u32, base_address + 0xf8);

        /// address: 0x400440fc
        /// I2C Component Type Register
        pub const IC_COMP_TYPE = @intToPtr(*volatile u32, base_address + 0xfc);
    };
    pub const I2C1 = struct {
        pub const base_address = 0x40048000;

        /// address: 0x40048000
        /// I2C Control Register. This register can be written only when the DW_apb_i2c is
        /// disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes
        /// at other times have no effect.\n\n
        /// Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read
        /// only - bit 17 is read only - bits 18 and 19 are read only.
        pub const IC_CON = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit controls whether the DW_apb_i2c master is enabled.\n\n
            /// NOTE: Software should ensure that if this bit is written with '1' then bit 6
            /// should also be written with a '1'.
            MASTER_MODE: u1,
            /// These bits control at which speed the DW_apb_i2c operates; its setting is
            /// relevant only if one is operating the DW_apb_i2c in master mode. Hardware
            /// protects against illegal values being programmed by software. These bits must be
            /// programmed appropriately for slave mode also, as it is used to capture correct
            /// value of spike filter as per the speed mode.\n\n
            /// This register should be programmed only with a value in the range of 1 to
            /// IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of
            /// IC_MAX_SPEED_MODE.\n\n
            /// 1: standard mode (100 kbit/s)\n\n
            /// 2: fast mode (<=400 kbit/s) or fast mode plus (<=1000Kbit/s)\n\n
            /// 3: high speed mode (3.4 Mbit/s)\n\n
            /// Note: This field is not applicable when IC_ULTRA_FAST_MODE=1
            SPEED: u2,
            /// When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7-
            /// or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions
            /// that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of
            /// the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c
            /// responds to only 10-bit addressing transfers that match the full 10 bits of the
            /// IC_SAR register.
            IC_10BITADDR_SLAVE: u1,
            /// Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing
            /// mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing
            IC_10BITADDR_MASTER: u1,
            /// Determines whether RESTART conditions may be sent when acting as a master. Some
            /// older slaves do not support handling RESTART conditions; however, RESTART
            /// conditions are used in several DW_apb_i2c operations. When RESTART is disabled,
            /// the master is prohibited from performing the following functions: - Sending a
            /// START BYTE - Performing any high-speed mode operation - High-speed mode
            /// operation - Performing direction changes in combined format mode - Performing a
            /// read operation with a 10-bit address By replacing RESTART condition followed by
            /// a STOP and a subsequent START condition, split operations are broken down into
            /// multiple DW_apb_i2c transfers. If the above operations are performed, it will
            /// result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.\n\n
            /// Reset value: ENABLED
            IC_RESTART_EN: u1,
            /// This bit controls whether I2C has its slave disabled, which means once the
            /// presetn signal is applied, then this bit is set and the slave is disabled.\n\n
            /// If this bit is set (slave is disabled), DW_apb_i2c functions only as a master
            /// and does not perform any action that requires a slave.\n\n
            /// NOTE: Software should ensure that if this bit is written with 0, then bit 0
            /// should also be written with a 0.
            IC_SLAVE_DISABLE: u1,
            /// In slave mode: - 1'b1: issues the STOP_DET interrupt only when it is addressed.
            /// - 1'b0: issues the STOP_DET irrespective of whether it's addressed or not. Reset
            /// value: 0x0\n\n
            /// NOTE: During a general call address, this slave does not issue the STOP_DET
            /// interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the
            /// general call address by generating ACK. The STOP_DET interrupt is generated only
            /// when the transmitted address matches the slave address (SAR).
            STOP_DET_IFADDRESSED: u1,
            /// This bit controls the generation of the TX_EMPTY interrupt, as described in the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0.
            TX_EMPTY_CTRL: u1,
            /// This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is
            /// physically full to its RX_BUFFER_DEPTH, as described in the
            /// IC_RX_FULL_HLD_BUS_EN parameter.\n\n
            /// Reset value: 0x0.
            RX_FIFO_FULL_HLD_CTRL: u1,
            /// Master issues the STOP_DET interrupt irrespective of whether master is active or
            /// not
            STOP_DET_IF_MASTER_ACTIVE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40048004
        /// I2C Target Address Register\n\n
        /// This register is 12 bits wide, and bits 31:12 are reserved. This register can be
        /// written to only when IC_ENABLE[0] is set to 0.\n\n
        /// Note: If the software or application is aware that the DW_apb_i2c is not using
        /// the TAR address for the pending commands in the Tx FIFO, then it is possible to
        /// update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). -
        /// It is not necessary to perform any write to this register if DW_apb_i2c is
        /// enabled as an I2C slave only.
        pub const IC_TAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// This is the target address for any master transaction. When transmitting a
            /// General Call, these bits are ignored. To generate a START BYTE, the CPU needs to
            /// write only once into these bits.\n\n
            /// If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared
            /// between master and slave, so full loopback is not feasible. Only one direction
            /// loopback mode is supported (simplex), not duplex. A master cannot transmit to
            /// itself; it can transmit to only a slave.
            IC_TAR: u10,
            /// If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit
            /// indicates whether a General Call or START byte command is to be performed by the
            /// DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only
            /// writes may be performed. Attempting to issue a read command results in setting
            /// bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in
            /// General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START
            /// BYTE Reset value: 0x0
            GC_OR_START: u1,
            /// This bit indicates whether software performs a Device-ID or General Call or
            /// START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1:
            /// perform special I2C command as specified in Device_ID or GC_OR_START bit Reset
            /// value: 0x0
            SPECIAL: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40048008
        /// I2C Slave Address Register
        pub const IC_SAR = @intToPtr(*volatile MmioInt(32, u10), base_address + 0x8);

        /// address: 0x40048010
        /// I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes
        /// to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX
        /// FIFO.\n\n
        /// The size of the register changes as follows:\n\n
        /// Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when
        /// IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1
        /// - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to
        /// continue acknowledging reads, a read command should be written for every byte
        /// that is to be received; otherwise the DW_apb_i2c will stop acknowledging.
        pub const IC_DATA_CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register contains the data to be transmitted or received on the I2C bus. If
            /// you are writing to this register and want to perform a read, bits 7:0 (DAT) are
            /// ignored by the DW_apb_i2c. However, when you read this register, these bits
            /// return the value of data received on the DW_apb_i2c interface.\n\n
            /// Reset value: 0x0
            DAT: u8,
            /// This bit controls whether a read or a write is performed. This bit does not
            /// control the direction when the DW_apb_i2con acts as a slave. It controls only
            /// the direction when it acts as a master.\n\n
            /// When a command is entered in the TX FIFO, this bit distinguishes the write and
            /// read commands. In slave-receiver mode, this bit is a 'don't care' because writes
            /// to this register are not required. In slave-transmitter mode, a '0' indicates
            /// that the data in IC_DATA_CMD is to be transmitted.\n\n
            /// When programming this bit, you should remember the following: attempting to
            /// perform a read operation after a General Call command has been sent results in a
            /// TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11
            /// (SPECIAL) in the IC_TAR register has been cleared. If a '1' is written to this
            /// bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n
            /// Reset value: 0x0
            CMD: u1,
            /// This bit controls whether a STOP is issued after the byte is sent or
            /// received.\n\n
            /// - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO
            /// is empty. If the Tx FIFO is not empty, the master immediately tries to start a
            /// new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not
            /// issued after this byte, regardless of whether or not the Tx FIFO is empty. If
            /// the Tx FIFO is not empty, the master continues the current transfer by
            /// sending/receiving data bytes according to the value of the CMD bit. If the Tx
            /// FIFO is empty, the master holds the SCL line low and stalls the bus until a new
            /// command is available in the Tx FIFO. Reset value: 0x0
            STOP: u1,
            /// This bit controls whether a RESTART is issued before the byte is sent or
            /// received.\n\n
            /// 1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received
            /// (according to the value of CMD), regardless of whether or not the transfer
            /// direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP
            /// followed by a START is issued instead.\n\n
            /// 0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is
            /// changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a
            /// START is issued instead.\n\n
            /// Reset value: 0x0
            RESTART: u1,
            /// Indicates the first data byte received after the address phase for receive
            /// transfer in Master receiver or Slave receiver mode.\n\n
            /// Reset value : 0x0\n\n
            /// NOTE: In case of APB_DATA_WIDTH=8,\n\n
            /// 1. The user has to perform two APB Reads to IC_DATA_CMD in order to get status
            /// on 11 bit.\n\n
            /// 2. In order to read the 11 bit, the user has to perform the first data byte read
            /// [7:0] (offset 0x10) and then perform the second read [15:8] (offset 0x11) in
            /// order to know the status of 11 bit (whether the data received in previous read
            /// is a first data byte or not).\n\n
            /// 3. The 11th bit is an optional read field, user can ignore 2nd byte read [15:8]
            /// (offset 0x11) if not interested in FIRST_DATA_BYTE status.
            FIRST_DATA_BYTE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x10);

        /// address: 0x40048014
        /// Standard Speed I2C Clock SCL High Count Register
        pub const IC_SS_SCL_HCNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x14);

        /// address: 0x40048018
        /// Standard Speed I2C Clock SCL Low Count Register
        pub const IC_SS_SCL_LCNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x18);

        /// address: 0x4004801c
        /// Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
        pub const IC_FS_SCL_HCNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x1c);

        /// address: 0x40048020
        /// Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
        pub const IC_FS_SCL_LCNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x20);

        /// address: 0x4004802c
        /// I2C Interrupt Status Register\n\n
        /// Each bit in this register has a corresponding mask bit in the IC_INTR_MASK
        /// register. These bits are cleared by reading the matching interrupt clear
        /// register. The unmasked raw versions of these bits are available in the
        /// IC_RAW_INTR_STAT register.
        pub const IC_INTR_STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.\n\n
            /// Reset value: 0x0
            R_RX_UNDER: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.\n\n
            /// Reset value: 0x0
            R_RX_OVER: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.\n\n
            /// Reset value: 0x0
            R_RX_FULL: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.\n\n
            /// Reset value: 0x0
            R_TX_OVER: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.\n\n
            /// Reset value: 0x0
            R_TX_EMPTY: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.\n\n
            /// Reset value: 0x0
            R_RD_REQ: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.\n\n
            /// Reset value: 0x0
            R_TX_ABRT: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.\n\n
            /// Reset value: 0x0
            R_RX_DONE: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.\n\n
            /// Reset value: 0x0
            R_ACTIVITY: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.\n\n
            /// Reset value: 0x0
            R_STOP_DET: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.\n\n
            /// Reset value: 0x0
            R_START_DET: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.\n\n
            /// Reset value: 0x0
            R_GEN_CALL: u1,
            /// See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit.\n\n
            /// Reset value: 0x0
            R_RESTART_DET: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
        }), base_address + 0x2c);

        /// address: 0x40048030
        /// I2C Interrupt Mask Register.\n\n
        /// These bits mask their corresponding interrupt status bits. This register is
        /// active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the
        /// interrupt.
        pub const IC_INTR_MASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_RX_UNDER: u1,
            /// This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_RX_OVER: u1,
            /// This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_RX_FULL: u1,
            /// This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_TX_OVER: u1,
            /// This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_TX_EMPTY: u1,
            /// This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_RD_REQ: u1,
            /// This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_TX_ABRT: u1,
            /// This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_RX_DONE: u1,
            /// This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x0
            M_ACTIVITY: u1,
            /// This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x0
            M_STOP_DET: u1,
            /// This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x0
            M_START_DET: u1,
            /// This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x1
            M_GEN_CALL: u1,
            /// This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n
            /// Reset value: 0x0
            M_RESTART_DET: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
        }), base_address + 0x30);

        /// address: 0x40048034
        /// I2C Raw Interrupt Status Register\n\n
        /// Unlike the IC_INTR_STAT register, these bits are not masked so they always show
        /// the true status of the DW_apb_i2c.
        pub const IC_RAW_INTR_STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set if the processor attempts to read the receive buffer when it is empty by
            /// reading from the IC_DATA_CMD register. If the module is disabled
            /// (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state
            /// machines go into idle, and when ic_en goes to 0, this interrupt is cleared.\n\n
            /// Reset value: 0x0
            RX_UNDER: u1,
            /// Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an
            /// additional byte is received from an external I2C device. The DW_apb_i2c
            /// acknowledges this, but any data bytes received after the FIFO is full are lost.
            /// If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the
            /// master or slave state machines go into idle, and when ic_en goes to 0, this
            /// interrupt is cleared.\n\n
            /// Note: If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to
            /// HIGH, then the RX_OVER interrupt never occurs, because the Rx FIFO never
            /// overflows.\n\n
            /// Reset value: 0x0
            RX_OVER: u1,
            /// Set when the receive buffer reaches or goes above the RX_TL threshold in the
            /// IC_RX_TL register. It is automatically cleared by hardware when buffer level
            /// goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX
            /// FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this
            /// bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of
            /// the activity that continues.\n\n
            /// Reset value: 0x0
            RX_FULL: u1,
            /// Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and
            /// the processor attempts to issue another I2C command by writing to the
            /// IC_DATA_CMD register. When the module is disabled, this bit keeps its level
            /// until the master or slave state machines go into idle, and when ic_en goes to 0,
            /// this interrupt is cleared.\n\n
            /// Reset value: 0x0
            TX_OVER: u1,
            /// The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL
            /// selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1
            /// when the transmit buffer is at or below the threshold value set in the IC_TX_TL
            /// register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit
            /// buffer is at or below the threshold value set in the IC_TX_TL register and the
            /// transmission of the address/data from the internal shift register for the most
            /// recently popped command is completed. It is automatically cleared by hardware
            /// when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0,
            /// the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no
            /// data within it, so this bit is set to 1, provided there is activity in the
            /// master or slave state machines. When there is no longer any activity, then with
            /// ic_en=0, this bit is set to 0.\n\n
            /// Reset value: 0x0.
            TX_EMPTY: u1,
            /// This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master
            /// is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in
            /// a wait state (SCL=0) until this interrupt is serviced, which means that the
            /// slave has been addressed by a remote master that is asking for data to be
            /// transferred. The processor must respond to this interrupt and then write the
            /// requested data to the IC_DATA_CMD register. This bit is set to 0 just after the
            /// processor reads the IC_CLR_RD_REQ register.\n\n
            /// Reset value: 0x0
            RD_REQ: u1,
            /// This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete
            /// the intended actions on the contents of the transmit FIFO. This situation can
            /// occur both as an I2C master or an I2C slave, and is referred to as a 'transmit
            /// abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the
            /// reason why the transmit abort takes places.\n\n
            /// Note: The DW_apb_i2c flushes/resets/empties the TX_FIFO and RX_FIFO whenever
            /// there is a transmit abort caused by any of the events tracked by the
            /// IC_TX_ABRT_SOURCE register. The FIFOs remains in this flushed state until the
            /// register IC_CLR_TX_ABRT is read. Once this read is performed, the Tx FIFO is
            /// then ready to accept more data bytes from the APB interface.\n\n
            /// Reset value: 0x0
            TX_ABRT: u1,
            /// When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if
            /// the master does not acknowledge a transmitted byte. This occurs on the last byte
            /// of the transmission, indicating that the transmission is done.\n\n
            /// Reset value: 0x0
            RX_DONE: u1,
            /// This bit captures DW_apb_i2c activity and stays set until it is cleared. There
            /// are four ways to clear it: - Disabling the DW_apb_i2c - Reading the
            /// IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once
            /// this bit is set, it stays set unless one of the four methods is used to clear
            /// it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared,
            /// indicating that there was activity on the bus.\n\n
            /// Reset value: 0x0
            ACTIVITY: u1,
            /// Indicates whether a STOP condition has occurred on the I2C interface regardless
            /// of whether DW_apb_i2c is operating in slave or master mode.\n\n
            /// In Slave Mode: - If IC_CON[7]=1'b1 (STOP_DET_IFADDRESSED), the STOP_DET
            /// interrupt will be issued only if slave is addressed. Note: During a general call
            /// address, this slave does not issue a STOP_DET interrupt if
            /// STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to the general call
            /// address by generating ACK. The STOP_DET interrupt is generated only when the
            /// transmitted address matches the slave address (SAR). - If IC_CON[7]=1'b0
            /// (STOP_DET_IFADDRESSED), the STOP_DET interrupt is issued irrespective of whether
            /// it is being addressed. In Master Mode: - If IC_CON[10]=1'b1
            /// (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will be issued only if Master
            /// is active. - If IC_CON[10]=1'b0 (STOP_DET_IFADDRESSED),the STOP_DET interrupt
            /// will be issued irrespective of whether master is active or not. Reset value: 0x0
            STOP_DET: u1,
            /// Indicates whether a START or RESTART condition has occurred on the I2C interface
            /// regardless of whether DW_apb_i2c is operating in slave or master mode.\n\n
            /// Reset value: 0x0
            START_DET: u1,
            /// Set only when a General Call address is received and it is acknowledged. It
            /// stays set until it is cleared either by disabling DW_apb_i2c or when the CPU
            /// reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data
            /// in the Rx buffer.\n\n
            /// Reset value: 0x0
            GEN_CALL: u1,
            /// Indicates whether a RESTART condition has occurred on the I2C interface when
            /// DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled
            /// only when IC_SLV_RESTART_DET_EN=1.\n\n
            /// Note: However, in high-speed mode or during a START BYTE transfer, the RESTART
            /// comes before the address field as per the I2C protocol. In this case, the slave
            /// is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does
            /// not generate the RESTART_DET interrupt.\n\n
            /// Reset value: 0x0
            RESTART_DET: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
        }), base_address + 0x34);

        /// address: 0x40048038
        /// I2C Receive FIFO Threshold Register
        pub const IC_RX_TL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive FIFO Threshold Level.\n\n
            /// Controls the level of entries (or above) that triggers the RX_FULL interrupt
            /// (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the
            /// additional restriction that hardware does not allow this value to be set to a
            /// value larger than the depth of the buffer. If an attempt is made to do that, the
            /// actual value set will be the maximum depth of the buffer. A value of 0 sets the
            /// threshold for 1 entry, and a value of 255 sets the threshold for 256 entries.
            RX_TL: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x38);

        /// address: 0x4004803c
        /// I2C Transmit FIFO Threshold Register
        pub const IC_TX_TL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO Threshold Level.\n\n
            /// Controls the level of entries (or below) that trigger the TX_EMPTY interrupt
            /// (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the
            /// additional restriction that it may not be set to value larger than the depth of
            /// the buffer. If an attempt is made to do that, the actual value set will be the
            /// maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and
            /// a value of 255 sets the threshold for 255 entries.
            TX_TL: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x3c);

        /// address: 0x40048040
        /// Clear Combined and Individual Interrupt Register
        pub const IC_CLR_INTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the combined interrupt, all individual interrupts,
            /// and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable
            /// interrupts but software clearable interrupts. Refer to Bit 9 of the
            /// IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE.\n\n
            /// Reset value: 0x0
            CLR_INTR: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x40);

        /// address: 0x40048044
        /// Clear RX_UNDER Interrupt Register
        pub const IC_CLR_RX_UNDER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the RX_UNDER interrupt (bit 0) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_RX_UNDER: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x44);

        /// address: 0x40048048
        /// Clear RX_OVER Interrupt Register
        pub const IC_CLR_RX_OVER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the RX_OVER interrupt (bit 1) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_RX_OVER: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x48);

        /// address: 0x4004804c
        /// Clear TX_OVER Interrupt Register
        pub const IC_CLR_TX_OVER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the TX_OVER interrupt (bit 3) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_TX_OVER: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x4c);

        /// address: 0x40048050
        /// Clear RD_REQ Interrupt Register
        pub const IC_CLR_RD_REQ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT
            /// register.\n\n
            /// Reset value: 0x0
            CLR_RD_REQ: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x50);

        /// address: 0x40048054
        /// Clear TX_ABRT Interrupt Register
        pub const IC_CLR_TX_ABRT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the TX_ABRT interrupt (bit 6) of the
            /// IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also
            /// releases the TX FIFO from the flushed/reset state, allowing more writes to the
            /// TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to
            /// clearing IC_TX_ABRT_SOURCE.\n\n
            /// Reset value: 0x0
            CLR_TX_ABRT: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x54);

        /// address: 0x40048058
        /// Clear RX_DONE Interrupt Register
        pub const IC_CLR_RX_DONE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the RX_DONE interrupt (bit 7) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_RX_DONE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x58);

        /// address: 0x4004805c
        /// Clear ACTIVITY Interrupt Register
        pub const IC_CLR_ACTIVITY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reading this register clears the ACTIVITY interrupt if the I2C is not active
            /// anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt
            /// bit continues to be set. It is automatically cleared by hardware if the module
            /// is disabled and if there is no further activity on the bus. The value read from
            /// this register to get status of the ACTIVITY interrupt (bit 8) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_ACTIVITY: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x5c);

        /// address: 0x40048060
        /// Clear STOP_DET Interrupt Register
        pub const IC_CLR_STOP_DET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the STOP_DET interrupt (bit 9) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_STOP_DET: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x60);

        /// address: 0x40048064
        /// Clear START_DET Interrupt Register
        pub const IC_CLR_START_DET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the START_DET interrupt (bit 10) of the
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_START_DET: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x64);

        /// address: 0x40048068
        /// Clear GEN_CALL Interrupt Register
        pub const IC_CLR_GEN_CALL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT
            /// register.\n\n
            /// Reset value: 0x0
            CLR_GEN_CALL: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x68);

        /// address: 0x4004806c
        /// I2C Enable Register
        pub const IC_ENABLE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX
            /// FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable
            /// DW_apb_i2c while it is active. However, it is important that care be taken to
            /// ensure that DW_apb_i2c is disabled properly. A recommended procedure is
            /// described in 'Disabling DW_apb_i2c'.\n\n
            /// When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get
            /// flushed. - Status bits in the IC_INTR_STAT register are still active until
            /// DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well
            /// as deletes the contents of the transmit buffer after the current transfer is
            /// complete. If the module is receiving, the DW_apb_i2c stops the current transfer
            /// at the end of the current byte and does not acknowledge the transfer.\n\n
            /// In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to
            /// asynchronous (1), there is a two ic_clk delay when enabling or disabling the
            /// DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to
            /// 'Disabling DW_apb_i2c'\n\n
            /// Reset value: 0x0
            ENABLE: u1,
            /// When set, the controller initiates the transfer abort. - 0: ABORT not initiated
            /// or ABORT done - 1: ABORT operation in progress The software can abort the I2C
            /// transfer in master mode by setting this bit. The software can set this bit only
            /// when ENABLE is already set; otherwise, the controller ignores any write to ABORT
            /// bit. The software cannot clear the ABORT bit once set. In response to an ABORT,
            /// the controller issues a STOP and flushes the Tx FIFO after completing the
            /// current transfer, then sets the TX_ABORT interrupt after the abort operation.
            /// The ABORT bit is cleared automatically after the abort operation.\n\n
            /// For a detailed description on how to abort I2C transfers, refer to 'Aborting I2C
            /// Transfers'.\n\n
            /// Reset value: 0x0
            ABORT: u1,
            /// In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx
            /// FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus
            /// automatically, as soon as the first data is available in the Tx FIFO. Note: To
            /// block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx
            /// FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0).
            /// Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit
            /// is unset. Reset value: IC_TX_CMD_BLOCK_DEFAULT
            TX_CMD_BLOCK: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
        }), base_address + 0x6c);

        /// address: 0x40048070
        /// I2C Status Register\n\n
        /// This is a read-only register used to indicate the current transfer status and
        /// FIFO status. The status register may be read at any time. None of the bits in
        /// this register request an interrupt.\n\n
        /// When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits
        /// 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state
        /// machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0
        pub const IC_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2C Activity Status. Reset value: 0x0
            ACTIVITY: u1,
            /// Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty
            /// locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1:
            /// Transmit FIFO is not full Reset value: 0x1
            TFNF: u1,
            /// Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this
            /// bit is set. When it contains one or more valid entries, this bit is cleared.
            /// This bit field does not request an interrupt. - 0: Transmit FIFO is not empty -
            /// 1: Transmit FIFO is empty Reset value: 0x1
            TFE: u1,
            /// Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or
            /// more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is
            /// empty - 1: Receive FIFO is not empty Reset value: 0x0
            RFNE: u1,
            /// Receive FIFO Completely Full. When the receive FIFO is completely full, this bit
            /// is set. When the receive FIFO contains one or more empty location, this bit is
            /// cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value:
            /// 0x0
            RFF: u1,
            /// Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in
            /// the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master
            /// part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the
            /// Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is
            /// the OR of SLV_ACTIVITY and MST_ACTIVITY bits.\n\n
            /// Reset value: 0x0
            MST_ACTIVITY: u1,
            /// Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in
            /// the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave
            /// part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the
            /// Slave part of DW_apb_i2c is Active Reset value: 0x0
            SLV_ACTIVITY: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
        }), base_address + 0x70);

        /// address: 0x40048074
        /// I2C Transmit FIFO Level Register This register contains the number of valid data
        /// entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is
        /// disabled - There is a transmit abort - that is, TX_ABRT bit is set in the
        /// IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register
        /// increments whenever data is placed into the transmit FIFO and decrements when
        /// data is taken from the transmit FIFO.
        pub const IC_TXFLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit FIFO Level. Contains the number of valid data entries in the transmit
            /// FIFO.\n\n
            /// Reset value: 0x0
            TXFLR: u5,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
        }), base_address + 0x74);

        /// address: 0x40048078
        /// I2C Receive FIFO Level Register This register contains the number of valid data
        /// entries in the receive FIFO buffer. It is cleared whenever: - The I2C is
        /// disabled - Whenever there is a transmit abort caused by any of the events
        /// tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed
        /// into the receive FIFO and decrements when data is taken from the receive FIFO.
        pub const IC_RXFLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive FIFO Level. Contains the number of valid data entries in the receive
            /// FIFO.\n\n
            /// Reset value: 0x0
            RXFLR: u5,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
        }), base_address + 0x78);

        /// address: 0x4004807c
        /// I2C SDA Hold Time Length Register\n\n
        /// The bits [15:0] of this register are used to control the hold time of SDA during
        /// transmit in both slave and master mode (after SCL goes from HIGH to LOW).\n\n
        /// The bits [23:16] of this register are used to extend the SDA transition (if any)
        /// whenever SCL is HIGH in the receiver in either master or slave mode.\n\n
        /// Writes to this register succeed only when IC_ENABLE[0]=0.\n\n
        /// The values in this register are in units of ic_clk period. The value programmed
        /// in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one
        /// cycle in master mode, seven cycles in slave mode) for the value to be
        /// implemented.\n\n
        /// The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at
        /// any time the duration of the low part of scl. Therefore the programmed value
        /// cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low
        /// part of the scl period measured in ic_clk cycles.
        pub const IC_SDA_HOLD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts
            /// as a transmitter.\n\n
            /// Reset value: IC_DEFAULT_SDA_HOLD[15:0].
            IC_SDA_TX_HOLD: u16,
            /// Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts
            /// as a receiver.\n\n
            /// Reset value: IC_DEFAULT_SDA_HOLD[23:16].
            IC_SDA_RX_HOLD: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x7c);

        /// address: 0x40048080
        /// I2C Transmit Abort Source Register\n\n
        /// This register has 32 bits that indicate the source of the TX_ABRT bit. Except
        /// for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the
        /// IC_CLR_INTR register is read. To clear Bit 9, the source of the
        /// ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1),
        /// the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be
        /// cleared (IC_TAR[10]).\n\n
        /// Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared
        /// in the same manner as other bits in this register. If the source of the
        /// ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9
        /// clears for one cycle and is then re-asserted.
        pub const IC_TX_ABRT_SOURCE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This field indicates that the Master is in 7-bit addressing mode and the address
            /// sent was not acknowledged by any slave.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            ABRT_7B_ADDR_NOACK: u1,
            /// This field indicates that the Master is in 10-bit address mode and the first
            /// 10-bit address byte was not acknowledged by any slave.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            ABRT_10ADDR1_NOACK: u1,
            /// This field indicates that the Master is in 10-bit address mode and that the
            /// second address byte of the 10-bit address was not acknowledged by any slave.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            ABRT_10ADDR2_NOACK: u1,
            /// This field indicates the master-mode only bit. When the master receives an
            /// acknowledgement for the address, but when it sends data byte(s) following the
            /// address, it did not receive an acknowledge from the remote slave(s).\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter
            ABRT_TXDATA_NOACK: u1,
            /// This field indicates that DW_apb_i2c in master mode has sent a General Call and
            /// no slave on the bus acknowledged the General Call.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter
            ABRT_GCALL_NOACK: u1,
            /// This field indicates that DW_apb_i2c in the master mode has sent a General Call
            /// but the user programmed the byte following the General Call to be a read from
            /// the bus (IC_DATA_CMD[9] is set to 1).\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter
            ABRT_GCALL_READ: u1,
            /// This field indicates that the Master is in High Speed mode and the High Speed
            /// Master code was acknowledged (wrong behavior).\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master
            ABRT_HS_ACKDET: u1,
            /// This field indicates that the Master has sent a START Byte and the START Byte
            /// was acknowledged (wrong behavior).\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master
            ABRT_SBYTE_ACKDET: u1,
            /// This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5])
            /// =0) and the user is trying to use the master to transfer data in High Speed
            /// mode.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            ABRT_HS_NORSTRT: u1,
            /// To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first;
            /// restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared
            /// (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the
            /// source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the
            /// same manner as other bits in this register. If the source of the
            /// ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9
            /// clears for one cycle and then gets reasserted. When this field is set to 1, the
            /// restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to
            /// send a START Byte.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master
            ABRT_SBYTE_NORSTRT: u1,
            /// This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5])
            /// =0) and the master sends a read command in 10-bit addressing mode.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Receiver
            ABRT_10B_RD_NORSTRT: u1,
            /// This field indicates that the User tries to initiate a Master operation with the
            /// Master mode disabled.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
            ABRT_MASTER_DIS: u1,
            /// This field specifies that the Master has lost arbitration, or if
            /// IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost
            /// arbitration.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
            ARB_LOST: u1,
            /// This field specifies that the Slave has received a read command and some data
            /// exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data
            /// in TX FIFO.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Slave-Transmitter
            ABRT_SLVFLUSH_TXFIFO: u1,
            /// This field indicates that a Slave has lost the bus while transmitting data to a
            /// remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though
            /// the slave never 'owns' the bus, something could go wrong on the bus. This is a
            /// fail safe check. For instance, during a data transmission at the low-to-high
            /// transition of SCL, if what is on the data bus is not what is supposed to be
            /// transmitted, then DW_apb_i2c no longer own the bus.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Slave-Transmitter
            ABRT_SLV_ARBLOST: u1,
            /// 1: When the processor side responds to a slave mode request for data to be
            /// transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD
            /// register.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Slave-Transmitter
            ABRT_SLVRD_INTX: u1,
            /// This is a master-mode-only bit. Master has detected the transfer abort
            /// (IC_ENABLE[1])\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter
            ABRT_USER_ABRT: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            /// This field indicates the number of Tx FIFO Data Commands which are flushed due
            /// to TX_ABRT interrupt. It is cleared whenever I2C is disabled.\n\n
            /// Reset value: 0x0\n\n
            /// Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
            TX_FLUSH_CNT: u9,
        }), base_address + 0x80);

        /// address: 0x40048084
        /// Generate Slave Data NACK Register\n\n
        /// The register is used to generate a NACK for the data part of a transfer when
        /// DW_apb_i2c is acting as a slave-receiver. This register only exists when the
        /// IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this
        /// register does not exist and writing to the register's address has no effect.\n\n
        /// A write can occur on this register if both of the following conditions are met:
        /// - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive
        /// (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for
        /// the internal slv_activity signal; the user should poll this before writing the
        /// ic_slv_data_nack_only bit.
        pub const IC_SLV_DATA_NACK_ONLY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Generate NACK. This NACK generation only occurs when DW_apb_i2c is a
            /// slave-receiver. If this register is set to a value of 1, it can only generate a
            /// NACK after a data byte is received; hence, the data transfer is aborted and the
            /// data received is not pushed to the receive buffer.\n\n
            /// When the register is set to a value of 0, it generates NACK/ACK, depending on
            /// normal criteria. - 1: generate NACK after data byte received - 0: generate
            /// NACK/ACK normally Reset value: 0x0
            NACK: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x84);

        /// address: 0x40048088
        /// DMA Control Register\n\n
        /// The register is used to enable the DMA Controller interface operation. There is
        /// a separate bit for transmit and receive. This can be programmed regardless of
        /// the state of IC_ENABLE.
        pub const IC_DMA_CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.
            /// Reset value: 0x0
            RDMAE: u1,
            /// Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel.
            /// Reset value: 0x0
            TDMAE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
        }), base_address + 0x88);

        /// address: 0x4004808c
        /// DMA Transmit Data Level Register
        pub const IC_DMA_TDLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Data Level. This bit field controls the level at which a DMA request is
            /// made by the transmit logic. It is equal to the watermark level; that is, the
            /// dma_tx_req signal is generated when the number of valid data entries in the
            /// transmit FIFO is equal to or below this field value, and TDMAE = 1.\n\n
            /// Reset value: 0x0
            DMATDL: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x8c);

        /// address: 0x40048090
        /// I2C Receive Data Level Register
        pub const IC_DMA_RDLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Data Level. This bit field controls the level at which a DMA request is
            /// made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req
            /// is generated when the number of valid data entries in the receive FIFO is equal
            /// to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is
            /// 0, then dma_rx_req is asserted when 1 or more data entries are present in the
            /// receive FIFO.\n\n
            /// Reset value: 0x0
            DMARDL: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x90);

        /// address: 0x40048094
        /// I2C SDA Setup Register\n\n
        /// This register controls the amount of time delay (in terms of number of ic_clk
        /// clock periods) introduced in the rising edge of SCL - relative to SDA changing -
        /// when DW_apb_i2c services a read request in a slave-transmitter operation. The
        /// relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus
        /// Specification. This register must be programmed with a value equal to or greater
        /// than 2.\n\n
        /// Writes to this register succeed only when IC_ENABLE[0] = 0.\n\n
        /// Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) *
        /// (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they
        /// should program a value of 11. The IC_SDA_SETUP register is only used by the
        /// DW_apb_i2c when operating as a slave transmitter.
        pub const IC_SDA_SETUP = @intToPtr(*volatile Mmio(32, packed struct {
            /// SDA Setup. It is recommended that if the required delay is 1000ns, then for an
            /// ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.
            /// IC_SDA_SETUP must be programmed with a minimum value of 2.
            SDA_SETUP: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x94);

        /// address: 0x40048098
        /// I2C ACK General Call Register\n\n
        /// The register controls whether DW_apb_i2c responds with a ACK or NACK when it
        /// receives an I2C General Call address.\n\n
        /// This register is applicable only when the DW_apb_i2c is in slave mode.
        pub const IC_ACK_GENERAL_CALL = @intToPtr(*volatile Mmio(32, packed struct {
            /// ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting
            /// ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with
            /// a NACK (by negating ic_data_oe).
            ACK_GEN_CALL: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x98);

        /// address: 0x4004809c
        /// I2C Enable Status Register\n\n
        /// The register is used to report the DW_apb_i2c hardware status when the
        /// IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is
        /// disabled.\n\n
        /// If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced
        /// to 1.\n\n
        /// If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is
        /// read as '0'.\n\n
        /// Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read
        /// as 0 because disabling the DW_apb_i2c depends on I2C bus activities.
        pub const IC_ENABLE_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// ic_en Status. This bit always reflects the value driven on the output port
            /// ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When
            /// read as 0, DW_apb_i2c is deemed completely inactive. Note: The CPU can safely
            /// read this bit anytime. When this bit is read as 0, the CPU can safely read
            /// SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).\n\n
            /// Reset value: 0x0
            IC_EN: u1,
            /// Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential
            /// or active Slave operation has been aborted due to the setting bit 0 of the
            /// IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the
            /// IC_ENABLE register while:\n\n
            /// (a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter operation
            /// from a remote master;\n\n
            /// OR,\n\n
            /// (b) address and data bytes of the Slave-Receiver operation from a remote
            /// master.\n\n
            /// When read as 1, DW_apb_i2c is deemed to have forced a NACK during any part of an
            /// I2C transfer, irrespective of whether the I2C address matches the slave address
            /// set in DW_apb_i2c (IC_SAR register) OR if the transfer is completed before
            /// IC_ENABLE is set to 0 but has not taken effect.\n\n
            /// Note: If the remote I2C master terminates the transfer with a STOP condition
            /// before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been
            /// set to 0, then this bit will also be set to 1.\n\n
            /// When read as 0, DW_apb_i2c is deemed to have been disabled when there is master
            /// activity, or when the I2C bus is idle.\n\n
            /// Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n
            /// Reset value: 0x0
            SLV_DISABLED_WHILE_BUSY: u1,
            /// Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has
            /// been aborted with at least one data byte received from an I2C transfer due to
            /// the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed
            /// to have been actively engaged in an aborted I2C transfer (with matching address)
            /// and the data phase of the I2C transfer has been entered, even though a data byte
            /// has been responded with a NACK.\n\n
            /// Note: If the remote I2C master terminates the transfer with a STOP condition
            /// before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been
            /// set to 0, then this bit is also set to 1.\n\n
            /// When read as 0, DW_apb_i2c is deemed to have been disabled without being
            /// actively involved in the data phase of a Slave-Receiver transfer.\n\n
            /// Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n
            /// Reset value: 0x0
            SLV_RX_DATA_LOST: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
        }), base_address + 0x9c);

        /// address: 0x400480a0
        /// I2C SS, FS or FM+ spike suppression limit\n\n
        /// This register is used to store the duration, measured in ic_clk cycles, of the
        /// longest spike that is filtered out by the spike suppression logic when the
        /// component is operating in SS, FS or FM+ modes. The relevant I2C requirement is
        /// tSP (table 4) as detailed in the I2C Bus Specification. This register must be
        /// programmed with a minimum value of 1.
        pub const IC_FS_SPKLEN = @intToPtr(*volatile MmioInt(32, u8), base_address + 0xa0);

        /// address: 0x400480a8
        /// Clear RESTART_DET Interrupt Register
        pub const IC_CLR_RESTART_DET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read this register to clear the RESTART_DET interrupt (bit 12) of
            /// IC_RAW_INTR_STAT register.\n\n
            /// Reset value: 0x0
            CLR_RESTART_DET: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0xa8);

        /// address: 0x400480f4
        /// Component Parameter Register 1\n\n
        /// Note This register is not implemented and therefore reads as 0. If it was
        /// implemented it would be a constant read-only register that contains encoded
        /// information about the component's parameter settings. Fields shown below are the
        /// settings for those parameters
        pub const IC_COMP_PARAM_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// APB data bus width is 32 bits
            APB_DATA_WIDTH: u2,
            /// MAX SPEED MODE = FAST MODE
            MAX_SPEED_MODE: u2,
            /// Programmable count values for each mode.
            HC_COUNT_VALUES: u1,
            /// COMBINED Interrupt outputs
            INTR_IO: u1,
            /// DMA handshaking signals are enabled
            HAS_DMA: u1,
            /// Encoded parameters not visible
            ADD_ENCODED_PARAMS: u1,
            /// RX Buffer Depth = 16
            RX_BUFFER_DEPTH: u8,
            /// TX Buffer Depth = 16
            TX_BUFFER_DEPTH: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0xf4);

        /// address: 0x400480f8
        /// I2C Component Version Register
        pub const IC_COMP_VERSION = @intToPtr(*volatile u32, base_address + 0xf8);

        /// address: 0x400480fc
        /// I2C Component Type Register
        pub const IC_COMP_TYPE = @intToPtr(*volatile u32, base_address + 0xfc);
    };

    /// Control and data interface to SAR ADC
    pub const ADC = struct {
        pub const base_address = 0x4004c000;
        pub const version = "2";

        /// address: 0x4004c000
        /// ADC Control and Status
        pub const CS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Power on ADC and enable its clock.\n
            /// 1 - enabled. 0 - disabled.
            EN: u1,
            /// Power on temperature sensor. 1 - enabled. 0 - disabled.
            TS_EN: u1,
            /// Start a single conversion. Self-clearing. Ignored if start_many is asserted.
            START_ONCE: u1,
            /// Continuously perform conversions whilst this bit is 1. A new conversion will
            /// start immediately after the previous finishes.
            START_MANY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// 1 if the ADC is ready to start a new conversion. Implies any previous conversion
            /// has completed.\n
            /// 0 whilst conversion in progress.
            READY: u1,
            /// The most recent ADC conversion encountered an error; result is undefined or
            /// noisy.
            ERR: u1,
            /// Some past ADC conversion encountered an error. Write 1 to clear.
            ERR_STICKY: u1,
            reserved4: u1 = 0,
            /// Select analog mux input. Updated automatically in round-robin mode.
            AINSEL: u3,
            reserved5: u1 = 0,
            /// Round-robin sampling. 1 bit per channel. Set all bits to 0 to disable.\n
            /// Otherwise, the ADC will cycle through each enabled channel in a round-robin
            /// fashion.\n
            /// The first channel to be sampled will be the one currently indicated by AINSEL.\n
            /// AINSEL will be updated after each conversion with the newly-selected channel.
            RROBIN: u5,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x4004c004
        /// Result of most recent ADC conversion
        pub const RESULT = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x4);

        /// address: 0x4004c008
        /// FIFO control and status
        pub const FCS = @intToPtr(*volatile Mmio(32, packed struct {
            /// If 1: write result to the FIFO after each conversion.
            EN: u1,
            /// If 1: FIFO results are right-shifted to be one byte in size. Enables DMA to byte
            /// buffers.
            SHIFT: u1,
            /// If 1: conversion error bit appears in the FIFO alongside the result
            ERR: u1,
            /// If 1: assert DMA requests when FIFO contains data
            DREQ_EN: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            EMPTY: u1,
            FULL: u1,
            /// 1 if the FIFO has been underflowed. Write 1 to clear.
            UNDER: u1,
            /// 1 if the FIFO has been overflowed. Write 1 to clear.
            OVER: u1,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// The number of conversion results currently waiting in the FIFO
            LEVEL: u4,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            /// DREQ/IRQ asserted when level >= threshold
            THRESH: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x4004c00c
        /// Conversion result FIFO
        pub const FIFO = @intToPtr(*volatile Mmio(32, packed struct {
            VAL: u12,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            /// 1 if this particular sample experienced a conversion error. Remains in the same
            /// location if the sample is shifted.
            ERR: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0xc);

        /// address: 0x4004c010
        /// Clock divider. If non-zero, CS_START_MANY will start conversions\n
        /// at regular intervals rather than back-to-back.\n
        /// The divider is reset when either of these fields are written.\n
        /// Total period is 1 + INT + FRAC / 256
        pub const DIV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fractional part of clock divisor. First-order delta-sigma.
            FRAC: u8,
            /// Integer part of clock divisor.
            INT: u16,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x10);

        /// address: 0x4004c014
        /// Raw Interrupts
        pub const INTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Triggered when the sample FIFO reaches a certain level.\n
            /// This level can be programmed via the FCS_THRESH field.
            FIFO: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x14);

        /// address: 0x4004c018
        /// Interrupt Enable
        pub const INTE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Triggered when the sample FIFO reaches a certain level.\n
            /// This level can be programmed via the FCS_THRESH field.
            FIFO: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x4004c01c
        /// Interrupt Force
        pub const INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Triggered when the sample FIFO reaches a certain level.\n
            /// This level can be programmed via the FCS_THRESH field.
            FIFO: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x1c);

        /// address: 0x4004c020
        /// Interrupt status after masking & forcing
        pub const INTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Triggered when the sample FIFO reaches a certain level.\n
            /// This level can be programmed via the FCS_THRESH field.
            FIFO: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x20);
    };

    /// Simple PWM
    pub const PWM = struct {
        pub const base_address = 0x40050000;
        pub const version = "1";

        /// address: 0x40050000
        /// Control and status register
        pub const CH0_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the PWM channel.
            EN: u1,
            /// 1: Enable phase-correct modulation. 0: Trailing-edge
            PH_CORRECT: u1,
            /// Invert output A
            A_INV: u1,
            /// Invert output B
            B_INV: u1,
            DIVMODE: u2,
            /// Retard the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running.
            PH_RET: u1,
            /// Advance the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running\n
            /// at less than full speed (div_int + div_frac / 16 > 1)
            PH_ADV: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40050004
        /// INT and FRAC form a fixed-point fractional number.\n
        /// Counting rate is system clock frequency divided by this number.\n
        /// Fractional division uses simple 1st-order sigma-delta.
        pub const CH0_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            FRAC: u4,
            INT: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40050008
        /// Direct access to the PWM counter
        pub const CH0_CTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x8);

        /// address: 0x4005000c
        /// Counter compare values
        pub const CH0_CC = @intToPtr(*volatile Mmio(32, packed struct {
            A: u16,
            B: u16,
        }), base_address + 0xc);

        /// address: 0x40050010
        /// Counter wrap value
        pub const CH0_TOP = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x10);

        /// address: 0x40050014
        /// Control and status register
        pub const CH1_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the PWM channel.
            EN: u1,
            /// 1: Enable phase-correct modulation. 0: Trailing-edge
            PH_CORRECT: u1,
            /// Invert output A
            A_INV: u1,
            /// Invert output B
            B_INV: u1,
            DIVMODE: u2,
            /// Retard the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running.
            PH_RET: u1,
            /// Advance the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running\n
            /// at less than full speed (div_int + div_frac / 16 > 1)
            PH_ADV: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x14);

        /// address: 0x40050018
        /// INT and FRAC form a fixed-point fractional number.\n
        /// Counting rate is system clock frequency divided by this number.\n
        /// Fractional division uses simple 1st-order sigma-delta.
        pub const CH1_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            FRAC: u4,
            INT: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x4005001c
        /// Direct access to the PWM counter
        pub const CH1_CTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x1c);

        /// address: 0x40050020
        /// Counter compare values
        pub const CH1_CC = @intToPtr(*volatile Mmio(32, packed struct {
            A: u16,
            B: u16,
        }), base_address + 0x20);

        /// address: 0x40050024
        /// Counter wrap value
        pub const CH1_TOP = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40050028
        /// Control and status register
        pub const CH2_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the PWM channel.
            EN: u1,
            /// 1: Enable phase-correct modulation. 0: Trailing-edge
            PH_CORRECT: u1,
            /// Invert output A
            A_INV: u1,
            /// Invert output B
            B_INV: u1,
            DIVMODE: u2,
            /// Retard the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running.
            PH_RET: u1,
            /// Advance the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running\n
            /// at less than full speed (div_int + div_frac / 16 > 1)
            PH_ADV: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x28);

        /// address: 0x4005002c
        /// INT and FRAC form a fixed-point fractional number.\n
        /// Counting rate is system clock frequency divided by this number.\n
        /// Fractional division uses simple 1st-order sigma-delta.
        pub const CH2_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            FRAC: u4,
            INT: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x2c);

        /// address: 0x40050030
        /// Direct access to the PWM counter
        pub const CH2_CTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x30);

        /// address: 0x40050034
        /// Counter compare values
        pub const CH2_CC = @intToPtr(*volatile Mmio(32, packed struct {
            A: u16,
            B: u16,
        }), base_address + 0x34);

        /// address: 0x40050038
        /// Counter wrap value
        pub const CH2_TOP = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x4005003c
        /// Control and status register
        pub const CH3_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the PWM channel.
            EN: u1,
            /// 1: Enable phase-correct modulation. 0: Trailing-edge
            PH_CORRECT: u1,
            /// Invert output A
            A_INV: u1,
            /// Invert output B
            B_INV: u1,
            DIVMODE: u2,
            /// Retard the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running.
            PH_RET: u1,
            /// Advance the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running\n
            /// at less than full speed (div_int + div_frac / 16 > 1)
            PH_ADV: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x3c);

        /// address: 0x40050040
        /// INT and FRAC form a fixed-point fractional number.\n
        /// Counting rate is system clock frequency divided by this number.\n
        /// Fractional division uses simple 1st-order sigma-delta.
        pub const CH3_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            FRAC: u4,
            INT: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x40);

        /// address: 0x40050044
        /// Direct access to the PWM counter
        pub const CH3_CTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x44);

        /// address: 0x40050048
        /// Counter compare values
        pub const CH3_CC = @intToPtr(*volatile Mmio(32, packed struct {
            A: u16,
            B: u16,
        }), base_address + 0x48);

        /// address: 0x4005004c
        /// Counter wrap value
        pub const CH3_TOP = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x4c);

        /// address: 0x40050050
        /// Control and status register
        pub const CH4_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the PWM channel.
            EN: u1,
            /// 1: Enable phase-correct modulation. 0: Trailing-edge
            PH_CORRECT: u1,
            /// Invert output A
            A_INV: u1,
            /// Invert output B
            B_INV: u1,
            DIVMODE: u2,
            /// Retard the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running.
            PH_RET: u1,
            /// Advance the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running\n
            /// at less than full speed (div_int + div_frac / 16 > 1)
            PH_ADV: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x50);

        /// address: 0x40050054
        /// INT and FRAC form a fixed-point fractional number.\n
        /// Counting rate is system clock frequency divided by this number.\n
        /// Fractional division uses simple 1st-order sigma-delta.
        pub const CH4_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            FRAC: u4,
            INT: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x54);

        /// address: 0x40050058
        /// Direct access to the PWM counter
        pub const CH4_CTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x58);

        /// address: 0x4005005c
        /// Counter compare values
        pub const CH4_CC = @intToPtr(*volatile Mmio(32, packed struct {
            A: u16,
            B: u16,
        }), base_address + 0x5c);

        /// address: 0x40050060
        /// Counter wrap value
        pub const CH4_TOP = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x60);

        /// address: 0x40050064
        /// Control and status register
        pub const CH5_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the PWM channel.
            EN: u1,
            /// 1: Enable phase-correct modulation. 0: Trailing-edge
            PH_CORRECT: u1,
            /// Invert output A
            A_INV: u1,
            /// Invert output B
            B_INV: u1,
            DIVMODE: u2,
            /// Retard the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running.
            PH_RET: u1,
            /// Advance the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running\n
            /// at less than full speed (div_int + div_frac / 16 > 1)
            PH_ADV: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x64);

        /// address: 0x40050068
        /// INT and FRAC form a fixed-point fractional number.\n
        /// Counting rate is system clock frequency divided by this number.\n
        /// Fractional division uses simple 1st-order sigma-delta.
        pub const CH5_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            FRAC: u4,
            INT: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x68);

        /// address: 0x4005006c
        /// Direct access to the PWM counter
        pub const CH5_CTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x6c);

        /// address: 0x40050070
        /// Counter compare values
        pub const CH5_CC = @intToPtr(*volatile Mmio(32, packed struct {
            A: u16,
            B: u16,
        }), base_address + 0x70);

        /// address: 0x40050074
        /// Counter wrap value
        pub const CH5_TOP = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x74);

        /// address: 0x40050078
        /// Control and status register
        pub const CH6_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the PWM channel.
            EN: u1,
            /// 1: Enable phase-correct modulation. 0: Trailing-edge
            PH_CORRECT: u1,
            /// Invert output A
            A_INV: u1,
            /// Invert output B
            B_INV: u1,
            DIVMODE: u2,
            /// Retard the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running.
            PH_RET: u1,
            /// Advance the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running\n
            /// at less than full speed (div_int + div_frac / 16 > 1)
            PH_ADV: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x78);

        /// address: 0x4005007c
        /// INT and FRAC form a fixed-point fractional number.\n
        /// Counting rate is system clock frequency divided by this number.\n
        /// Fractional division uses simple 1st-order sigma-delta.
        pub const CH6_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            FRAC: u4,
            INT: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x7c);

        /// address: 0x40050080
        /// Direct access to the PWM counter
        pub const CH6_CTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x80);

        /// address: 0x40050084
        /// Counter compare values
        pub const CH6_CC = @intToPtr(*volatile Mmio(32, packed struct {
            A: u16,
            B: u16,
        }), base_address + 0x84);

        /// address: 0x40050088
        /// Counter wrap value
        pub const CH6_TOP = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x88);

        /// address: 0x4005008c
        /// Control and status register
        pub const CH7_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the PWM channel.
            EN: u1,
            /// 1: Enable phase-correct modulation. 0: Trailing-edge
            PH_CORRECT: u1,
            /// Invert output A
            A_INV: u1,
            /// Invert output B
            B_INV: u1,
            DIVMODE: u2,
            /// Retard the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running.
            PH_RET: u1,
            /// Advance the phase of the counter by 1 count, while it is running.\n
            /// Self-clearing. Write a 1, and poll until low. Counter must be running\n
            /// at less than full speed (div_int + div_frac / 16 > 1)
            PH_ADV: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x8c);

        /// address: 0x40050090
        /// INT and FRAC form a fixed-point fractional number.\n
        /// Counting rate is system clock frequency divided by this number.\n
        /// Fractional division uses simple 1st-order sigma-delta.
        pub const CH7_DIV = @intToPtr(*volatile Mmio(32, packed struct {
            FRAC: u4,
            INT: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x90);

        /// address: 0x40050094
        /// Direct access to the PWM counter
        pub const CH7_CTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x94);

        /// address: 0x40050098
        /// Counter compare values
        pub const CH7_CC = @intToPtr(*volatile Mmio(32, packed struct {
            A: u16,
            B: u16,
        }), base_address + 0x98);

        /// address: 0x4005009c
        /// Counter wrap value
        pub const CH7_TOP = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x9c);

        /// address: 0x400500a0
        /// This register aliases the CSR_EN bits for all channels.\n
        /// Writing to this register allows multiple channels to be enabled\n
        /// or disabled simultaneously, so they can run in perfect sync.\n
        /// For each channel, there is only one physical EN register bit,\n
        /// which can be accessed through here or CHx_CSR.
        pub const EN = @intToPtr(*volatile Mmio(32, packed struct {
            CH0: u1,
            CH1: u1,
            CH2: u1,
            CH3: u1,
            CH4: u1,
            CH5: u1,
            CH6: u1,
            CH7: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xa0);

        /// address: 0x400500a4
        /// Raw Interrupts
        pub const INTR = @intToPtr(*volatile Mmio(32, packed struct {
            CH0: u1,
            CH1: u1,
            CH2: u1,
            CH3: u1,
            CH4: u1,
            CH5: u1,
            CH6: u1,
            CH7: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xa4);

        /// address: 0x400500a8
        /// Interrupt Enable
        pub const INTE = @intToPtr(*volatile Mmio(32, packed struct {
            CH0: u1,
            CH1: u1,
            CH2: u1,
            CH3: u1,
            CH4: u1,
            CH5: u1,
            CH6: u1,
            CH7: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xa8);

        /// address: 0x400500ac
        /// Interrupt Force
        pub const INTF = @intToPtr(*volatile Mmio(32, packed struct {
            CH0: u1,
            CH1: u1,
            CH2: u1,
            CH3: u1,
            CH4: u1,
            CH5: u1,
            CH6: u1,
            CH7: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xac);

        /// address: 0x400500b0
        /// Interrupt status after masking & forcing
        pub const INTS = @intToPtr(*volatile Mmio(32, packed struct {
            CH0: u1,
            CH1: u1,
            CH2: u1,
            CH3: u1,
            CH4: u1,
            CH5: u1,
            CH6: u1,
            CH7: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0xb0);
    };

    /// Controls time and alarms\n
    /// time is a 64 bit value indicating the time in usec since power-on\n
    /// timeh is the top 32 bits of time & timel is the bottom 32 bits\n
    /// to change time write to timelw before timehw\n
    /// to read time read from timelr before timehr\n
    /// An alarm is set by setting alarm_enable and writing to the corresponding alarm
    /// register\n
    /// When an alarm is pending, the corresponding alarm_running signal will be high\n
    /// An alarm can be cancelled before it has finished by clearing the alarm_enable\n
    /// When an alarm fires, the corresponding alarm_irq is set and alarm_running is
    /// cleared\n
    /// To clear the interrupt write a 1 to the corresponding alarm_irq
    pub const TIMER = struct {
        pub const base_address = 0x40054000;
        pub const version = "1";

        /// address: 0x40054000
        /// Write to bits 63:32 of time\n
        /// always write timelw before timehw
        pub const TIMEHW = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40054004
        /// Write to bits 31:0 of time\n
        /// writes do not get copied to time until timehw is written
        pub const TIMELW = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40054008
        /// Read from bits 63:32 of time\n
        /// always read timelr before timehr
        pub const TIMEHR = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4005400c
        /// Read from bits 31:0 of time
        pub const TIMELR = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40054010
        /// Arm alarm 0, and configure the time it will fire.\n
        /// Once armed, the alarm fires when TIMER_ALARM0 == TIMELR.\n
        /// The alarm will disarm itself once it fires, and can\n
        /// be disarmed early using the ARMED status register.
        pub const ALARM0 = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40054014
        /// Arm alarm 1, and configure the time it will fire.\n
        /// Once armed, the alarm fires when TIMER_ALARM1 == TIMELR.\n
        /// The alarm will disarm itself once it fires, and can\n
        /// be disarmed early using the ARMED status register.
        pub const ALARM1 = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x40054018
        /// Arm alarm 2, and configure the time it will fire.\n
        /// Once armed, the alarm fires when TIMER_ALARM2 == TIMELR.\n
        /// The alarm will disarm itself once it fires, and can\n
        /// be disarmed early using the ARMED status register.
        pub const ALARM2 = @intToPtr(*volatile u32, base_address + 0x18);

        /// address: 0x4005401c
        /// Arm alarm 3, and configure the time it will fire.\n
        /// Once armed, the alarm fires when TIMER_ALARM3 == TIMELR.\n
        /// The alarm will disarm itself once it fires, and can\n
        /// be disarmed early using the ARMED status register.
        pub const ALARM3 = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40054020
        /// Indicates the armed/disarmed status of each alarm.\n
        /// A write to the corresponding ALARMx register arms the alarm.\n
        /// Alarms automatically disarm upon firing, but writing ones here\n
        /// will disarm immediately without waiting to fire.
        pub const ARMED = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x20);

        /// address: 0x40054024
        /// Raw read from bits 63:32 of time (no side effects)
        pub const TIMERAWH = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x40054028
        /// Raw read from bits 31:0 of time (no side effects)
        pub const TIMERAWL = @intToPtr(*volatile u32, base_address + 0x28);

        /// address: 0x4005402c
        /// Set bits high to enable pause when the corresponding debug ports are active
        pub const DBGPAUSE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            /// Pause when processor 0 is in debug mode
            DBG0: u1,
            /// Pause when processor 1 is in debug mode
            DBG1: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
        }), base_address + 0x2c);

        /// address: 0x40054030
        /// Set high to pause the timer
        pub const PAUSE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x30);

        /// address: 0x40054034
        /// Raw Interrupts
        pub const INTR = @intToPtr(*volatile Mmio(32, packed struct {
            ALARM_0: u1,
            ALARM_1: u1,
            ALARM_2: u1,
            ALARM_3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x34);

        /// address: 0x40054038
        /// Interrupt Enable
        pub const INTE = @intToPtr(*volatile Mmio(32, packed struct {
            ALARM_0: u1,
            ALARM_1: u1,
            ALARM_2: u1,
            ALARM_3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x38);

        /// address: 0x4005403c
        /// Interrupt Force
        pub const INTF = @intToPtr(*volatile Mmio(32, packed struct {
            ALARM_0: u1,
            ALARM_1: u1,
            ALARM_2: u1,
            ALARM_3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x3c);

        /// address: 0x40054040
        /// Interrupt status after masking & forcing
        pub const INTS = @intToPtr(*volatile Mmio(32, packed struct {
            ALARM_0: u1,
            ALARM_1: u1,
            ALARM_2: u1,
            ALARM_3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x40);
    };
    pub const WATCHDOG = struct {
        pub const base_address = 0x40058000;
        pub const version = "1";

        /// address: 0x40058000
        /// Watchdog control\n
        /// The rst_wdsel register determines which subsystems are reset when the watchdog
        /// is triggered.\n
        /// The watchdog can be triggered in software.
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the number of ticks / 2 (see errata RP2040-E1) before a watchdog reset
            /// will be triggered
            TIME: u24,
            /// Pause the watchdog timer when JTAG is accessing the bus fabric
            PAUSE_JTAG: u1,
            /// Pause the watchdog timer when processor 0 is in debug mode
            PAUSE_DBG0: u1,
            /// Pause the watchdog timer when processor 1 is in debug mode
            PAUSE_DBG1: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            /// When not enabled the watchdog timer is paused
            ENABLE: u1,
            /// Trigger a watchdog reset
            TRIGGER: u1,
        }), base_address + 0x0);

        /// address: 0x40058004
        /// Load the watchdog timer. The maximum setting is 0xffffff which corresponds to
        /// 0xffffff / 2 ticks before triggering a watchdog reset (see errata RP2040-E1).
        pub const LOAD = @intToPtr(*volatile MmioInt(32, u24), base_address + 0x4);

        /// address: 0x40058008
        /// Logs the reason for the last reset. Both bits are zero for the case of a
        /// hardware reset.
        pub const REASON = @intToPtr(*volatile Mmio(32, packed struct {
            TIMER: u1,
            FORCE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x4005800c
        /// Scratch register. Information persists through soft reset of the chip.
        pub const SCRATCH0 = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40058010
        /// Scratch register. Information persists through soft reset of the chip.
        pub const SCRATCH1 = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40058014
        /// Scratch register. Information persists through soft reset of the chip.
        pub const SCRATCH2 = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x40058018
        /// Scratch register. Information persists through soft reset of the chip.
        pub const SCRATCH3 = @intToPtr(*volatile u32, base_address + 0x18);

        /// address: 0x4005801c
        /// Scratch register. Information persists through soft reset of the chip.
        pub const SCRATCH4 = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x40058020
        /// Scratch register. Information persists through soft reset of the chip.
        pub const SCRATCH5 = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x40058024
        /// Scratch register. Information persists through soft reset of the chip.
        pub const SCRATCH6 = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x40058028
        /// Scratch register. Information persists through soft reset of the chip.
        pub const SCRATCH7 = @intToPtr(*volatile u32, base_address + 0x28);

        /// address: 0x4005802c
        /// Controls the tick generator
        pub const TICK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Total number of clk_tick cycles before the next tick.
            CYCLES: u9,
            /// start / stop tick generation
            ENABLE: u1,
            /// Is the tick generator running?
            RUNNING: u1,
            /// Count down timer: the remaining number clk_tick cycles before the next tick is
            /// generated.
            COUNT: u9,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
        }), base_address + 0x2c);
    };

    /// Register block to control RTC
    pub const RTC = struct {
        pub const base_address = 0x4005c000;
        pub const version = "1";

        /// address: 0x4005c000
        /// Divider minus 1 for the 1 second counter. Safe to change the value when RTC is
        /// not enabled.
        pub const CLKDIV_M1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x0);

        /// address: 0x4005c004
        /// RTC setup register 0
        pub const SETUP_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Day of the month (1..31)
            DAY: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            /// Month (1..12)
            MONTH: u4,
            /// Year
            YEAR: u12,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x4005c008
        /// RTC setup register 1
        pub const SETUP_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Seconds
            SEC: u6,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// Minutes
            MIN: u6,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// Hours
            HOUR: u5,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            /// Day of the week: 1-Monday...0-Sunday ISO 8601 mod 7
            DOTW: u3,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x4005c00c
        /// RTC Control and status
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable RTC
            RTC_ENABLE: u1,
            /// RTC enabled (running)
            RTC_ACTIVE: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// Load RTC
            LOAD: u1,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            /// If set, leapyear is forced off.\n
            /// Useful for years divisible by 100 but not by 400
            FORCE_NOTLEAPYEAR: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
        }), base_address + 0xc);

        /// address: 0x4005c010
        /// Interrupt setup register 0
        pub const IRQ_SETUP_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Day of the month (1..31)
            DAY: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            /// Month (1..12)
            MONTH: u4,
            /// Year
            YEAR: u12,
            /// Enable day matching
            DAY_ENA: u1,
            /// Enable month matching
            MONTH_ENA: u1,
            /// Enable year matching
            YEAR_ENA: u1,
            reserved3: u1 = 0,
            /// Global match enable. Don't change any other value while this one is enabled
            MATCH_ENA: u1,
            MATCH_ACTIVE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
        }), base_address + 0x10);

        /// address: 0x4005c014
        /// Interrupt setup register 1
        pub const IRQ_SETUP_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Seconds
            SEC: u6,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// Minutes
            MIN: u6,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// Hours
            HOUR: u5,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            /// Day of the week
            DOTW: u3,
            reserved7: u1 = 0,
            /// Enable second matching
            SEC_ENA: u1,
            /// Enable minute matching
            MIN_ENA: u1,
            /// Enable hour matching
            HOUR_ENA: u1,
            /// Enable day of the week matching
            DOTW_ENA: u1,
        }), base_address + 0x14);

        /// address: 0x4005c018
        /// RTC register 1.
        pub const RTC_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Day of the month (1..31)
            DAY: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            /// Month (1..12)
            MONTH: u4,
            /// Year
            YEAR: u12,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x4005c01c
        /// RTC register 0\n
        /// Read this before RTC 1!
        pub const RTC_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Seconds
            SEC: u6,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// Minutes
            MIN: u6,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// Hours
            HOUR: u5,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            /// Day of the week
            DOTW: u3,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x1c);

        /// address: 0x4005c020
        /// Raw Interrupts
        pub const INTR = @intToPtr(*volatile Mmio(32, packed struct {
            RTC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x20);

        /// address: 0x4005c024
        /// Interrupt Enable
        pub const INTE = @intToPtr(*volatile Mmio(32, packed struct {
            RTC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x24);

        /// address: 0x4005c028
        /// Interrupt Force
        pub const INTF = @intToPtr(*volatile Mmio(32, packed struct {
            RTC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x28);

        /// address: 0x4005c02c
        /// Interrupt status after masking & forcing
        pub const INTS = @intToPtr(*volatile Mmio(32, packed struct {
            RTC: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
            padding30: u1 = 0,
        }), base_address + 0x2c);
    };
    pub const ROSC = struct {
        pub const base_address = 0x40060000;
        pub const version = "1";

        /// address: 0x40060000
        /// Ring Oscillator control
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Controls the number of delay stages in the ROSC ring\n
            /// LOW uses stages 0 to 7\n
            /// MEDIUM uses stages 0 to 5\n
            /// HIGH uses stages 0 to 3\n
            /// TOOHIGH uses stages 0 to 1 and should not be used because its frequency exceeds
            /// design specifications\n
            /// The clock output will not glitch when changing the range up one step at a time\n
            /// The clock output will glitch when changing the range down\n
            /// Note: the values here are gray coded which is why HIGH comes before TOOHIGH
            FREQ_RANGE: u12,
            /// On power-up this field is initialised to ENABLE\n
            /// The system clock must be switched to another source before setting this field to
            /// DISABLE otherwise the chip will lock up\n
            /// The 12-bit code is intended to give some protection against accidental writes.
            /// An invalid setting will enable the oscillator.
            ENABLE: u12,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40060004
        /// The FREQA & FREQB registers control the frequency by controlling the drive
        /// strength of each stage\n
        /// The drive strength has 4 levels determined by the number of bits set\n
        /// Increasing the number of bits set increases the drive strength and increases the
        /// oscillation frequency\n
        /// 0 bits set is the default drive strength\n
        /// 1 bit set doubles the drive strength\n
        /// 2 bits set triples drive strength\n
        /// 3 bits set quadruples drive strength
        pub const FREQA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stage 0 drive strength
            DS0: u3,
            reserved0: u1 = 0,
            /// Stage 1 drive strength
            DS1: u3,
            reserved1: u1 = 0,
            /// Stage 2 drive strength
            DS2: u3,
            reserved2: u1 = 0,
            /// Stage 3 drive strength
            DS3: u3,
            reserved3: u1 = 0,
            /// Set to 0x9696 to apply the settings\n
            /// Any other value in this field will set all drive strengths to 0
            PASSWD: u16,
        }), base_address + 0x4);

        /// address: 0x40060008
        /// For a detailed description see freqa register
        pub const FREQB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stage 4 drive strength
            DS4: u3,
            reserved0: u1 = 0,
            /// Stage 5 drive strength
            DS5: u3,
            reserved1: u1 = 0,
            /// Stage 6 drive strength
            DS6: u3,
            reserved2: u1 = 0,
            /// Stage 7 drive strength
            DS7: u3,
            reserved3: u1 = 0,
            /// Set to 0x9696 to apply the settings\n
            /// Any other value in this field will set all drive strengths to 0
            PASSWD: u16,
        }), base_address + 0x8);

        /// address: 0x4006000c
        /// Ring Oscillator pause control\n
        /// This is used to save power by pausing the ROSC\n
        /// On power-up this field is initialised to WAKE\n
        /// An invalid write will also select WAKE\n
        /// Warning: setup the irq before selecting dormant mode
        pub const DORMANT = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40060010
        /// Controls the output divider
        pub const DIV = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x10);

        /// address: 0x40060014
        /// Controls the phase shifted output
        pub const PHASE = @intToPtr(*volatile Mmio(32, packed struct {
            /// phase shift the phase-shifted output by SHIFT input clocks\n
            /// this can be changed on-the-fly\n
            /// must be set to 0 before setting div=1
            SHIFT: u2,
            /// invert the phase-shifted output\n
            /// this is ignored when div=1
            FLIP: u1,
            /// enable the phase-shifted output\n
            /// this can be changed on-the-fly
            ENABLE: u1,
            /// set to 0xaa\n
            /// any other value enables the output with shift=0
            PASSWD: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x14);

        /// address: 0x40060018
        /// Ring Oscillator Status
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            /// Oscillator is enabled but not necessarily running and stable\n
            /// this resets to 0 but transitions to 1 during chip startup
            ENABLED: u1,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            /// post-divider is running\n
            /// this resets to 0 but transitions to 1 during chip startup
            DIV_RUNNING: u1,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            reserved18: u1 = 0,
            reserved19: u1 = 0,
            reserved20: u1 = 0,
            reserved21: u1 = 0,
            /// An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or FREQA or
            /// FREQB or DIV or PHASE or DORMANT
            BADWRITE: u1,
            reserved22: u1 = 0,
            reserved23: u1 = 0,
            reserved24: u1 = 0,
            reserved25: u1 = 0,
            reserved26: u1 = 0,
            reserved27: u1 = 0,
            /// Oscillator is running and stable
            STABLE: u1,
        }), base_address + 0x18);

        /// address: 0x4006001c
        /// This just reads the state of the oscillator output so randomness is compromised
        /// if the ring oscillator is stopped or run at a harmonic of the bus frequency
        pub const RANDOMBIT = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x1c);

        /// address: 0x40060020
        /// A down counter running at the ROSC frequency which counts to zero and stops.\n
        /// To start the counter write a non-zero value.\n
        /// Can be used for short software pauses when setting up time sensitive hardware.
        pub const COUNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x20);
    };

    /// control and status for on-chip voltage regulator and chip level reset subsystem
    pub const VREG_AND_CHIP_RESET = struct {
        pub const base_address = 0x40064000;
        pub const version = "1";

        /// address: 0x40064000
        /// Voltage regulator control and status
        pub const VREG = @intToPtr(*volatile Mmio(32, packed struct {
            /// enable\n
            /// 0=not enabled, 1=enabled
            EN: u1,
            /// high impedance mode select\n
            /// 0=not in high impedance mode, 1=in high impedance mode
            HIZ: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// output voltage select\n
            /// 0000 to 0101 - 0.80V\n
            /// 0110 - 0.85V\n
            /// 0111 - 0.90V\n
            /// 1000 - 0.95V\n
            /// 1001 - 1.00V\n
            /// 1010 - 1.05V\n
            /// 1011 - 1.10V (default)\n
            /// 1100 - 1.15V\n
            /// 1101 - 1.20V\n
            /// 1110 - 1.25V\n
            /// 1111 - 1.30V
            VSEL: u4,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            /// regulation status\n
            /// 0=not in regulation, 1=in regulation
            ROK: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x40064004
        /// brown-out detection control
        pub const BOD = @intToPtr(*volatile Mmio(32, packed struct {
            /// enable\n
            /// 0=not enabled, 1=enabled
            EN: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            /// threshold select\n
            /// 0000 - 0.473V\n
            /// 0001 - 0.516V\n
            /// 0010 - 0.559V\n
            /// 0011 - 0.602V\n
            /// 0100 - 0.645V\n
            /// 0101 - 0.688V\n
            /// 0110 - 0.731V\n
            /// 0111 - 0.774V\n
            /// 1000 - 0.817V\n
            /// 1001 - 0.860V (default)\n
            /// 1010 - 0.903V\n
            /// 1011 - 0.946V\n
            /// 1100 - 0.989V\n
            /// 1101 - 1.032V\n
            /// 1110 - 1.075V\n
            /// 1111 - 1.118V
            VSEL: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x40064008
        /// Chip reset control and status
        pub const CHIP_RESET = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Last reset was from the power-on reset or brown-out detection blocks
            HAD_POR: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            /// Last reset was from the RUN pin
            HAD_RUN: u1,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            /// Last reset was from the debug port
            HAD_PSM_RESTART: u1,
            reserved18: u1 = 0,
            reserved19: u1 = 0,
            reserved20: u1 = 0,
            /// This is set by psm_restart from the debugger.\n
            /// Its purpose is to branch bootcode to a safe mode when the debugger has issued a
            /// psm_restart in order to recover from a boot lock-up.\n
            /// In the safe mode the debugger can repair the boot code, clear this flag then
            /// reboot the processor.
            PSM_RESTART_FLAG: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
        }), base_address + 0x8);
    };

    /// Testbench manager. Allows the programmer to know what platform their software is
    /// running on.
    pub const TBMAN = struct {
        pub const base_address = 0x4006c000;
        pub const version = "1";

        /// address: 0x4006c000
        /// Indicates the type of platform in use
        pub const PLATFORM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the platform is an ASIC
            ASIC: u1,
            /// Indicates the platform is an FPGA
            FPGA: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
        }), base_address + 0x0);
    };

    /// DMA with separate read and write masters
    pub const DMA = struct {
        pub const base_address = 0x50000000;
        pub const version = "1";

        /// address: 0x50000000
        /// DMA Channel 0 Read Address pointer\n
        /// This register updates automatically each time a read completes. The current
        /// value is the next address to be read by this channel.
        pub const CH0_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x50000004
        /// DMA Channel 0 Write Address pointer\n
        /// This register updates automatically each time a write completes. The current
        /// value is the next address to be written by this channel.
        pub const CH0_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x50000008
        /// DMA Channel 0 Transfer Count\n
        /// Program the number of bus transfers a channel will perform before halting. Note
        /// that, if transfers are larger than one byte in size, this is not equal to the
        /// number of bytes transferred (see CTRL_DATA_SIZE).\n\n
        /// When the channel is active, reading this register shows the number of transfers
        /// remaining, updating automatically each time a write transfer completes.\n\n
        /// Writing this register sets the RELOAD value for the transfer counter. Each time
        /// this channel is triggered, the RELOAD value is copied into the live transfer
        /// counter. The channel can be started multiple times, and will perform the same
        /// number of transfers each time, as programmed by most recent write.\n\n
        /// The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
        /// trigger, the written value is used immediately as the length of the new transfer
        /// sequence, as well as being written to RELOAD.
        pub const CH0_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x5000000c
        /// DMA Channel 0 Control and Status
        pub const CH0_CTRL_TRIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel Enable.\n
            /// When 1, the channel will respond to triggering events, which will cause it to
            /// become BUSY and start transferring data. When 0, the channel will ignore
            /// triggers, stop issuing transfers, and pause the current transfer sequence (i.e.
            /// BUSY will remain high if already high)
            EN: u1,
            /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in
            /// each scheduling round, all high priority channels are considered first, and then
            /// only a single low priority channel, before returning to the high priority
            /// channels.\n\n
            /// This only affects the order in which the DMA schedules channels. The DMA's bus
            /// priority is not changed. If the DMA is not saturated then a low priority channel
            /// will see no loss of throughput.
            HIGH_PRIORITY: u1,
            /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR
            /// advance by this amount (1/2/4 bytes) with each transfer.
            DATA_SIZE: u2,
            /// If 1, the read address increments with each transfer. If 0, each read is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for peripheral-to-memory transfers.
            INCR_READ: u1,
            /// If 1, the write address increments with each transfer. If 0, each write is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for memory-to-peripheral transfers.
            INCR_WRITE: u1,
            /// Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower
            /// n bits of the address will change. This wraps the address on a (1 << n) byte
            /// boundary, facilitating access to naturally-aligned ring buffers.\n\n
            /// Ring sizes between 2 and 32768 bytes are possible. This can apply to either read
            /// or write addresses, based on value of RING_SEL.
            RING_SIZE: u4,
            /// Select whether RING_SIZE applies to read or write addresses.\n
            /// If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write
            /// addresses are wrapped.
            RING_SEL: u1,
            /// When this channel completes, it will trigger the channel indicated by CHAIN_TO.
            /// Disable by setting CHAIN_TO = _(this channel)_.\n
            /// Reset value is equal to channel number (0).
            CHAIN_TO: u4,
            /// Select a Transfer Request signal.\n
            /// The channel uses the transfer request signal to pace its data transfer rate.
            /// Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request
            /// from the system).\n
            /// 0x0 to 0x3a -> select DREQ n as TREQ
            TREQ_SEL: u6,
            /// In QUIET mode, the channel does not generate IRQs at the end of every transfer
            /// block. Instead, an IRQ is raised when NULL is written to a trigger register,
            /// indicating the end of a control block chain.\n\n
            /// This reduces the number of interrupts to be serviced by the CPU when
            /// transferring a DMA chain of many small control blocks.
            IRQ_QUIET: u1,
            /// Apply byte-swap transformation to DMA data.\n
            /// For byte data, this has no effect. For halfword data, the two bytes of each
            /// halfword are swapped. For word data, the four bytes of each word are swapped to
            /// reverse order.
            BSWAP: u1,
            /// If 1, this channel's data transfers are visible to the sniff hardware, and each
            /// transfer will advance the state of the checksum. This only applies if the sniff
            /// hardware is enabled, and has this channel selected.\n\n
            /// This allows checksum to be enabled or disabled on a per-control- block basis.
            SNIFF_EN: u1,
            /// This flag goes high when the channel starts a new transfer sequence, and low
            /// when the last transfer of that sequence completes. Clearing EN while BUSY is
            /// high pauses the channel, and BUSY will stay high while paused.\n\n
            /// To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
            BUSY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// If 1, the channel received a write bus error. Write one to clear.\n
            /// WRITE_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 5 transfers later)
            WRITE_ERROR: u1,
            /// If 1, the channel received a read bus error. Write one to clear.\n
            /// READ_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 3 transfers later)
            READ_ERROR: u1,
            /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it
            /// encounters any bus error, and always raises its channel IRQ flag.
            AHB_ERROR: u1,
        }), base_address + 0xc);

        /// address: 0x50000010
        /// Alias for channel 0 CTRL register
        pub const CH0_AL1_CTRL = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x50000014
        /// Alias for channel 0 READ_ADDR register
        pub const CH0_AL1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x50000018
        /// Alias for channel 0 WRITE_ADDR register
        pub const CH0_AL1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x18);

        /// address: 0x5000001c
        /// Alias for channel 0 TRANS_COUNT register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH0_AL1_TRANS_COUNT_TRIG = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x50000020
        /// Alias for channel 0 CTRL register
        pub const CH0_AL2_CTRL = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x50000024
        /// Alias for channel 0 TRANS_COUNT register
        pub const CH0_AL2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x50000028
        /// Alias for channel 0 READ_ADDR register
        pub const CH0_AL2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x28);

        /// address: 0x5000002c
        /// Alias for channel 0 WRITE_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH0_AL2_WRITE_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x50000030
        /// Alias for channel 0 CTRL register
        pub const CH0_AL3_CTRL = @intToPtr(*volatile u32, base_address + 0x30);

        /// address: 0x50000034
        /// Alias for channel 0 WRITE_ADDR register
        pub const CH0_AL3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x34);

        /// address: 0x50000038
        /// Alias for channel 0 TRANS_COUNT register
        pub const CH0_AL3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x38);

        /// address: 0x5000003c
        /// Alias for channel 0 READ_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH0_AL3_READ_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x3c);

        /// address: 0x50000040
        /// DMA Channel 1 Read Address pointer\n
        /// This register updates automatically each time a read completes. The current
        /// value is the next address to be read by this channel.
        pub const CH1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x40);

        /// address: 0x50000044
        /// DMA Channel 1 Write Address pointer\n
        /// This register updates automatically each time a write completes. The current
        /// value is the next address to be written by this channel.
        pub const CH1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x44);

        /// address: 0x50000048
        /// DMA Channel 1 Transfer Count\n
        /// Program the number of bus transfers a channel will perform before halting. Note
        /// that, if transfers are larger than one byte in size, this is not equal to the
        /// number of bytes transferred (see CTRL_DATA_SIZE).\n\n
        /// When the channel is active, reading this register shows the number of transfers
        /// remaining, updating automatically each time a write transfer completes.\n\n
        /// Writing this register sets the RELOAD value for the transfer counter. Each time
        /// this channel is triggered, the RELOAD value is copied into the live transfer
        /// counter. The channel can be started multiple times, and will perform the same
        /// number of transfers each time, as programmed by most recent write.\n\n
        /// The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
        /// trigger, the written value is used immediately as the length of the new transfer
        /// sequence, as well as being written to RELOAD.
        pub const CH1_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x48);

        /// address: 0x5000004c
        /// DMA Channel 1 Control and Status
        pub const CH1_CTRL_TRIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel Enable.\n
            /// When 1, the channel will respond to triggering events, which will cause it to
            /// become BUSY and start transferring data. When 0, the channel will ignore
            /// triggers, stop issuing transfers, and pause the current transfer sequence (i.e.
            /// BUSY will remain high if already high)
            EN: u1,
            /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in
            /// each scheduling round, all high priority channels are considered first, and then
            /// only a single low priority channel, before returning to the high priority
            /// channels.\n\n
            /// This only affects the order in which the DMA schedules channels. The DMA's bus
            /// priority is not changed. If the DMA is not saturated then a low priority channel
            /// will see no loss of throughput.
            HIGH_PRIORITY: u1,
            /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR
            /// advance by this amount (1/2/4 bytes) with each transfer.
            DATA_SIZE: u2,
            /// If 1, the read address increments with each transfer. If 0, each read is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for peripheral-to-memory transfers.
            INCR_READ: u1,
            /// If 1, the write address increments with each transfer. If 0, each write is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for memory-to-peripheral transfers.
            INCR_WRITE: u1,
            /// Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower
            /// n bits of the address will change. This wraps the address on a (1 << n) byte
            /// boundary, facilitating access to naturally-aligned ring buffers.\n\n
            /// Ring sizes between 2 and 32768 bytes are possible. This can apply to either read
            /// or write addresses, based on value of RING_SEL.
            RING_SIZE: u4,
            /// Select whether RING_SIZE applies to read or write addresses.\n
            /// If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write
            /// addresses are wrapped.
            RING_SEL: u1,
            /// When this channel completes, it will trigger the channel indicated by CHAIN_TO.
            /// Disable by setting CHAIN_TO = _(this channel)_.\n
            /// Reset value is equal to channel number (1).
            CHAIN_TO: u4,
            /// Select a Transfer Request signal.\n
            /// The channel uses the transfer request signal to pace its data transfer rate.
            /// Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request
            /// from the system).\n
            /// 0x0 to 0x3a -> select DREQ n as TREQ
            TREQ_SEL: u6,
            /// In QUIET mode, the channel does not generate IRQs at the end of every transfer
            /// block. Instead, an IRQ is raised when NULL is written to a trigger register,
            /// indicating the end of a control block chain.\n\n
            /// This reduces the number of interrupts to be serviced by the CPU when
            /// transferring a DMA chain of many small control blocks.
            IRQ_QUIET: u1,
            /// Apply byte-swap transformation to DMA data.\n
            /// For byte data, this has no effect. For halfword data, the two bytes of each
            /// halfword are swapped. For word data, the four bytes of each word are swapped to
            /// reverse order.
            BSWAP: u1,
            /// If 1, this channel's data transfers are visible to the sniff hardware, and each
            /// transfer will advance the state of the checksum. This only applies if the sniff
            /// hardware is enabled, and has this channel selected.\n\n
            /// This allows checksum to be enabled or disabled on a per-control- block basis.
            SNIFF_EN: u1,
            /// This flag goes high when the channel starts a new transfer sequence, and low
            /// when the last transfer of that sequence completes. Clearing EN while BUSY is
            /// high pauses the channel, and BUSY will stay high while paused.\n\n
            /// To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
            BUSY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// If 1, the channel received a write bus error. Write one to clear.\n
            /// WRITE_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 5 transfers later)
            WRITE_ERROR: u1,
            /// If 1, the channel received a read bus error. Write one to clear.\n
            /// READ_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 3 transfers later)
            READ_ERROR: u1,
            /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it
            /// encounters any bus error, and always raises its channel IRQ flag.
            AHB_ERROR: u1,
        }), base_address + 0x4c);

        /// address: 0x50000050
        /// Alias for channel 1 CTRL register
        pub const CH1_AL1_CTRL = @intToPtr(*volatile u32, base_address + 0x50);

        /// address: 0x50000054
        /// Alias for channel 1 READ_ADDR register
        pub const CH1_AL1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x54);

        /// address: 0x50000058
        /// Alias for channel 1 WRITE_ADDR register
        pub const CH1_AL1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x58);

        /// address: 0x5000005c
        /// Alias for channel 1 TRANS_COUNT register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH1_AL1_TRANS_COUNT_TRIG = @intToPtr(*volatile u32, base_address + 0x5c);

        /// address: 0x50000060
        /// Alias for channel 1 CTRL register
        pub const CH1_AL2_CTRL = @intToPtr(*volatile u32, base_address + 0x60);

        /// address: 0x50000064
        /// Alias for channel 1 TRANS_COUNT register
        pub const CH1_AL2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x64);

        /// address: 0x50000068
        /// Alias for channel 1 READ_ADDR register
        pub const CH1_AL2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x68);

        /// address: 0x5000006c
        /// Alias for channel 1 WRITE_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH1_AL2_WRITE_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x6c);

        /// address: 0x50000070
        /// Alias for channel 1 CTRL register
        pub const CH1_AL3_CTRL = @intToPtr(*volatile u32, base_address + 0x70);

        /// address: 0x50000074
        /// Alias for channel 1 WRITE_ADDR register
        pub const CH1_AL3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x74);

        /// address: 0x50000078
        /// Alias for channel 1 TRANS_COUNT register
        pub const CH1_AL3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x78);

        /// address: 0x5000007c
        /// Alias for channel 1 READ_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH1_AL3_READ_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x7c);

        /// address: 0x50000080
        /// DMA Channel 2 Read Address pointer\n
        /// This register updates automatically each time a read completes. The current
        /// value is the next address to be read by this channel.
        pub const CH2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x80);

        /// address: 0x50000084
        /// DMA Channel 2 Write Address pointer\n
        /// This register updates automatically each time a write completes. The current
        /// value is the next address to be written by this channel.
        pub const CH2_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x84);

        /// address: 0x50000088
        /// DMA Channel 2 Transfer Count\n
        /// Program the number of bus transfers a channel will perform before halting. Note
        /// that, if transfers are larger than one byte in size, this is not equal to the
        /// number of bytes transferred (see CTRL_DATA_SIZE).\n\n
        /// When the channel is active, reading this register shows the number of transfers
        /// remaining, updating automatically each time a write transfer completes.\n\n
        /// Writing this register sets the RELOAD value for the transfer counter. Each time
        /// this channel is triggered, the RELOAD value is copied into the live transfer
        /// counter. The channel can be started multiple times, and will perform the same
        /// number of transfers each time, as programmed by most recent write.\n\n
        /// The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
        /// trigger, the written value is used immediately as the length of the new transfer
        /// sequence, as well as being written to RELOAD.
        pub const CH2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x88);

        /// address: 0x5000008c
        /// DMA Channel 2 Control and Status
        pub const CH2_CTRL_TRIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel Enable.\n
            /// When 1, the channel will respond to triggering events, which will cause it to
            /// become BUSY and start transferring data. When 0, the channel will ignore
            /// triggers, stop issuing transfers, and pause the current transfer sequence (i.e.
            /// BUSY will remain high if already high)
            EN: u1,
            /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in
            /// each scheduling round, all high priority channels are considered first, and then
            /// only a single low priority channel, before returning to the high priority
            /// channels.\n\n
            /// This only affects the order in which the DMA schedules channels. The DMA's bus
            /// priority is not changed. If the DMA is not saturated then a low priority channel
            /// will see no loss of throughput.
            HIGH_PRIORITY: u1,
            /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR
            /// advance by this amount (1/2/4 bytes) with each transfer.
            DATA_SIZE: u2,
            /// If 1, the read address increments with each transfer. If 0, each read is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for peripheral-to-memory transfers.
            INCR_READ: u1,
            /// If 1, the write address increments with each transfer. If 0, each write is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for memory-to-peripheral transfers.
            INCR_WRITE: u1,
            /// Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower
            /// n bits of the address will change. This wraps the address on a (1 << n) byte
            /// boundary, facilitating access to naturally-aligned ring buffers.\n\n
            /// Ring sizes between 2 and 32768 bytes are possible. This can apply to either read
            /// or write addresses, based on value of RING_SEL.
            RING_SIZE: u4,
            /// Select whether RING_SIZE applies to read or write addresses.\n
            /// If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write
            /// addresses are wrapped.
            RING_SEL: u1,
            /// When this channel completes, it will trigger the channel indicated by CHAIN_TO.
            /// Disable by setting CHAIN_TO = _(this channel)_.\n
            /// Reset value is equal to channel number (2).
            CHAIN_TO: u4,
            /// Select a Transfer Request signal.\n
            /// The channel uses the transfer request signal to pace its data transfer rate.
            /// Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request
            /// from the system).\n
            /// 0x0 to 0x3a -> select DREQ n as TREQ
            TREQ_SEL: u6,
            /// In QUIET mode, the channel does not generate IRQs at the end of every transfer
            /// block. Instead, an IRQ is raised when NULL is written to a trigger register,
            /// indicating the end of a control block chain.\n\n
            /// This reduces the number of interrupts to be serviced by the CPU when
            /// transferring a DMA chain of many small control blocks.
            IRQ_QUIET: u1,
            /// Apply byte-swap transformation to DMA data.\n
            /// For byte data, this has no effect. For halfword data, the two bytes of each
            /// halfword are swapped. For word data, the four bytes of each word are swapped to
            /// reverse order.
            BSWAP: u1,
            /// If 1, this channel's data transfers are visible to the sniff hardware, and each
            /// transfer will advance the state of the checksum. This only applies if the sniff
            /// hardware is enabled, and has this channel selected.\n\n
            /// This allows checksum to be enabled or disabled on a per-control- block basis.
            SNIFF_EN: u1,
            /// This flag goes high when the channel starts a new transfer sequence, and low
            /// when the last transfer of that sequence completes. Clearing EN while BUSY is
            /// high pauses the channel, and BUSY will stay high while paused.\n\n
            /// To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
            BUSY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// If 1, the channel received a write bus error. Write one to clear.\n
            /// WRITE_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 5 transfers later)
            WRITE_ERROR: u1,
            /// If 1, the channel received a read bus error. Write one to clear.\n
            /// READ_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 3 transfers later)
            READ_ERROR: u1,
            /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it
            /// encounters any bus error, and always raises its channel IRQ flag.
            AHB_ERROR: u1,
        }), base_address + 0x8c);

        /// address: 0x50000090
        /// Alias for channel 2 CTRL register
        pub const CH2_AL1_CTRL = @intToPtr(*volatile u32, base_address + 0x90);

        /// address: 0x50000094
        /// Alias for channel 2 READ_ADDR register
        pub const CH2_AL1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x94);

        /// address: 0x50000098
        /// Alias for channel 2 WRITE_ADDR register
        pub const CH2_AL1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x98);

        /// address: 0x5000009c
        /// Alias for channel 2 TRANS_COUNT register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH2_AL1_TRANS_COUNT_TRIG = @intToPtr(*volatile u32, base_address + 0x9c);

        /// address: 0x500000a0
        /// Alias for channel 2 CTRL register
        pub const CH2_AL2_CTRL = @intToPtr(*volatile u32, base_address + 0xa0);

        /// address: 0x500000a4
        /// Alias for channel 2 TRANS_COUNT register
        pub const CH2_AL2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0xa4);

        /// address: 0x500000a8
        /// Alias for channel 2 READ_ADDR register
        pub const CH2_AL2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0xa8);

        /// address: 0x500000ac
        /// Alias for channel 2 WRITE_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH2_AL2_WRITE_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0xac);

        /// address: 0x500000b0
        /// Alias for channel 2 CTRL register
        pub const CH2_AL3_CTRL = @intToPtr(*volatile u32, base_address + 0xb0);

        /// address: 0x500000b4
        /// Alias for channel 2 WRITE_ADDR register
        pub const CH2_AL3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0xb4);

        /// address: 0x500000b8
        /// Alias for channel 2 TRANS_COUNT register
        pub const CH2_AL3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0xb8);

        /// address: 0x500000bc
        /// Alias for channel 2 READ_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH2_AL3_READ_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0xbc);

        /// address: 0x500000c0
        /// DMA Channel 3 Read Address pointer\n
        /// This register updates automatically each time a read completes. The current
        /// value is the next address to be read by this channel.
        pub const CH3_READ_ADDR = @intToPtr(*volatile u32, base_address + 0xc0);

        /// address: 0x500000c4
        /// DMA Channel 3 Write Address pointer\n
        /// This register updates automatically each time a write completes. The current
        /// value is the next address to be written by this channel.
        pub const CH3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0xc4);

        /// address: 0x500000c8
        /// DMA Channel 3 Transfer Count\n
        /// Program the number of bus transfers a channel will perform before halting. Note
        /// that, if transfers are larger than one byte in size, this is not equal to the
        /// number of bytes transferred (see CTRL_DATA_SIZE).\n\n
        /// When the channel is active, reading this register shows the number of transfers
        /// remaining, updating automatically each time a write transfer completes.\n\n
        /// Writing this register sets the RELOAD value for the transfer counter. Each time
        /// this channel is triggered, the RELOAD value is copied into the live transfer
        /// counter. The channel can be started multiple times, and will perform the same
        /// number of transfers each time, as programmed by most recent write.\n\n
        /// The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
        /// trigger, the written value is used immediately as the length of the new transfer
        /// sequence, as well as being written to RELOAD.
        pub const CH3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0xc8);

        /// address: 0x500000cc
        /// DMA Channel 3 Control and Status
        pub const CH3_CTRL_TRIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel Enable.\n
            /// When 1, the channel will respond to triggering events, which will cause it to
            /// become BUSY and start transferring data. When 0, the channel will ignore
            /// triggers, stop issuing transfers, and pause the current transfer sequence (i.e.
            /// BUSY will remain high if already high)
            EN: u1,
            /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in
            /// each scheduling round, all high priority channels are considered first, and then
            /// only a single low priority channel, before returning to the high priority
            /// channels.\n\n
            /// This only affects the order in which the DMA schedules channels. The DMA's bus
            /// priority is not changed. If the DMA is not saturated then a low priority channel
            /// will see no loss of throughput.
            HIGH_PRIORITY: u1,
            /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR
            /// advance by this amount (1/2/4 bytes) with each transfer.
            DATA_SIZE: u2,
            /// If 1, the read address increments with each transfer. If 0, each read is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for peripheral-to-memory transfers.
            INCR_READ: u1,
            /// If 1, the write address increments with each transfer. If 0, each write is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for memory-to-peripheral transfers.
            INCR_WRITE: u1,
            /// Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower
            /// n bits of the address will change. This wraps the address on a (1 << n) byte
            /// boundary, facilitating access to naturally-aligned ring buffers.\n\n
            /// Ring sizes between 2 and 32768 bytes are possible. This can apply to either read
            /// or write addresses, based on value of RING_SEL.
            RING_SIZE: u4,
            /// Select whether RING_SIZE applies to read or write addresses.\n
            /// If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write
            /// addresses are wrapped.
            RING_SEL: u1,
            /// When this channel completes, it will trigger the channel indicated by CHAIN_TO.
            /// Disable by setting CHAIN_TO = _(this channel)_.\n
            /// Reset value is equal to channel number (3).
            CHAIN_TO: u4,
            /// Select a Transfer Request signal.\n
            /// The channel uses the transfer request signal to pace its data transfer rate.
            /// Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request
            /// from the system).\n
            /// 0x0 to 0x3a -> select DREQ n as TREQ
            TREQ_SEL: u6,
            /// In QUIET mode, the channel does not generate IRQs at the end of every transfer
            /// block. Instead, an IRQ is raised when NULL is written to a trigger register,
            /// indicating the end of a control block chain.\n\n
            /// This reduces the number of interrupts to be serviced by the CPU when
            /// transferring a DMA chain of many small control blocks.
            IRQ_QUIET: u1,
            /// Apply byte-swap transformation to DMA data.\n
            /// For byte data, this has no effect. For halfword data, the two bytes of each
            /// halfword are swapped. For word data, the four bytes of each word are swapped to
            /// reverse order.
            BSWAP: u1,
            /// If 1, this channel's data transfers are visible to the sniff hardware, and each
            /// transfer will advance the state of the checksum. This only applies if the sniff
            /// hardware is enabled, and has this channel selected.\n\n
            /// This allows checksum to be enabled or disabled on a per-control- block basis.
            SNIFF_EN: u1,
            /// This flag goes high when the channel starts a new transfer sequence, and low
            /// when the last transfer of that sequence completes. Clearing EN while BUSY is
            /// high pauses the channel, and BUSY will stay high while paused.\n\n
            /// To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
            BUSY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// If 1, the channel received a write bus error. Write one to clear.\n
            /// WRITE_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 5 transfers later)
            WRITE_ERROR: u1,
            /// If 1, the channel received a read bus error. Write one to clear.\n
            /// READ_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 3 transfers later)
            READ_ERROR: u1,
            /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it
            /// encounters any bus error, and always raises its channel IRQ flag.
            AHB_ERROR: u1,
        }), base_address + 0xcc);

        /// address: 0x500000d0
        /// Alias for channel 3 CTRL register
        pub const CH3_AL1_CTRL = @intToPtr(*volatile u32, base_address + 0xd0);

        /// address: 0x500000d4
        /// Alias for channel 3 READ_ADDR register
        pub const CH3_AL1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0xd4);

        /// address: 0x500000d8
        /// Alias for channel 3 WRITE_ADDR register
        pub const CH3_AL1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0xd8);

        /// address: 0x500000dc
        /// Alias for channel 3 TRANS_COUNT register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH3_AL1_TRANS_COUNT_TRIG = @intToPtr(*volatile u32, base_address + 0xdc);

        /// address: 0x500000e0
        /// Alias for channel 3 CTRL register
        pub const CH3_AL2_CTRL = @intToPtr(*volatile u32, base_address + 0xe0);

        /// address: 0x500000e4
        /// Alias for channel 3 TRANS_COUNT register
        pub const CH3_AL2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0xe4);

        /// address: 0x500000e8
        /// Alias for channel 3 READ_ADDR register
        pub const CH3_AL2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0xe8);

        /// address: 0x500000ec
        /// Alias for channel 3 WRITE_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH3_AL2_WRITE_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0xec);

        /// address: 0x500000f0
        /// Alias for channel 3 CTRL register
        pub const CH3_AL3_CTRL = @intToPtr(*volatile u32, base_address + 0xf0);

        /// address: 0x500000f4
        /// Alias for channel 3 WRITE_ADDR register
        pub const CH3_AL3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0xf4);

        /// address: 0x500000f8
        /// Alias for channel 3 TRANS_COUNT register
        pub const CH3_AL3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0xf8);

        /// address: 0x500000fc
        /// Alias for channel 3 READ_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH3_AL3_READ_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0xfc);

        /// address: 0x50000100
        /// DMA Channel 4 Read Address pointer\n
        /// This register updates automatically each time a read completes. The current
        /// value is the next address to be read by this channel.
        pub const CH4_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x50000104
        /// DMA Channel 4 Write Address pointer\n
        /// This register updates automatically each time a write completes. The current
        /// value is the next address to be written by this channel.
        pub const CH4_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x50000108
        /// DMA Channel 4 Transfer Count\n
        /// Program the number of bus transfers a channel will perform before halting. Note
        /// that, if transfers are larger than one byte in size, this is not equal to the
        /// number of bytes transferred (see CTRL_DATA_SIZE).\n\n
        /// When the channel is active, reading this register shows the number of transfers
        /// remaining, updating automatically each time a write transfer completes.\n\n
        /// Writing this register sets the RELOAD value for the transfer counter. Each time
        /// this channel is triggered, the RELOAD value is copied into the live transfer
        /// counter. The channel can be started multiple times, and will perform the same
        /// number of transfers each time, as programmed by most recent write.\n\n
        /// The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
        /// trigger, the written value is used immediately as the length of the new transfer
        /// sequence, as well as being written to RELOAD.
        pub const CH4_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x5000010c
        /// DMA Channel 4 Control and Status
        pub const CH4_CTRL_TRIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel Enable.\n
            /// When 1, the channel will respond to triggering events, which will cause it to
            /// become BUSY and start transferring data. When 0, the channel will ignore
            /// triggers, stop issuing transfers, and pause the current transfer sequence (i.e.
            /// BUSY will remain high if already high)
            EN: u1,
            /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in
            /// each scheduling round, all high priority channels are considered first, and then
            /// only a single low priority channel, before returning to the high priority
            /// channels.\n\n
            /// This only affects the order in which the DMA schedules channels. The DMA's bus
            /// priority is not changed. If the DMA is not saturated then a low priority channel
            /// will see no loss of throughput.
            HIGH_PRIORITY: u1,
            /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR
            /// advance by this amount (1/2/4 bytes) with each transfer.
            DATA_SIZE: u2,
            /// If 1, the read address increments with each transfer. If 0, each read is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for peripheral-to-memory transfers.
            INCR_READ: u1,
            /// If 1, the write address increments with each transfer. If 0, each write is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for memory-to-peripheral transfers.
            INCR_WRITE: u1,
            /// Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower
            /// n bits of the address will change. This wraps the address on a (1 << n) byte
            /// boundary, facilitating access to naturally-aligned ring buffers.\n\n
            /// Ring sizes between 2 and 32768 bytes are possible. This can apply to either read
            /// or write addresses, based on value of RING_SEL.
            RING_SIZE: u4,
            /// Select whether RING_SIZE applies to read or write addresses.\n
            /// If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write
            /// addresses are wrapped.
            RING_SEL: u1,
            /// When this channel completes, it will trigger the channel indicated by CHAIN_TO.
            /// Disable by setting CHAIN_TO = _(this channel)_.\n
            /// Reset value is equal to channel number (4).
            CHAIN_TO: u4,
            /// Select a Transfer Request signal.\n
            /// The channel uses the transfer request signal to pace its data transfer rate.
            /// Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request
            /// from the system).\n
            /// 0x0 to 0x3a -> select DREQ n as TREQ
            TREQ_SEL: u6,
            /// In QUIET mode, the channel does not generate IRQs at the end of every transfer
            /// block. Instead, an IRQ is raised when NULL is written to a trigger register,
            /// indicating the end of a control block chain.\n\n
            /// This reduces the number of interrupts to be serviced by the CPU when
            /// transferring a DMA chain of many small control blocks.
            IRQ_QUIET: u1,
            /// Apply byte-swap transformation to DMA data.\n
            /// For byte data, this has no effect. For halfword data, the two bytes of each
            /// halfword are swapped. For word data, the four bytes of each word are swapped to
            /// reverse order.
            BSWAP: u1,
            /// If 1, this channel's data transfers are visible to the sniff hardware, and each
            /// transfer will advance the state of the checksum. This only applies if the sniff
            /// hardware is enabled, and has this channel selected.\n\n
            /// This allows checksum to be enabled or disabled on a per-control- block basis.
            SNIFF_EN: u1,
            /// This flag goes high when the channel starts a new transfer sequence, and low
            /// when the last transfer of that sequence completes. Clearing EN while BUSY is
            /// high pauses the channel, and BUSY will stay high while paused.\n\n
            /// To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
            BUSY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// If 1, the channel received a write bus error. Write one to clear.\n
            /// WRITE_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 5 transfers later)
            WRITE_ERROR: u1,
            /// If 1, the channel received a read bus error. Write one to clear.\n
            /// READ_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 3 transfers later)
            READ_ERROR: u1,
            /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it
            /// encounters any bus error, and always raises its channel IRQ flag.
            AHB_ERROR: u1,
        }), base_address + 0x10c);

        /// address: 0x50000110
        /// Alias for channel 4 CTRL register
        pub const CH4_AL1_CTRL = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x50000114
        /// Alias for channel 4 READ_ADDR register
        pub const CH4_AL1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x114);

        /// address: 0x50000118
        /// Alias for channel 4 WRITE_ADDR register
        pub const CH4_AL1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x118);

        /// address: 0x5000011c
        /// Alias for channel 4 TRANS_COUNT register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH4_AL1_TRANS_COUNT_TRIG = @intToPtr(*volatile u32, base_address + 0x11c);

        /// address: 0x50000120
        /// Alias for channel 4 CTRL register
        pub const CH4_AL2_CTRL = @intToPtr(*volatile u32, base_address + 0x120);

        /// address: 0x50000124
        /// Alias for channel 4 TRANS_COUNT register
        pub const CH4_AL2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x124);

        /// address: 0x50000128
        /// Alias for channel 4 READ_ADDR register
        pub const CH4_AL2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x128);

        /// address: 0x5000012c
        /// Alias for channel 4 WRITE_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH4_AL2_WRITE_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x12c);

        /// address: 0x50000130
        /// Alias for channel 4 CTRL register
        pub const CH4_AL3_CTRL = @intToPtr(*volatile u32, base_address + 0x130);

        /// address: 0x50000134
        /// Alias for channel 4 WRITE_ADDR register
        pub const CH4_AL3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x134);

        /// address: 0x50000138
        /// Alias for channel 4 TRANS_COUNT register
        pub const CH4_AL3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x138);

        /// address: 0x5000013c
        /// Alias for channel 4 READ_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH4_AL3_READ_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x13c);

        /// address: 0x50000140
        /// DMA Channel 5 Read Address pointer\n
        /// This register updates automatically each time a read completes. The current
        /// value is the next address to be read by this channel.
        pub const CH5_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x140);

        /// address: 0x50000144
        /// DMA Channel 5 Write Address pointer\n
        /// This register updates automatically each time a write completes. The current
        /// value is the next address to be written by this channel.
        pub const CH5_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x144);

        /// address: 0x50000148
        /// DMA Channel 5 Transfer Count\n
        /// Program the number of bus transfers a channel will perform before halting. Note
        /// that, if transfers are larger than one byte in size, this is not equal to the
        /// number of bytes transferred (see CTRL_DATA_SIZE).\n\n
        /// When the channel is active, reading this register shows the number of transfers
        /// remaining, updating automatically each time a write transfer completes.\n\n
        /// Writing this register sets the RELOAD value for the transfer counter. Each time
        /// this channel is triggered, the RELOAD value is copied into the live transfer
        /// counter. The channel can be started multiple times, and will perform the same
        /// number of transfers each time, as programmed by most recent write.\n\n
        /// The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
        /// trigger, the written value is used immediately as the length of the new transfer
        /// sequence, as well as being written to RELOAD.
        pub const CH5_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x148);

        /// address: 0x5000014c
        /// DMA Channel 5 Control and Status
        pub const CH5_CTRL_TRIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel Enable.\n
            /// When 1, the channel will respond to triggering events, which will cause it to
            /// become BUSY and start transferring data. When 0, the channel will ignore
            /// triggers, stop issuing transfers, and pause the current transfer sequence (i.e.
            /// BUSY will remain high if already high)
            EN: u1,
            /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in
            /// each scheduling round, all high priority channels are considered first, and then
            /// only a single low priority channel, before returning to the high priority
            /// channels.\n\n
            /// This only affects the order in which the DMA schedules channels. The DMA's bus
            /// priority is not changed. If the DMA is not saturated then a low priority channel
            /// will see no loss of throughput.
            HIGH_PRIORITY: u1,
            /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR
            /// advance by this amount (1/2/4 bytes) with each transfer.
            DATA_SIZE: u2,
            /// If 1, the read address increments with each transfer. If 0, each read is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for peripheral-to-memory transfers.
            INCR_READ: u1,
            /// If 1, the write address increments with each transfer. If 0, each write is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for memory-to-peripheral transfers.
            INCR_WRITE: u1,
            /// Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower
            /// n bits of the address will change. This wraps the address on a (1 << n) byte
            /// boundary, facilitating access to naturally-aligned ring buffers.\n\n
            /// Ring sizes between 2 and 32768 bytes are possible. This can apply to either read
            /// or write addresses, based on value of RING_SEL.
            RING_SIZE: u4,
            /// Select whether RING_SIZE applies to read or write addresses.\n
            /// If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write
            /// addresses are wrapped.
            RING_SEL: u1,
            /// When this channel completes, it will trigger the channel indicated by CHAIN_TO.
            /// Disable by setting CHAIN_TO = _(this channel)_.\n
            /// Reset value is equal to channel number (5).
            CHAIN_TO: u4,
            /// Select a Transfer Request signal.\n
            /// The channel uses the transfer request signal to pace its data transfer rate.
            /// Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request
            /// from the system).\n
            /// 0x0 to 0x3a -> select DREQ n as TREQ
            TREQ_SEL: u6,
            /// In QUIET mode, the channel does not generate IRQs at the end of every transfer
            /// block. Instead, an IRQ is raised when NULL is written to a trigger register,
            /// indicating the end of a control block chain.\n\n
            /// This reduces the number of interrupts to be serviced by the CPU when
            /// transferring a DMA chain of many small control blocks.
            IRQ_QUIET: u1,
            /// Apply byte-swap transformation to DMA data.\n
            /// For byte data, this has no effect. For halfword data, the two bytes of each
            /// halfword are swapped. For word data, the four bytes of each word are swapped to
            /// reverse order.
            BSWAP: u1,
            /// If 1, this channel's data transfers are visible to the sniff hardware, and each
            /// transfer will advance the state of the checksum. This only applies if the sniff
            /// hardware is enabled, and has this channel selected.\n\n
            /// This allows checksum to be enabled or disabled on a per-control- block basis.
            SNIFF_EN: u1,
            /// This flag goes high when the channel starts a new transfer sequence, and low
            /// when the last transfer of that sequence completes. Clearing EN while BUSY is
            /// high pauses the channel, and BUSY will stay high while paused.\n\n
            /// To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
            BUSY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// If 1, the channel received a write bus error. Write one to clear.\n
            /// WRITE_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 5 transfers later)
            WRITE_ERROR: u1,
            /// If 1, the channel received a read bus error. Write one to clear.\n
            /// READ_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 3 transfers later)
            READ_ERROR: u1,
            /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it
            /// encounters any bus error, and always raises its channel IRQ flag.
            AHB_ERROR: u1,
        }), base_address + 0x14c);

        /// address: 0x50000150
        /// Alias for channel 5 CTRL register
        pub const CH5_AL1_CTRL = @intToPtr(*volatile u32, base_address + 0x150);

        /// address: 0x50000154
        /// Alias for channel 5 READ_ADDR register
        pub const CH5_AL1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x154);

        /// address: 0x50000158
        /// Alias for channel 5 WRITE_ADDR register
        pub const CH5_AL1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x158);

        /// address: 0x5000015c
        /// Alias for channel 5 TRANS_COUNT register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH5_AL1_TRANS_COUNT_TRIG = @intToPtr(*volatile u32, base_address + 0x15c);

        /// address: 0x50000160
        /// Alias for channel 5 CTRL register
        pub const CH5_AL2_CTRL = @intToPtr(*volatile u32, base_address + 0x160);

        /// address: 0x50000164
        /// Alias for channel 5 TRANS_COUNT register
        pub const CH5_AL2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x164);

        /// address: 0x50000168
        /// Alias for channel 5 READ_ADDR register
        pub const CH5_AL2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x168);

        /// address: 0x5000016c
        /// Alias for channel 5 WRITE_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH5_AL2_WRITE_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x16c);

        /// address: 0x50000170
        /// Alias for channel 5 CTRL register
        pub const CH5_AL3_CTRL = @intToPtr(*volatile u32, base_address + 0x170);

        /// address: 0x50000174
        /// Alias for channel 5 WRITE_ADDR register
        pub const CH5_AL3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x174);

        /// address: 0x50000178
        /// Alias for channel 5 TRANS_COUNT register
        pub const CH5_AL3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x178);

        /// address: 0x5000017c
        /// Alias for channel 5 READ_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH5_AL3_READ_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x17c);

        /// address: 0x50000180
        /// DMA Channel 6 Read Address pointer\n
        /// This register updates automatically each time a read completes. The current
        /// value is the next address to be read by this channel.
        pub const CH6_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x180);

        /// address: 0x50000184
        /// DMA Channel 6 Write Address pointer\n
        /// This register updates automatically each time a write completes. The current
        /// value is the next address to be written by this channel.
        pub const CH6_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x184);

        /// address: 0x50000188
        /// DMA Channel 6 Transfer Count\n
        /// Program the number of bus transfers a channel will perform before halting. Note
        /// that, if transfers are larger than one byte in size, this is not equal to the
        /// number of bytes transferred (see CTRL_DATA_SIZE).\n\n
        /// When the channel is active, reading this register shows the number of transfers
        /// remaining, updating automatically each time a write transfer completes.\n\n
        /// Writing this register sets the RELOAD value for the transfer counter. Each time
        /// this channel is triggered, the RELOAD value is copied into the live transfer
        /// counter. The channel can be started multiple times, and will perform the same
        /// number of transfers each time, as programmed by most recent write.\n\n
        /// The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
        /// trigger, the written value is used immediately as the length of the new transfer
        /// sequence, as well as being written to RELOAD.
        pub const CH6_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x188);

        /// address: 0x5000018c
        /// DMA Channel 6 Control and Status
        pub const CH6_CTRL_TRIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel Enable.\n
            /// When 1, the channel will respond to triggering events, which will cause it to
            /// become BUSY and start transferring data. When 0, the channel will ignore
            /// triggers, stop issuing transfers, and pause the current transfer sequence (i.e.
            /// BUSY will remain high if already high)
            EN: u1,
            /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in
            /// each scheduling round, all high priority channels are considered first, and then
            /// only a single low priority channel, before returning to the high priority
            /// channels.\n\n
            /// This only affects the order in which the DMA schedules channels. The DMA's bus
            /// priority is not changed. If the DMA is not saturated then a low priority channel
            /// will see no loss of throughput.
            HIGH_PRIORITY: u1,
            /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR
            /// advance by this amount (1/2/4 bytes) with each transfer.
            DATA_SIZE: u2,
            /// If 1, the read address increments with each transfer. If 0, each read is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for peripheral-to-memory transfers.
            INCR_READ: u1,
            /// If 1, the write address increments with each transfer. If 0, each write is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for memory-to-peripheral transfers.
            INCR_WRITE: u1,
            /// Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower
            /// n bits of the address will change. This wraps the address on a (1 << n) byte
            /// boundary, facilitating access to naturally-aligned ring buffers.\n\n
            /// Ring sizes between 2 and 32768 bytes are possible. This can apply to either read
            /// or write addresses, based on value of RING_SEL.
            RING_SIZE: u4,
            /// Select whether RING_SIZE applies to read or write addresses.\n
            /// If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write
            /// addresses are wrapped.
            RING_SEL: u1,
            /// When this channel completes, it will trigger the channel indicated by CHAIN_TO.
            /// Disable by setting CHAIN_TO = _(this channel)_.\n
            /// Reset value is equal to channel number (6).
            CHAIN_TO: u4,
            /// Select a Transfer Request signal.\n
            /// The channel uses the transfer request signal to pace its data transfer rate.
            /// Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request
            /// from the system).\n
            /// 0x0 to 0x3a -> select DREQ n as TREQ
            TREQ_SEL: u6,
            /// In QUIET mode, the channel does not generate IRQs at the end of every transfer
            /// block. Instead, an IRQ is raised when NULL is written to a trigger register,
            /// indicating the end of a control block chain.\n\n
            /// This reduces the number of interrupts to be serviced by the CPU when
            /// transferring a DMA chain of many small control blocks.
            IRQ_QUIET: u1,
            /// Apply byte-swap transformation to DMA data.\n
            /// For byte data, this has no effect. For halfword data, the two bytes of each
            /// halfword are swapped. For word data, the four bytes of each word are swapped to
            /// reverse order.
            BSWAP: u1,
            /// If 1, this channel's data transfers are visible to the sniff hardware, and each
            /// transfer will advance the state of the checksum. This only applies if the sniff
            /// hardware is enabled, and has this channel selected.\n\n
            /// This allows checksum to be enabled or disabled on a per-control- block basis.
            SNIFF_EN: u1,
            /// This flag goes high when the channel starts a new transfer sequence, and low
            /// when the last transfer of that sequence completes. Clearing EN while BUSY is
            /// high pauses the channel, and BUSY will stay high while paused.\n\n
            /// To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
            BUSY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// If 1, the channel received a write bus error. Write one to clear.\n
            /// WRITE_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 5 transfers later)
            WRITE_ERROR: u1,
            /// If 1, the channel received a read bus error. Write one to clear.\n
            /// READ_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 3 transfers later)
            READ_ERROR: u1,
            /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it
            /// encounters any bus error, and always raises its channel IRQ flag.
            AHB_ERROR: u1,
        }), base_address + 0x18c);

        /// address: 0x50000190
        /// Alias for channel 6 CTRL register
        pub const CH6_AL1_CTRL = @intToPtr(*volatile u32, base_address + 0x190);

        /// address: 0x50000194
        /// Alias for channel 6 READ_ADDR register
        pub const CH6_AL1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x194);

        /// address: 0x50000198
        /// Alias for channel 6 WRITE_ADDR register
        pub const CH6_AL1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x198);

        /// address: 0x5000019c
        /// Alias for channel 6 TRANS_COUNT register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH6_AL1_TRANS_COUNT_TRIG = @intToPtr(*volatile u32, base_address + 0x19c);

        /// address: 0x500001a0
        /// Alias for channel 6 CTRL register
        pub const CH6_AL2_CTRL = @intToPtr(*volatile u32, base_address + 0x1a0);

        /// address: 0x500001a4
        /// Alias for channel 6 TRANS_COUNT register
        pub const CH6_AL2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x1a4);

        /// address: 0x500001a8
        /// Alias for channel 6 READ_ADDR register
        pub const CH6_AL2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x1a8);

        /// address: 0x500001ac
        /// Alias for channel 6 WRITE_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH6_AL2_WRITE_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x1ac);

        /// address: 0x500001b0
        /// Alias for channel 6 CTRL register
        pub const CH6_AL3_CTRL = @intToPtr(*volatile u32, base_address + 0x1b0);

        /// address: 0x500001b4
        /// Alias for channel 6 WRITE_ADDR register
        pub const CH6_AL3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x1b4);

        /// address: 0x500001b8
        /// Alias for channel 6 TRANS_COUNT register
        pub const CH6_AL3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x1b8);

        /// address: 0x500001bc
        /// Alias for channel 6 READ_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH6_AL3_READ_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x1bc);

        /// address: 0x500001c0
        /// DMA Channel 7 Read Address pointer\n
        /// This register updates automatically each time a read completes. The current
        /// value is the next address to be read by this channel.
        pub const CH7_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x1c0);

        /// address: 0x500001c4
        /// DMA Channel 7 Write Address pointer\n
        /// This register updates automatically each time a write completes. The current
        /// value is the next address to be written by this channel.
        pub const CH7_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x1c4);

        /// address: 0x500001c8
        /// DMA Channel 7 Transfer Count\n
        /// Program the number of bus transfers a channel will perform before halting. Note
        /// that, if transfers are larger than one byte in size, this is not equal to the
        /// number of bytes transferred (see CTRL_DATA_SIZE).\n\n
        /// When the channel is active, reading this register shows the number of transfers
        /// remaining, updating automatically each time a write transfer completes.\n\n
        /// Writing this register sets the RELOAD value for the transfer counter. Each time
        /// this channel is triggered, the RELOAD value is copied into the live transfer
        /// counter. The channel can be started multiple times, and will perform the same
        /// number of transfers each time, as programmed by most recent write.\n\n
        /// The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
        /// trigger, the written value is used immediately as the length of the new transfer
        /// sequence, as well as being written to RELOAD.
        pub const CH7_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x1c8);

        /// address: 0x500001cc
        /// DMA Channel 7 Control and Status
        pub const CH7_CTRL_TRIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel Enable.\n
            /// When 1, the channel will respond to triggering events, which will cause it to
            /// become BUSY and start transferring data. When 0, the channel will ignore
            /// triggers, stop issuing transfers, and pause the current transfer sequence (i.e.
            /// BUSY will remain high if already high)
            EN: u1,
            /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in
            /// each scheduling round, all high priority channels are considered first, and then
            /// only a single low priority channel, before returning to the high priority
            /// channels.\n\n
            /// This only affects the order in which the DMA schedules channels. The DMA's bus
            /// priority is not changed. If the DMA is not saturated then a low priority channel
            /// will see no loss of throughput.
            HIGH_PRIORITY: u1,
            /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR
            /// advance by this amount (1/2/4 bytes) with each transfer.
            DATA_SIZE: u2,
            /// If 1, the read address increments with each transfer. If 0, each read is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for peripheral-to-memory transfers.
            INCR_READ: u1,
            /// If 1, the write address increments with each transfer. If 0, each write is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for memory-to-peripheral transfers.
            INCR_WRITE: u1,
            /// Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower
            /// n bits of the address will change. This wraps the address on a (1 << n) byte
            /// boundary, facilitating access to naturally-aligned ring buffers.\n\n
            /// Ring sizes between 2 and 32768 bytes are possible. This can apply to either read
            /// or write addresses, based on value of RING_SEL.
            RING_SIZE: u4,
            /// Select whether RING_SIZE applies to read or write addresses.\n
            /// If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write
            /// addresses are wrapped.
            RING_SEL: u1,
            /// When this channel completes, it will trigger the channel indicated by CHAIN_TO.
            /// Disable by setting CHAIN_TO = _(this channel)_.\n
            /// Reset value is equal to channel number (7).
            CHAIN_TO: u4,
            /// Select a Transfer Request signal.\n
            /// The channel uses the transfer request signal to pace its data transfer rate.
            /// Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request
            /// from the system).\n
            /// 0x0 to 0x3a -> select DREQ n as TREQ
            TREQ_SEL: u6,
            /// In QUIET mode, the channel does not generate IRQs at the end of every transfer
            /// block. Instead, an IRQ is raised when NULL is written to a trigger register,
            /// indicating the end of a control block chain.\n\n
            /// This reduces the number of interrupts to be serviced by the CPU when
            /// transferring a DMA chain of many small control blocks.
            IRQ_QUIET: u1,
            /// Apply byte-swap transformation to DMA data.\n
            /// For byte data, this has no effect. For halfword data, the two bytes of each
            /// halfword are swapped. For word data, the four bytes of each word are swapped to
            /// reverse order.
            BSWAP: u1,
            /// If 1, this channel's data transfers are visible to the sniff hardware, and each
            /// transfer will advance the state of the checksum. This only applies if the sniff
            /// hardware is enabled, and has this channel selected.\n\n
            /// This allows checksum to be enabled or disabled on a per-control- block basis.
            SNIFF_EN: u1,
            /// This flag goes high when the channel starts a new transfer sequence, and low
            /// when the last transfer of that sequence completes. Clearing EN while BUSY is
            /// high pauses the channel, and BUSY will stay high while paused.\n\n
            /// To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
            BUSY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// If 1, the channel received a write bus error. Write one to clear.\n
            /// WRITE_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 5 transfers later)
            WRITE_ERROR: u1,
            /// If 1, the channel received a read bus error. Write one to clear.\n
            /// READ_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 3 transfers later)
            READ_ERROR: u1,
            /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it
            /// encounters any bus error, and always raises its channel IRQ flag.
            AHB_ERROR: u1,
        }), base_address + 0x1cc);

        /// address: 0x500001d0
        /// Alias for channel 7 CTRL register
        pub const CH7_AL1_CTRL = @intToPtr(*volatile u32, base_address + 0x1d0);

        /// address: 0x500001d4
        /// Alias for channel 7 READ_ADDR register
        pub const CH7_AL1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x1d4);

        /// address: 0x500001d8
        /// Alias for channel 7 WRITE_ADDR register
        pub const CH7_AL1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x1d8);

        /// address: 0x500001dc
        /// Alias for channel 7 TRANS_COUNT register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH7_AL1_TRANS_COUNT_TRIG = @intToPtr(*volatile u32, base_address + 0x1dc);

        /// address: 0x500001e0
        /// Alias for channel 7 CTRL register
        pub const CH7_AL2_CTRL = @intToPtr(*volatile u32, base_address + 0x1e0);

        /// address: 0x500001e4
        /// Alias for channel 7 TRANS_COUNT register
        pub const CH7_AL2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x1e4);

        /// address: 0x500001e8
        /// Alias for channel 7 READ_ADDR register
        pub const CH7_AL2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x1e8);

        /// address: 0x500001ec
        /// Alias for channel 7 WRITE_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH7_AL2_WRITE_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x1ec);

        /// address: 0x500001f0
        /// Alias for channel 7 CTRL register
        pub const CH7_AL3_CTRL = @intToPtr(*volatile u32, base_address + 0x1f0);

        /// address: 0x500001f4
        /// Alias for channel 7 WRITE_ADDR register
        pub const CH7_AL3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x1f4);

        /// address: 0x500001f8
        /// Alias for channel 7 TRANS_COUNT register
        pub const CH7_AL3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x1f8);

        /// address: 0x500001fc
        /// Alias for channel 7 READ_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH7_AL3_READ_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x1fc);

        /// address: 0x50000200
        /// DMA Channel 8 Read Address pointer\n
        /// This register updates automatically each time a read completes. The current
        /// value is the next address to be read by this channel.
        pub const CH8_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x200);

        /// address: 0x50000204
        /// DMA Channel 8 Write Address pointer\n
        /// This register updates automatically each time a write completes. The current
        /// value is the next address to be written by this channel.
        pub const CH8_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x204);

        /// address: 0x50000208
        /// DMA Channel 8 Transfer Count\n
        /// Program the number of bus transfers a channel will perform before halting. Note
        /// that, if transfers are larger than one byte in size, this is not equal to the
        /// number of bytes transferred (see CTRL_DATA_SIZE).\n\n
        /// When the channel is active, reading this register shows the number of transfers
        /// remaining, updating automatically each time a write transfer completes.\n\n
        /// Writing this register sets the RELOAD value for the transfer counter. Each time
        /// this channel is triggered, the RELOAD value is copied into the live transfer
        /// counter. The channel can be started multiple times, and will perform the same
        /// number of transfers each time, as programmed by most recent write.\n\n
        /// The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
        /// trigger, the written value is used immediately as the length of the new transfer
        /// sequence, as well as being written to RELOAD.
        pub const CH8_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x208);

        /// address: 0x5000020c
        /// DMA Channel 8 Control and Status
        pub const CH8_CTRL_TRIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel Enable.\n
            /// When 1, the channel will respond to triggering events, which will cause it to
            /// become BUSY and start transferring data. When 0, the channel will ignore
            /// triggers, stop issuing transfers, and pause the current transfer sequence (i.e.
            /// BUSY will remain high if already high)
            EN: u1,
            /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in
            /// each scheduling round, all high priority channels are considered first, and then
            /// only a single low priority channel, before returning to the high priority
            /// channels.\n\n
            /// This only affects the order in which the DMA schedules channels. The DMA's bus
            /// priority is not changed. If the DMA is not saturated then a low priority channel
            /// will see no loss of throughput.
            HIGH_PRIORITY: u1,
            /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR
            /// advance by this amount (1/2/4 bytes) with each transfer.
            DATA_SIZE: u2,
            /// If 1, the read address increments with each transfer. If 0, each read is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for peripheral-to-memory transfers.
            INCR_READ: u1,
            /// If 1, the write address increments with each transfer. If 0, each write is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for memory-to-peripheral transfers.
            INCR_WRITE: u1,
            /// Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower
            /// n bits of the address will change. This wraps the address on a (1 << n) byte
            /// boundary, facilitating access to naturally-aligned ring buffers.\n\n
            /// Ring sizes between 2 and 32768 bytes are possible. This can apply to either read
            /// or write addresses, based on value of RING_SEL.
            RING_SIZE: u4,
            /// Select whether RING_SIZE applies to read or write addresses.\n
            /// If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write
            /// addresses are wrapped.
            RING_SEL: u1,
            /// When this channel completes, it will trigger the channel indicated by CHAIN_TO.
            /// Disable by setting CHAIN_TO = _(this channel)_.\n
            /// Reset value is equal to channel number (8).
            CHAIN_TO: u4,
            /// Select a Transfer Request signal.\n
            /// The channel uses the transfer request signal to pace its data transfer rate.
            /// Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request
            /// from the system).\n
            /// 0x0 to 0x3a -> select DREQ n as TREQ
            TREQ_SEL: u6,
            /// In QUIET mode, the channel does not generate IRQs at the end of every transfer
            /// block. Instead, an IRQ is raised when NULL is written to a trigger register,
            /// indicating the end of a control block chain.\n\n
            /// This reduces the number of interrupts to be serviced by the CPU when
            /// transferring a DMA chain of many small control blocks.
            IRQ_QUIET: u1,
            /// Apply byte-swap transformation to DMA data.\n
            /// For byte data, this has no effect. For halfword data, the two bytes of each
            /// halfword are swapped. For word data, the four bytes of each word are swapped to
            /// reverse order.
            BSWAP: u1,
            /// If 1, this channel's data transfers are visible to the sniff hardware, and each
            /// transfer will advance the state of the checksum. This only applies if the sniff
            /// hardware is enabled, and has this channel selected.\n\n
            /// This allows checksum to be enabled or disabled on a per-control- block basis.
            SNIFF_EN: u1,
            /// This flag goes high when the channel starts a new transfer sequence, and low
            /// when the last transfer of that sequence completes. Clearing EN while BUSY is
            /// high pauses the channel, and BUSY will stay high while paused.\n\n
            /// To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
            BUSY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// If 1, the channel received a write bus error. Write one to clear.\n
            /// WRITE_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 5 transfers later)
            WRITE_ERROR: u1,
            /// If 1, the channel received a read bus error. Write one to clear.\n
            /// READ_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 3 transfers later)
            READ_ERROR: u1,
            /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it
            /// encounters any bus error, and always raises its channel IRQ flag.
            AHB_ERROR: u1,
        }), base_address + 0x20c);

        /// address: 0x50000210
        /// Alias for channel 8 CTRL register
        pub const CH8_AL1_CTRL = @intToPtr(*volatile u32, base_address + 0x210);

        /// address: 0x50000214
        /// Alias for channel 8 READ_ADDR register
        pub const CH8_AL1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x214);

        /// address: 0x50000218
        /// Alias for channel 8 WRITE_ADDR register
        pub const CH8_AL1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x218);

        /// address: 0x5000021c
        /// Alias for channel 8 TRANS_COUNT register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH8_AL1_TRANS_COUNT_TRIG = @intToPtr(*volatile u32, base_address + 0x21c);

        /// address: 0x50000220
        /// Alias for channel 8 CTRL register
        pub const CH8_AL2_CTRL = @intToPtr(*volatile u32, base_address + 0x220);

        /// address: 0x50000224
        /// Alias for channel 8 TRANS_COUNT register
        pub const CH8_AL2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x224);

        /// address: 0x50000228
        /// Alias for channel 8 READ_ADDR register
        pub const CH8_AL2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x228);

        /// address: 0x5000022c
        /// Alias for channel 8 WRITE_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH8_AL2_WRITE_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x22c);

        /// address: 0x50000230
        /// Alias for channel 8 CTRL register
        pub const CH8_AL3_CTRL = @intToPtr(*volatile u32, base_address + 0x230);

        /// address: 0x50000234
        /// Alias for channel 8 WRITE_ADDR register
        pub const CH8_AL3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x234);

        /// address: 0x50000238
        /// Alias for channel 8 TRANS_COUNT register
        pub const CH8_AL3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x238);

        /// address: 0x5000023c
        /// Alias for channel 8 READ_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH8_AL3_READ_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x23c);

        /// address: 0x50000240
        /// DMA Channel 9 Read Address pointer\n
        /// This register updates automatically each time a read completes. The current
        /// value is the next address to be read by this channel.
        pub const CH9_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x240);

        /// address: 0x50000244
        /// DMA Channel 9 Write Address pointer\n
        /// This register updates automatically each time a write completes. The current
        /// value is the next address to be written by this channel.
        pub const CH9_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x244);

        /// address: 0x50000248
        /// DMA Channel 9 Transfer Count\n
        /// Program the number of bus transfers a channel will perform before halting. Note
        /// that, if transfers are larger than one byte in size, this is not equal to the
        /// number of bytes transferred (see CTRL_DATA_SIZE).\n\n
        /// When the channel is active, reading this register shows the number of transfers
        /// remaining, updating automatically each time a write transfer completes.\n\n
        /// Writing this register sets the RELOAD value for the transfer counter. Each time
        /// this channel is triggered, the RELOAD value is copied into the live transfer
        /// counter. The channel can be started multiple times, and will perform the same
        /// number of transfers each time, as programmed by most recent write.\n\n
        /// The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
        /// trigger, the written value is used immediately as the length of the new transfer
        /// sequence, as well as being written to RELOAD.
        pub const CH9_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x248);

        /// address: 0x5000024c
        /// DMA Channel 9 Control and Status
        pub const CH9_CTRL_TRIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel Enable.\n
            /// When 1, the channel will respond to triggering events, which will cause it to
            /// become BUSY and start transferring data. When 0, the channel will ignore
            /// triggers, stop issuing transfers, and pause the current transfer sequence (i.e.
            /// BUSY will remain high if already high)
            EN: u1,
            /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in
            /// each scheduling round, all high priority channels are considered first, and then
            /// only a single low priority channel, before returning to the high priority
            /// channels.\n\n
            /// This only affects the order in which the DMA schedules channels. The DMA's bus
            /// priority is not changed. If the DMA is not saturated then a low priority channel
            /// will see no loss of throughput.
            HIGH_PRIORITY: u1,
            /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR
            /// advance by this amount (1/2/4 bytes) with each transfer.
            DATA_SIZE: u2,
            /// If 1, the read address increments with each transfer. If 0, each read is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for peripheral-to-memory transfers.
            INCR_READ: u1,
            /// If 1, the write address increments with each transfer. If 0, each write is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for memory-to-peripheral transfers.
            INCR_WRITE: u1,
            /// Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower
            /// n bits of the address will change. This wraps the address on a (1 << n) byte
            /// boundary, facilitating access to naturally-aligned ring buffers.\n\n
            /// Ring sizes between 2 and 32768 bytes are possible. This can apply to either read
            /// or write addresses, based on value of RING_SEL.
            RING_SIZE: u4,
            /// Select whether RING_SIZE applies to read or write addresses.\n
            /// If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write
            /// addresses are wrapped.
            RING_SEL: u1,
            /// When this channel completes, it will trigger the channel indicated by CHAIN_TO.
            /// Disable by setting CHAIN_TO = _(this channel)_.\n
            /// Reset value is equal to channel number (9).
            CHAIN_TO: u4,
            /// Select a Transfer Request signal.\n
            /// The channel uses the transfer request signal to pace its data transfer rate.
            /// Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request
            /// from the system).\n
            /// 0x0 to 0x3a -> select DREQ n as TREQ
            TREQ_SEL: u6,
            /// In QUIET mode, the channel does not generate IRQs at the end of every transfer
            /// block. Instead, an IRQ is raised when NULL is written to a trigger register,
            /// indicating the end of a control block chain.\n\n
            /// This reduces the number of interrupts to be serviced by the CPU when
            /// transferring a DMA chain of many small control blocks.
            IRQ_QUIET: u1,
            /// Apply byte-swap transformation to DMA data.\n
            /// For byte data, this has no effect. For halfword data, the two bytes of each
            /// halfword are swapped. For word data, the four bytes of each word are swapped to
            /// reverse order.
            BSWAP: u1,
            /// If 1, this channel's data transfers are visible to the sniff hardware, and each
            /// transfer will advance the state of the checksum. This only applies if the sniff
            /// hardware is enabled, and has this channel selected.\n\n
            /// This allows checksum to be enabled or disabled on a per-control- block basis.
            SNIFF_EN: u1,
            /// This flag goes high when the channel starts a new transfer sequence, and low
            /// when the last transfer of that sequence completes. Clearing EN while BUSY is
            /// high pauses the channel, and BUSY will stay high while paused.\n\n
            /// To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
            BUSY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// If 1, the channel received a write bus error. Write one to clear.\n
            /// WRITE_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 5 transfers later)
            WRITE_ERROR: u1,
            /// If 1, the channel received a read bus error. Write one to clear.\n
            /// READ_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 3 transfers later)
            READ_ERROR: u1,
            /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it
            /// encounters any bus error, and always raises its channel IRQ flag.
            AHB_ERROR: u1,
        }), base_address + 0x24c);

        /// address: 0x50000250
        /// Alias for channel 9 CTRL register
        pub const CH9_AL1_CTRL = @intToPtr(*volatile u32, base_address + 0x250);

        /// address: 0x50000254
        /// Alias for channel 9 READ_ADDR register
        pub const CH9_AL1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x254);

        /// address: 0x50000258
        /// Alias for channel 9 WRITE_ADDR register
        pub const CH9_AL1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x258);

        /// address: 0x5000025c
        /// Alias for channel 9 TRANS_COUNT register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH9_AL1_TRANS_COUNT_TRIG = @intToPtr(*volatile u32, base_address + 0x25c);

        /// address: 0x50000260
        /// Alias for channel 9 CTRL register
        pub const CH9_AL2_CTRL = @intToPtr(*volatile u32, base_address + 0x260);

        /// address: 0x50000264
        /// Alias for channel 9 TRANS_COUNT register
        pub const CH9_AL2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x264);

        /// address: 0x50000268
        /// Alias for channel 9 READ_ADDR register
        pub const CH9_AL2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x268);

        /// address: 0x5000026c
        /// Alias for channel 9 WRITE_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH9_AL2_WRITE_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x26c);

        /// address: 0x50000270
        /// Alias for channel 9 CTRL register
        pub const CH9_AL3_CTRL = @intToPtr(*volatile u32, base_address + 0x270);

        /// address: 0x50000274
        /// Alias for channel 9 WRITE_ADDR register
        pub const CH9_AL3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x274);

        /// address: 0x50000278
        /// Alias for channel 9 TRANS_COUNT register
        pub const CH9_AL3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x278);

        /// address: 0x5000027c
        /// Alias for channel 9 READ_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH9_AL3_READ_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x27c);

        /// address: 0x50000280
        /// DMA Channel 10 Read Address pointer\n
        /// This register updates automatically each time a read completes. The current
        /// value is the next address to be read by this channel.
        pub const CH10_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x280);

        /// address: 0x50000284
        /// DMA Channel 10 Write Address pointer\n
        /// This register updates automatically each time a write completes. The current
        /// value is the next address to be written by this channel.
        pub const CH10_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x284);

        /// address: 0x50000288
        /// DMA Channel 10 Transfer Count\n
        /// Program the number of bus transfers a channel will perform before halting. Note
        /// that, if transfers are larger than one byte in size, this is not equal to the
        /// number of bytes transferred (see CTRL_DATA_SIZE).\n\n
        /// When the channel is active, reading this register shows the number of transfers
        /// remaining, updating automatically each time a write transfer completes.\n\n
        /// Writing this register sets the RELOAD value for the transfer counter. Each time
        /// this channel is triggered, the RELOAD value is copied into the live transfer
        /// counter. The channel can be started multiple times, and will perform the same
        /// number of transfers each time, as programmed by most recent write.\n\n
        /// The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
        /// trigger, the written value is used immediately as the length of the new transfer
        /// sequence, as well as being written to RELOAD.
        pub const CH10_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x288);

        /// address: 0x5000028c
        /// DMA Channel 10 Control and Status
        pub const CH10_CTRL_TRIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel Enable.\n
            /// When 1, the channel will respond to triggering events, which will cause it to
            /// become BUSY and start transferring data. When 0, the channel will ignore
            /// triggers, stop issuing transfers, and pause the current transfer sequence (i.e.
            /// BUSY will remain high if already high)
            EN: u1,
            /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in
            /// each scheduling round, all high priority channels are considered first, and then
            /// only a single low priority channel, before returning to the high priority
            /// channels.\n\n
            /// This only affects the order in which the DMA schedules channels. The DMA's bus
            /// priority is not changed. If the DMA is not saturated then a low priority channel
            /// will see no loss of throughput.
            HIGH_PRIORITY: u1,
            /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR
            /// advance by this amount (1/2/4 bytes) with each transfer.
            DATA_SIZE: u2,
            /// If 1, the read address increments with each transfer. If 0, each read is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for peripheral-to-memory transfers.
            INCR_READ: u1,
            /// If 1, the write address increments with each transfer. If 0, each write is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for memory-to-peripheral transfers.
            INCR_WRITE: u1,
            /// Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower
            /// n bits of the address will change. This wraps the address on a (1 << n) byte
            /// boundary, facilitating access to naturally-aligned ring buffers.\n\n
            /// Ring sizes between 2 and 32768 bytes are possible. This can apply to either read
            /// or write addresses, based on value of RING_SEL.
            RING_SIZE: u4,
            /// Select whether RING_SIZE applies to read or write addresses.\n
            /// If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write
            /// addresses are wrapped.
            RING_SEL: u1,
            /// When this channel completes, it will trigger the channel indicated by CHAIN_TO.
            /// Disable by setting CHAIN_TO = _(this channel)_.\n
            /// Reset value is equal to channel number (10).
            CHAIN_TO: u4,
            /// Select a Transfer Request signal.\n
            /// The channel uses the transfer request signal to pace its data transfer rate.
            /// Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request
            /// from the system).\n
            /// 0x0 to 0x3a -> select DREQ n as TREQ
            TREQ_SEL: u6,
            /// In QUIET mode, the channel does not generate IRQs at the end of every transfer
            /// block. Instead, an IRQ is raised when NULL is written to a trigger register,
            /// indicating the end of a control block chain.\n\n
            /// This reduces the number of interrupts to be serviced by the CPU when
            /// transferring a DMA chain of many small control blocks.
            IRQ_QUIET: u1,
            /// Apply byte-swap transformation to DMA data.\n
            /// For byte data, this has no effect. For halfword data, the two bytes of each
            /// halfword are swapped. For word data, the four bytes of each word are swapped to
            /// reverse order.
            BSWAP: u1,
            /// If 1, this channel's data transfers are visible to the sniff hardware, and each
            /// transfer will advance the state of the checksum. This only applies if the sniff
            /// hardware is enabled, and has this channel selected.\n\n
            /// This allows checksum to be enabled or disabled on a per-control- block basis.
            SNIFF_EN: u1,
            /// This flag goes high when the channel starts a new transfer sequence, and low
            /// when the last transfer of that sequence completes. Clearing EN while BUSY is
            /// high pauses the channel, and BUSY will stay high while paused.\n\n
            /// To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
            BUSY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// If 1, the channel received a write bus error. Write one to clear.\n
            /// WRITE_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 5 transfers later)
            WRITE_ERROR: u1,
            /// If 1, the channel received a read bus error. Write one to clear.\n
            /// READ_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 3 transfers later)
            READ_ERROR: u1,
            /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it
            /// encounters any bus error, and always raises its channel IRQ flag.
            AHB_ERROR: u1,
        }), base_address + 0x28c);

        /// address: 0x50000290
        /// Alias for channel 10 CTRL register
        pub const CH10_AL1_CTRL = @intToPtr(*volatile u32, base_address + 0x290);

        /// address: 0x50000294
        /// Alias for channel 10 READ_ADDR register
        pub const CH10_AL1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x294);

        /// address: 0x50000298
        /// Alias for channel 10 WRITE_ADDR register
        pub const CH10_AL1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x298);

        /// address: 0x5000029c
        /// Alias for channel 10 TRANS_COUNT register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH10_AL1_TRANS_COUNT_TRIG = @intToPtr(*volatile u32, base_address + 0x29c);

        /// address: 0x500002a0
        /// Alias for channel 10 CTRL register
        pub const CH10_AL2_CTRL = @intToPtr(*volatile u32, base_address + 0x2a0);

        /// address: 0x500002a4
        /// Alias for channel 10 TRANS_COUNT register
        pub const CH10_AL2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x2a4);

        /// address: 0x500002a8
        /// Alias for channel 10 READ_ADDR register
        pub const CH10_AL2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x2a8);

        /// address: 0x500002ac
        /// Alias for channel 10 WRITE_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH10_AL2_WRITE_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x2ac);

        /// address: 0x500002b0
        /// Alias for channel 10 CTRL register
        pub const CH10_AL3_CTRL = @intToPtr(*volatile u32, base_address + 0x2b0);

        /// address: 0x500002b4
        /// Alias for channel 10 WRITE_ADDR register
        pub const CH10_AL3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x2b4);

        /// address: 0x500002b8
        /// Alias for channel 10 TRANS_COUNT register
        pub const CH10_AL3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x2b8);

        /// address: 0x500002bc
        /// Alias for channel 10 READ_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH10_AL3_READ_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x2bc);

        /// address: 0x500002c0
        /// DMA Channel 11 Read Address pointer\n
        /// This register updates automatically each time a read completes. The current
        /// value is the next address to be read by this channel.
        pub const CH11_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x2c0);

        /// address: 0x500002c4
        /// DMA Channel 11 Write Address pointer\n
        /// This register updates automatically each time a write completes. The current
        /// value is the next address to be written by this channel.
        pub const CH11_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x2c4);

        /// address: 0x500002c8
        /// DMA Channel 11 Transfer Count\n
        /// Program the number of bus transfers a channel will perform before halting. Note
        /// that, if transfers are larger than one byte in size, this is not equal to the
        /// number of bytes transferred (see CTRL_DATA_SIZE).\n\n
        /// When the channel is active, reading this register shows the number of transfers
        /// remaining, updating automatically each time a write transfer completes.\n\n
        /// Writing this register sets the RELOAD value for the transfer counter. Each time
        /// this channel is triggered, the RELOAD value is copied into the live transfer
        /// counter. The channel can be started multiple times, and will perform the same
        /// number of transfers each time, as programmed by most recent write.\n\n
        /// The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
        /// trigger, the written value is used immediately as the length of the new transfer
        /// sequence, as well as being written to RELOAD.
        pub const CH11_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x2c8);

        /// address: 0x500002cc
        /// DMA Channel 11 Control and Status
        pub const CH11_CTRL_TRIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel Enable.\n
            /// When 1, the channel will respond to triggering events, which will cause it to
            /// become BUSY and start transferring data. When 0, the channel will ignore
            /// triggers, stop issuing transfers, and pause the current transfer sequence (i.e.
            /// BUSY will remain high if already high)
            EN: u1,
            /// HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in
            /// each scheduling round, all high priority channels are considered first, and then
            /// only a single low priority channel, before returning to the high priority
            /// channels.\n\n
            /// This only affects the order in which the DMA schedules channels. The DMA's bus
            /// priority is not changed. If the DMA is not saturated then a low priority channel
            /// will see no loss of throughput.
            HIGH_PRIORITY: u1,
            /// Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR
            /// advance by this amount (1/2/4 bytes) with each transfer.
            DATA_SIZE: u2,
            /// If 1, the read address increments with each transfer. If 0, each read is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for peripheral-to-memory transfers.
            INCR_READ: u1,
            /// If 1, the write address increments with each transfer. If 0, each write is
            /// directed to the same, initial address.\n\n
            /// Generally this should be disabled for memory-to-peripheral transfers.
            INCR_WRITE: u1,
            /// Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower
            /// n bits of the address will change. This wraps the address on a (1 << n) byte
            /// boundary, facilitating access to naturally-aligned ring buffers.\n\n
            /// Ring sizes between 2 and 32768 bytes are possible. This can apply to either read
            /// or write addresses, based on value of RING_SEL.
            RING_SIZE: u4,
            /// Select whether RING_SIZE applies to read or write addresses.\n
            /// If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write
            /// addresses are wrapped.
            RING_SEL: u1,
            /// When this channel completes, it will trigger the channel indicated by CHAIN_TO.
            /// Disable by setting CHAIN_TO = _(this channel)_.\n
            /// Reset value is equal to channel number (11).
            CHAIN_TO: u4,
            /// Select a Transfer Request signal.\n
            /// The channel uses the transfer request signal to pace its data transfer rate.
            /// Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request
            /// from the system).\n
            /// 0x0 to 0x3a -> select DREQ n as TREQ
            TREQ_SEL: u6,
            /// In QUIET mode, the channel does not generate IRQs at the end of every transfer
            /// block. Instead, an IRQ is raised when NULL is written to a trigger register,
            /// indicating the end of a control block chain.\n\n
            /// This reduces the number of interrupts to be serviced by the CPU when
            /// transferring a DMA chain of many small control blocks.
            IRQ_QUIET: u1,
            /// Apply byte-swap transformation to DMA data.\n
            /// For byte data, this has no effect. For halfword data, the two bytes of each
            /// halfword are swapped. For word data, the four bytes of each word are swapped to
            /// reverse order.
            BSWAP: u1,
            /// If 1, this channel's data transfers are visible to the sniff hardware, and each
            /// transfer will advance the state of the checksum. This only applies if the sniff
            /// hardware is enabled, and has this channel selected.\n\n
            /// This allows checksum to be enabled or disabled on a per-control- block basis.
            SNIFF_EN: u1,
            /// This flag goes high when the channel starts a new transfer sequence, and low
            /// when the last transfer of that sequence completes. Clearing EN while BUSY is
            /// high pauses the channel, and BUSY will stay high while paused.\n\n
            /// To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
            BUSY: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// If 1, the channel received a write bus error. Write one to clear.\n
            /// WRITE_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 5 transfers later)
            WRITE_ERROR: u1,
            /// If 1, the channel received a read bus error. Write one to clear.\n
            /// READ_ADDR shows the approximate address where the bus error was encountered
            /// (will not to be earlier, or more than 3 transfers later)
            READ_ERROR: u1,
            /// Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it
            /// encounters any bus error, and always raises its channel IRQ flag.
            AHB_ERROR: u1,
        }), base_address + 0x2cc);

        /// address: 0x500002d0
        /// Alias for channel 11 CTRL register
        pub const CH11_AL1_CTRL = @intToPtr(*volatile u32, base_address + 0x2d0);

        /// address: 0x500002d4
        /// Alias for channel 11 READ_ADDR register
        pub const CH11_AL1_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x2d4);

        /// address: 0x500002d8
        /// Alias for channel 11 WRITE_ADDR register
        pub const CH11_AL1_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x2d8);

        /// address: 0x500002dc
        /// Alias for channel 11 TRANS_COUNT register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH11_AL1_TRANS_COUNT_TRIG = @intToPtr(*volatile u32, base_address + 0x2dc);

        /// address: 0x500002e0
        /// Alias for channel 11 CTRL register
        pub const CH11_AL2_CTRL = @intToPtr(*volatile u32, base_address + 0x2e0);

        /// address: 0x500002e4
        /// Alias for channel 11 TRANS_COUNT register
        pub const CH11_AL2_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x2e4);

        /// address: 0x500002e8
        /// Alias for channel 11 READ_ADDR register
        pub const CH11_AL2_READ_ADDR = @intToPtr(*volatile u32, base_address + 0x2e8);

        /// address: 0x500002ec
        /// Alias for channel 11 WRITE_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH11_AL2_WRITE_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x2ec);

        /// address: 0x500002f0
        /// Alias for channel 11 CTRL register
        pub const CH11_AL3_CTRL = @intToPtr(*volatile u32, base_address + 0x2f0);

        /// address: 0x500002f4
        /// Alias for channel 11 WRITE_ADDR register
        pub const CH11_AL3_WRITE_ADDR = @intToPtr(*volatile u32, base_address + 0x2f4);

        /// address: 0x500002f8
        /// Alias for channel 11 TRANS_COUNT register
        pub const CH11_AL3_TRANS_COUNT = @intToPtr(*volatile u32, base_address + 0x2f8);

        /// address: 0x500002fc
        /// Alias for channel 11 READ_ADDR register\n
        /// This is a trigger register (0xc). Writing a nonzero value will\n
        /// reload the channel counter and start the channel.
        pub const CH11_AL3_READ_ADDR_TRIG = @intToPtr(*volatile u32, base_address + 0x2fc);

        /// address: 0x50000400
        /// Interrupt Status (raw)
        pub const INTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x400);

        /// address: 0x50000404
        /// Interrupt Enables for IRQ 0
        pub const INTE0 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x404);

        /// address: 0x50000408
        /// Force Interrupts
        pub const INTF0 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x408);

        /// address: 0x5000040c
        /// Interrupt Status for IRQ 0
        pub const INTS0 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40c);

        /// address: 0x50000414
        /// Interrupt Enables for IRQ 1
        pub const INTE1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x414);

        /// address: 0x50000418
        /// Force Interrupts for IRQ 1
        pub const INTF1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x418);

        /// address: 0x5000041c
        /// Interrupt Status (masked) for IRQ 1
        pub const INTS1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x41c);

        /// address: 0x50000420
        /// Pacing (X/Y) Fractional Timer\n
        /// The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk).
        /// This equation is evaluated every sys_clk cycles and therefore can only generate
        /// TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
        pub const TIMER0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
            Y: u16,
            /// Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
            X: u16,
        }), base_address + 0x420);

        /// address: 0x50000424
        /// Pacing (X/Y) Fractional Timer\n
        /// The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk).
        /// This equation is evaluated every sys_clk cycles and therefore can only generate
        /// TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
        pub const TIMER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
            Y: u16,
            /// Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
            X: u16,
        }), base_address + 0x424);

        /// address: 0x50000428
        /// Pacing (X/Y) Fractional Timer\n
        /// The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk).
        /// This equation is evaluated every sys_clk cycles and therefore can only generate
        /// TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
        pub const TIMER2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
            Y: u16,
            /// Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
            X: u16,
        }), base_address + 0x428);

        /// address: 0x5000042c
        /// Pacing (X/Y) Fractional Timer\n
        /// The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk).
        /// This equation is evaluated every sys_clk cycles and therefore can only generate
        /// TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
        pub const TIMER3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
            Y: u16,
            /// Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
            X: u16,
        }), base_address + 0x42c);

        /// address: 0x50000430
        /// Trigger one or more channels simultaneously
        pub const MULTI_CHAN_TRIGGER = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x430);

        /// address: 0x50000434
        /// Sniffer Control
        pub const SNIFF_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable sniffer
            EN: u1,
            /// DMA channel for Sniffer to observe
            DMACH: u4,
            CALC: u4,
            /// Locally perform a byte reverse on the sniffed data, before feeding into
            /// checksum.\n\n
            /// Note that the sniff hardware is downstream of the DMA channel byteswap performed
            /// in the read master: if channel CTRL_BSWAP and SNIFF_CTRL_BSWAP are both enabled,
            /// their effects cancel from the sniffer's point of view.
            BSWAP: u1,
            /// If set, the result appears bit-reversed when read. This does not affect the way
            /// the checksum is calculated; the result is transformed on-the-fly between the
            /// result register and the bus.
            OUT_REV: u1,
            /// If set, the result appears inverted (bitwise complement) when read. This does
            /// not affect the way the checksum is calculated; the result is transformed
            /// on-the-fly between the result register and the bus.
            OUT_INV: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x434);

        /// address: 0x50000438
        /// Data accumulator for sniff hardware\n
        /// Write an initial seed value here before starting a DMA transfer on the channel
        /// indicated by SNIFF_CTRL_DMACH. The hardware will update this register each time
        /// it observes a read from the indicated channel. Once the channel completes, the
        /// final result can be read from this register.
        pub const SNIFF_DATA = @intToPtr(*volatile u32, base_address + 0x438);

        /// address: 0x50000440
        /// Debug RAF, WAF, TDF levels
        pub const FIFO_LEVELS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Transfer-Data-FIFO fill level
            TDF_LVL: u8,
            /// Current Write-Address-FIFO fill level
            WAF_LVL: u8,
            /// Current Read-Address-FIFO fill level
            RAF_LVL: u8,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
        }), base_address + 0x440);

        /// address: 0x50000444
        /// Abort an in-progress transfer sequence on one or more channels
        pub const CHAN_ABORT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x444);

        /// address: 0x50000448
        /// The number of channels this DMA instance is equipped with. This DMA supports up
        /// to 16 hardware channels, but can be configured with as few as one, to minimise
        /// silicon area.
        pub const N_CHANNELS = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x448);

        /// address: 0x50000800
        /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can
        /// perform on the peripheral without overflow/underflow. Write any value: clears
        /// the counter, and cause channel to re-initiate DREQ handshake.
        pub const CH0_DBG_CTDREQ = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x800);

        /// address: 0x50000804
        /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next
        /// transfer
        pub const CH0_DBG_TCR = @intToPtr(*volatile u32, base_address + 0x804);

        /// address: 0x50000840
        /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can
        /// perform on the peripheral without overflow/underflow. Write any value: clears
        /// the counter, and cause channel to re-initiate DREQ handshake.
        pub const CH1_DBG_CTDREQ = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x840);

        /// address: 0x50000844
        /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next
        /// transfer
        pub const CH1_DBG_TCR = @intToPtr(*volatile u32, base_address + 0x844);

        /// address: 0x50000880
        /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can
        /// perform on the peripheral without overflow/underflow. Write any value: clears
        /// the counter, and cause channel to re-initiate DREQ handshake.
        pub const CH2_DBG_CTDREQ = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x880);

        /// address: 0x50000884
        /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next
        /// transfer
        pub const CH2_DBG_TCR = @intToPtr(*volatile u32, base_address + 0x884);

        /// address: 0x500008c0
        /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can
        /// perform on the peripheral without overflow/underflow. Write any value: clears
        /// the counter, and cause channel to re-initiate DREQ handshake.
        pub const CH3_DBG_CTDREQ = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x8c0);

        /// address: 0x500008c4
        /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next
        /// transfer
        pub const CH3_DBG_TCR = @intToPtr(*volatile u32, base_address + 0x8c4);

        /// address: 0x50000900
        /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can
        /// perform on the peripheral without overflow/underflow. Write any value: clears
        /// the counter, and cause channel to re-initiate DREQ handshake.
        pub const CH4_DBG_CTDREQ = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x900);

        /// address: 0x50000904
        /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next
        /// transfer
        pub const CH4_DBG_TCR = @intToPtr(*volatile u32, base_address + 0x904);

        /// address: 0x50000940
        /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can
        /// perform on the peripheral without overflow/underflow. Write any value: clears
        /// the counter, and cause channel to re-initiate DREQ handshake.
        pub const CH5_DBG_CTDREQ = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x940);

        /// address: 0x50000944
        /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next
        /// transfer
        pub const CH5_DBG_TCR = @intToPtr(*volatile u32, base_address + 0x944);

        /// address: 0x50000980
        /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can
        /// perform on the peripheral without overflow/underflow. Write any value: clears
        /// the counter, and cause channel to re-initiate DREQ handshake.
        pub const CH6_DBG_CTDREQ = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x980);

        /// address: 0x50000984
        /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next
        /// transfer
        pub const CH6_DBG_TCR = @intToPtr(*volatile u32, base_address + 0x984);

        /// address: 0x500009c0
        /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can
        /// perform on the peripheral without overflow/underflow. Write any value: clears
        /// the counter, and cause channel to re-initiate DREQ handshake.
        pub const CH7_DBG_CTDREQ = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x9c0);

        /// address: 0x500009c4
        /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next
        /// transfer
        pub const CH7_DBG_TCR = @intToPtr(*volatile u32, base_address + 0x9c4);

        /// address: 0x50000a00
        /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can
        /// perform on the peripheral without overflow/underflow. Write any value: clears
        /// the counter, and cause channel to re-initiate DREQ handshake.
        pub const CH8_DBG_CTDREQ = @intToPtr(*volatile MmioInt(32, u6), base_address + 0xa00);

        /// address: 0x50000a04
        /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next
        /// transfer
        pub const CH8_DBG_TCR = @intToPtr(*volatile u32, base_address + 0xa04);

        /// address: 0x50000a40
        /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can
        /// perform on the peripheral without overflow/underflow. Write any value: clears
        /// the counter, and cause channel to re-initiate DREQ handshake.
        pub const CH9_DBG_CTDREQ = @intToPtr(*volatile MmioInt(32, u6), base_address + 0xa40);

        /// address: 0x50000a44
        /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next
        /// transfer
        pub const CH9_DBG_TCR = @intToPtr(*volatile u32, base_address + 0xa44);

        /// address: 0x50000a80
        /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can
        /// perform on the peripheral without overflow/underflow. Write any value: clears
        /// the counter, and cause channel to re-initiate DREQ handshake.
        pub const CH10_DBG_CTDREQ = @intToPtr(*volatile MmioInt(32, u6), base_address + 0xa80);

        /// address: 0x50000a84
        /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next
        /// transfer
        pub const CH10_DBG_TCR = @intToPtr(*volatile u32, base_address + 0xa84);

        /// address: 0x50000ac0
        /// Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can
        /// perform on the peripheral without overflow/underflow. Write any value: clears
        /// the counter, and cause channel to re-initiate DREQ handshake.
        pub const CH11_DBG_CTDREQ = @intToPtr(*volatile MmioInt(32, u6), base_address + 0xac0);

        /// address: 0x50000ac4
        /// Read to get channel TRANS_COUNT reload value, i.e. the length of the next
        /// transfer
        pub const CH11_DBG_TCR = @intToPtr(*volatile u32, base_address + 0xac4);
    };

    /// DPRAM layout for USB device.
    pub const USBCTRL_DPRAM = struct {
        pub const base_address = 0x50100000;
        pub const version = "1";

        /// address: 0x50100000
        /// Bytes 0-3 of the SETUP packet from the host.
        pub const SETUP_PACKET_LOW = @intToPtr(*volatile Mmio(32, packed struct {
            BMREQUESTTYPE: u8,
            BREQUEST: u8,
            WVALUE: u16,
        }), base_address + 0x0);

        /// address: 0x50100004
        /// Bytes 4-7 of the setup packet from the host.
        pub const SETUP_PACKET_HIGH = @intToPtr(*volatile Mmio(32, packed struct {
            WINDEX: u16,
            WLENGTH: u16,
        }), base_address + 0x4);

        /// address: 0x50100008
        pub const EP1_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x8);

        /// address: 0x5010000c
        pub const EP1_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0xc);

        /// address: 0x50100010
        pub const EP2_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x10);

        /// address: 0x50100014
        pub const EP2_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x14);

        /// address: 0x50100018
        pub const EP3_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x18);

        /// address: 0x5010001c
        pub const EP3_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x1c);

        /// address: 0x50100020
        pub const EP4_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x20);

        /// address: 0x50100024
        pub const EP4_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x24);

        /// address: 0x50100028
        pub const EP5_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x28);

        /// address: 0x5010002c
        pub const EP5_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x2c);

        /// address: 0x50100030
        pub const EP6_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x30);

        /// address: 0x50100034
        pub const EP6_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x34);

        /// address: 0x50100038
        pub const EP7_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x38);

        /// address: 0x5010003c
        pub const EP7_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x3c);

        /// address: 0x50100040
        pub const EP8_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x40);

        /// address: 0x50100044
        pub const EP8_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x44);

        /// address: 0x50100048
        pub const EP9_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x48);

        /// address: 0x5010004c
        pub const EP9_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x4c);

        /// address: 0x50100050
        pub const EP10_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x50);

        /// address: 0x50100054
        pub const EP10_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x54);

        /// address: 0x50100058
        pub const EP11_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x58);

        /// address: 0x5010005c
        pub const EP11_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x5c);

        /// address: 0x50100060
        pub const EP12_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x60);

        /// address: 0x50100064
        pub const EP12_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x64);

        /// address: 0x50100068
        pub const EP13_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x68);

        /// address: 0x5010006c
        pub const EP13_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x6c);

        /// address: 0x50100070
        pub const EP14_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x70);

        /// address: 0x50100074
        pub const EP14_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x74);

        /// address: 0x50100078
        pub const EP15_IN_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x78);

        /// address: 0x5010007c
        pub const EP15_OUT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to
            /// the start of the DPRAM.
            BUFFER_ADDRESS: u16,
            /// Trigger an interrupt if a NAK is sent. Intended for debug only.
            INTERRUPT_ON_NAK: u1,
            /// Trigger an interrupt if a STALL is sent. Intended for debug only.
            INTERRUPT_ON_STALL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            ENDPOINT_TYPE: u2,
            /// Trigger an interrupt each time both buffers are done. Only valid in double
            /// buffered mode.
            INTERRUPT_PER_DOUBLE_BUFF: u1,
            /// Trigger an interrupt each time a buffer is done.
            INTERRUPT_PER_BUFF: u1,
            /// This endpoint is double buffered.
            DOUBLE_BUFFERED: u1,
            /// Enable this endpoint. The device will not reply to any packets for this endpoint
            /// if this bit is not set.
            ENABLE: u1,
        }), base_address + 0x7c);

        /// address: 0x50100080
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP0_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0x80);

        /// address: 0x50100084
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP0_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0x84);

        /// address: 0x50100088
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP1_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0x88);

        /// address: 0x5010008c
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP1_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0x8c);

        /// address: 0x50100090
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP2_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0x90);

        /// address: 0x50100094
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP2_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0x94);

        /// address: 0x50100098
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP3_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0x98);

        /// address: 0x5010009c
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP3_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0x9c);

        /// address: 0x501000a0
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP4_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xa0);

        /// address: 0x501000a4
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP4_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xa4);

        /// address: 0x501000a8
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP5_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xa8);

        /// address: 0x501000ac
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP5_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xac);

        /// address: 0x501000b0
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP6_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xb0);

        /// address: 0x501000b4
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP6_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xb4);

        /// address: 0x501000b8
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP7_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xb8);

        /// address: 0x501000bc
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP7_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xbc);

        /// address: 0x501000c0
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP8_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xc0);

        /// address: 0x501000c4
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP8_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xc4);

        /// address: 0x501000c8
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP9_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xc8);

        /// address: 0x501000cc
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP9_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xcc);

        /// address: 0x501000d0
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP10_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xd0);

        /// address: 0x501000d4
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP10_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xd4);

        /// address: 0x501000d8
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP11_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xd8);

        /// address: 0x501000dc
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP11_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xdc);

        /// address: 0x501000e0
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP12_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xe0);

        /// address: 0x501000e4
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP12_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xe4);

        /// address: 0x501000e8
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP13_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xe8);

        /// address: 0x501000ec
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP13_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xec);

        /// address: 0x501000f0
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP14_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xf0);

        /// address: 0x501000f4
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP14_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xf4);

        /// address: 0x501000f8
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP15_IN_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xf8);

        /// address: 0x501000fc
        /// Buffer control for both buffers of an endpoint. Fields ending in a _1 are for
        /// buffer 1.\n
        /// Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the
        /// endpoint is in double buffered mode.
        pub const EP15_OUT_BUFFER_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length of the data in buffer 0.
            LENGTH_0: u10,
            /// Buffer 0 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_0: u1,
            /// Reply with a stall (valid for both buffers).
            STALL: u1,
            /// Reset the buffer selector to buffer 0.
            RESET: u1,
            /// The data pid of buffer 0.
            PID_0: u1,
            /// Buffer 0 is the last buffer of the transfer.
            LAST_0: u1,
            /// Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_0: u1,
            /// The length of the data in buffer 1.
            LENGTH_1: u10,
            /// Buffer 1 is available. This bit is set to indicate the buffer can be used by the
            /// controller. The controller clears the available bit when writing the status
            /// back.
            AVAILABLE_1: u1,
            /// The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only
            /// valid in double buffered mode for an Isochronous endpoint.\n
            /// For a non Isochronous endpoint the offset is always 64 bytes.
            DOUBLE_BUFFER_ISO_OFFSET: u2,
            /// The data pid of buffer 1.
            PID_1: u1,
            /// Buffer 1 is the last buffer of the transfer.
            LAST_1: u1,
            /// Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate
            /// the data is valid. For an OUT transfer (RX from the host) this bit should be
            /// left as a 0. The host will set it when it has filled the buffer with data.
            FULL_1: u1,
        }), base_address + 0xfc);
    };

    /// USB FS/LS controller device registers
    pub const USBCTRL_REGS = struct {
        pub const base_address = 0x50110000;
        pub const version = "1";

        /// address: 0x50110000
        /// Device address and endpoint control
        pub const ADDR_ENDP = @intToPtr(*volatile Mmio(32, packed struct {
            /// In device mode, the address that the device should respond to. Set in response
            /// to a SET_ADDR setup packet from the host. In host mode set to the address of the
            /// device to communicate with.
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Device endpoint to send data to. Only valid for HOST mode.
            ENDPOINT: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x50110004
        /// Interrupt endpoint 1. Only valid for HOST mode.
        pub const ADDR_ENDP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x50110008
        /// Interrupt endpoint 2. Only valid for HOST mode.
        pub const ADDR_ENDP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x5011000c
        /// Interrupt endpoint 3. Only valid for HOST mode.
        pub const ADDR_ENDP3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0xc);

        /// address: 0x50110010
        /// Interrupt endpoint 4. Only valid for HOST mode.
        pub const ADDR_ENDP4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x10);

        /// address: 0x50110014
        /// Interrupt endpoint 5. Only valid for HOST mode.
        pub const ADDR_ENDP5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x14);

        /// address: 0x50110018
        /// Interrupt endpoint 6. Only valid for HOST mode.
        pub const ADDR_ENDP6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x18);

        /// address: 0x5011001c
        /// Interrupt endpoint 7. Only valid for HOST mode.
        pub const ADDR_ENDP7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x1c);

        /// address: 0x50110020
        /// Interrupt endpoint 8. Only valid for HOST mode.
        pub const ADDR_ENDP8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x20);

        /// address: 0x50110024
        /// Interrupt endpoint 9. Only valid for HOST mode.
        pub const ADDR_ENDP9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x24);

        /// address: 0x50110028
        /// Interrupt endpoint 10. Only valid for HOST mode.
        pub const ADDR_ENDP10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x28);

        /// address: 0x5011002c
        /// Interrupt endpoint 11. Only valid for HOST mode.
        pub const ADDR_ENDP11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x2c);

        /// address: 0x50110030
        /// Interrupt endpoint 12. Only valid for HOST mode.
        pub const ADDR_ENDP12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x30);

        /// address: 0x50110034
        /// Interrupt endpoint 13. Only valid for HOST mode.
        pub const ADDR_ENDP13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x34);

        /// address: 0x50110038
        /// Interrupt endpoint 14. Only valid for HOST mode.
        pub const ADDR_ENDP14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x38);

        /// address: 0x5011003c
        /// Interrupt endpoint 15. Only valid for HOST mode.
        pub const ADDR_ENDP15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADDRESS: u7,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            /// Endpoint number of the interrupt endpoint
            ENDPOINT: u4,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            /// Direction of the interrupt endpoint. In=0, Out=1
            INTEP_DIR: u1,
            /// Interrupt EP requires preamble (is a low speed device on a full speed hub)
            INTEP_PREAMBLE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
        }), base_address + 0x3c);

        /// address: 0x50110040
        /// Main control register
        pub const MAIN_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable controller
            CONTROLLER_EN: u1,
            /// Device mode = 0, Host mode = 1
            HOST_NDEVICE: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            reserved18: u1 = 0,
            reserved19: u1 = 0,
            reserved20: u1 = 0,
            reserved21: u1 = 0,
            reserved22: u1 = 0,
            reserved23: u1 = 0,
            reserved24: u1 = 0,
            reserved25: u1 = 0,
            reserved26: u1 = 0,
            reserved27: u1 = 0,
            reserved28: u1 = 0,
            /// Reduced timings for simulation
            SIM_TIMING: u1,
        }), base_address + 0x40);

        /// address: 0x50110044
        /// Set the SOF (Start of Frame) frame number in the host controller. The SOF packet
        /// is sent every 1ms and the host will increment the frame number by 1 each time.
        pub const SOF_WR = @intToPtr(*volatile Mmio(32, packed struct {
            COUNT: u11,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
        }), base_address + 0x44);

        /// address: 0x50110048
        /// Read the last SOF (Start of Frame) frame number seen. In device mode the last
        /// SOF received from the host. In host mode the last SOF sent by the host.
        pub const SOF_RD = @intToPtr(*volatile Mmio(32, packed struct {
            COUNT: u11,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
        }), base_address + 0x48);

        /// address: 0x5011004c
        /// SIE control register
        pub const SIE_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host: Start transaction
            START_TRANS: u1,
            /// Host: Send Setup packet
            SEND_SETUP: u1,
            /// Host: Send transaction (OUT from host)
            SEND_DATA: u1,
            /// Host: Receive transaction (IN to host)
            RECEIVE_DATA: u1,
            /// Host: Stop transaction
            STOP_TRANS: u1,
            reserved0: u1 = 0,
            /// Host: Preable enable for LS device on FS hub
            PREAMBLE_EN: u1,
            reserved1: u1 = 0,
            /// Host: Delay packet(s) until after SOF
            SOF_SYNC: u1,
            /// Host: Enable SOF generation (for full speed bus)
            SOF_EN: u1,
            /// Host: Enable keep alive packet (for low speed bus)
            KEEP_ALIVE_EN: u1,
            /// Host: Enable VBUS
            VBUS_EN: u1,
            /// Device: Remote wakeup. Device can initiate its own resume after suspend.
            RESUME: u1,
            /// Host: Reset bus
            RESET_BUS: u1,
            reserved2: u1 = 0,
            /// Host: Enable pull down resistors
            PULLDOWN_EN: u1,
            /// Device: Enable pull up resistor
            PULLUP_EN: u1,
            /// Device: Pull-up strength (0=1K2, 1=2k3)
            RPU_OPT: u1,
            /// Power down bus transceiver
            TRANSCEIVER_PD: u1,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Direct control of DM
            DIRECT_DM: u1,
            /// Direct control of DP
            DIRECT_DP: u1,
            /// Direct bus drive enable
            DIRECT_EN: u1,
            /// Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK
            EP0_INT_NAK: u1,
            /// Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0
            EP0_INT_2BUF: u1,
            /// Device: Set bit in BUFF_STATUS for every buffer completed on EP0
            EP0_INT_1BUF: u1,
            /// Device: EP0 single buffered = 0, double buffered = 1
            EP0_DOUBLE_BUF: u1,
            /// Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL
            EP0_INT_STALL: u1,
        }), base_address + 0x4c);

        /// address: 0x50110050
        /// SIE status register
        pub const SIE_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device: VBUS Detected
            VBUS_DETECTED: u1,
            reserved0: u1 = 0,
            /// USB bus line state
            LINE_STATE: u2,
            /// Bus in suspended state. Valid for device and host. Host and device will go into
            /// suspend if neither Keep Alive / SOF frames are enabled.
            SUSPENDED: u1,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// Host: device speed. Disconnected = 00, LS = 01, FS = 10
            SPEED: u2,
            /// VBUS over current detected
            VBUS_OVER_CURR: u1,
            /// Host: Device has initiated a remote resume. Device: host has initiated a resume.
            RESUME: u1,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Device: connected
            CONNECTED: u1,
            /// Device: Setup packet received
            SETUP_REC: u1,
            /// Transaction complete.\n\n
            /// Raised by device if:\n\n
            /// * An IN or OUT packet is sent with the `LAST_BUFF` bit set in the buffer control
            /// register\n\n
            /// Raised by host if:\n\n
            /// * A setup packet is sent when no data in or data out transaction follows * An IN
            /// packet is received and the `LAST_BUFF` bit is set in the buffer control register
            /// * An IN packet is received with zero length * An OUT packet is sent and the
            /// `LAST_BUFF` bit is set
            TRANS_COMPLETE: u1,
            /// Device: bus reset received
            BUS_RESET: u1,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            /// CRC Error. Raised by the Serial RX engine.
            CRC_ERROR: u1,
            /// Bit Stuff Error. Raised by the Serial RX engine.
            BIT_STUFF_ERROR: u1,
            /// RX overflow is raised by the Serial RX engine if the incoming data is too fast.
            RX_OVERFLOW: u1,
            /// RX timeout is raised by both the host and device if an ACK is not received in
            /// the maximum time specified by the USB spec.
            RX_TIMEOUT: u1,
            /// Host: NAK received
            NAK_REC: u1,
            /// Host: STALL received
            STALL_REC: u1,
            /// ACK received. Raised by both host and device.
            ACK_REC: u1,
            /// Data Sequence Error.\n\n
            /// The device can raise a sequence error in the following conditions:\n\n
            /// * A SETUP packet is received followed by a DATA1 packet (data phase should
            /// always be DATA0) * An OUT packet is received from the host but doesn't match the
            /// data pid in the buffer control register read from DPSRAM\n\n
            /// The host can raise a data sequence error in the following conditions:\n\n
            /// * An IN packet from the device has the wrong data PID
            DATA_SEQ_ERROR: u1,
        }), base_address + 0x50);

        /// address: 0x50110054
        /// interrupt endpoint control register
        pub const INT_EP_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            /// Host: Enable interrupt endpoint 1 -> 15
            INT_EP_ACTIVE: u15,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0x54);

        /// address: 0x50110058
        /// Buffer status register. A bit set here indicates that a buffer has completed on
        /// the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers
        /// to be completed, so clearing the buffer status bit may instantly re set it on
        /// the next clock cycle.
        pub const BUFF_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            EP0_IN: u1,
            EP0_OUT: u1,
            EP1_IN: u1,
            EP1_OUT: u1,
            EP2_IN: u1,
            EP2_OUT: u1,
            EP3_IN: u1,
            EP3_OUT: u1,
            EP4_IN: u1,
            EP4_OUT: u1,
            EP5_IN: u1,
            EP5_OUT: u1,
            EP6_IN: u1,
            EP6_OUT: u1,
            EP7_IN: u1,
            EP7_OUT: u1,
            EP8_IN: u1,
            EP8_OUT: u1,
            EP9_IN: u1,
            EP9_OUT: u1,
            EP10_IN: u1,
            EP10_OUT: u1,
            EP11_IN: u1,
            EP11_OUT: u1,
            EP12_IN: u1,
            EP12_OUT: u1,
            EP13_IN: u1,
            EP13_OUT: u1,
            EP14_IN: u1,
            EP14_OUT: u1,
            EP15_IN: u1,
            EP15_OUT: u1,
        }), base_address + 0x58);

        /// address: 0x5011005c
        /// Which of the double buffers should be handled. Only valid if using an interrupt
        /// per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint
        /// polling because they are only single buffered.
        pub const BUFF_CPU_SHOULD_HANDLE = @intToPtr(*volatile Mmio(32, packed struct {
            EP0_IN: u1,
            EP0_OUT: u1,
            EP1_IN: u1,
            EP1_OUT: u1,
            EP2_IN: u1,
            EP2_OUT: u1,
            EP3_IN: u1,
            EP3_OUT: u1,
            EP4_IN: u1,
            EP4_OUT: u1,
            EP5_IN: u1,
            EP5_OUT: u1,
            EP6_IN: u1,
            EP6_OUT: u1,
            EP7_IN: u1,
            EP7_OUT: u1,
            EP8_IN: u1,
            EP8_OUT: u1,
            EP9_IN: u1,
            EP9_OUT: u1,
            EP10_IN: u1,
            EP10_OUT: u1,
            EP11_IN: u1,
            EP11_OUT: u1,
            EP12_IN: u1,
            EP12_OUT: u1,
            EP13_IN: u1,
            EP13_OUT: u1,
            EP14_IN: u1,
            EP14_OUT: u1,
            EP15_IN: u1,
            EP15_OUT: u1,
        }), base_address + 0x5c);

        /// address: 0x50110060
        /// Device only: Can be set to ignore the buffer control register for this endpoint
        /// in case you would like to revoke a buffer. A NAK will be sent for every access
        /// to the endpoint until this bit is cleared. A corresponding bit in
        /// `EP_ABORT_DONE` is set when it is safe to modify the buffer control register.
        pub const EP_ABORT = @intToPtr(*volatile Mmio(32, packed struct {
            EP0_IN: u1,
            EP0_OUT: u1,
            EP1_IN: u1,
            EP1_OUT: u1,
            EP2_IN: u1,
            EP2_OUT: u1,
            EP3_IN: u1,
            EP3_OUT: u1,
            EP4_IN: u1,
            EP4_OUT: u1,
            EP5_IN: u1,
            EP5_OUT: u1,
            EP6_IN: u1,
            EP6_OUT: u1,
            EP7_IN: u1,
            EP7_OUT: u1,
            EP8_IN: u1,
            EP8_OUT: u1,
            EP9_IN: u1,
            EP9_OUT: u1,
            EP10_IN: u1,
            EP10_OUT: u1,
            EP11_IN: u1,
            EP11_OUT: u1,
            EP12_IN: u1,
            EP12_OUT: u1,
            EP13_IN: u1,
            EP13_OUT: u1,
            EP14_IN: u1,
            EP14_OUT: u1,
            EP15_IN: u1,
            EP15_OUT: u1,
        }), base_address + 0x60);

        /// address: 0x50110064
        /// Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle
        /// so the programmer knows it is safe to modify the buffer control register.
        pub const EP_ABORT_DONE = @intToPtr(*volatile Mmio(32, packed struct {
            EP0_IN: u1,
            EP0_OUT: u1,
            EP1_IN: u1,
            EP1_OUT: u1,
            EP2_IN: u1,
            EP2_OUT: u1,
            EP3_IN: u1,
            EP3_OUT: u1,
            EP4_IN: u1,
            EP4_OUT: u1,
            EP5_IN: u1,
            EP5_OUT: u1,
            EP6_IN: u1,
            EP6_OUT: u1,
            EP7_IN: u1,
            EP7_OUT: u1,
            EP8_IN: u1,
            EP8_OUT: u1,
            EP9_IN: u1,
            EP9_OUT: u1,
            EP10_IN: u1,
            EP10_OUT: u1,
            EP11_IN: u1,
            EP11_OUT: u1,
            EP12_IN: u1,
            EP12_OUT: u1,
            EP13_IN: u1,
            EP13_OUT: u1,
            EP14_IN: u1,
            EP14_OUT: u1,
            EP15_IN: u1,
            EP15_OUT: u1,
        }), base_address + 0x64);

        /// address: 0x50110068
        /// Device: this bit must be set in conjunction with the `STALL` bit in the buffer
        /// control register to send a STALL on EP0. The device controller clears these bits
        /// when a SETUP packet is received because the USB spec requires that a STALL
        /// condition is cleared when a SETUP packet is received.
        pub const EP_STALL_ARM = @intToPtr(*volatile Mmio(32, packed struct {
            EP0_IN: u1,
            EP0_OUT: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
        }), base_address + 0x68);

        /// address: 0x5011006c
        /// Used by the host controller. Sets the wait time in microseconds before trying
        /// again if the device replies with a NAK.
        pub const NAK_POLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// NAK polling interval for a low speed device
            DELAY_LS: u10,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            /// NAK polling interval for a full speed device
            DELAY_FS: u10,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
        }), base_address + 0x6c);

        /// address: 0x50110070
        /// Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For
        /// EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the
        /// endpoint control register.
        pub const EP_STATUS_STALL_NAK = @intToPtr(*volatile Mmio(32, packed struct {
            EP0_IN: u1,
            EP0_OUT: u1,
            EP1_IN: u1,
            EP1_OUT: u1,
            EP2_IN: u1,
            EP2_OUT: u1,
            EP3_IN: u1,
            EP3_OUT: u1,
            EP4_IN: u1,
            EP4_OUT: u1,
            EP5_IN: u1,
            EP5_OUT: u1,
            EP6_IN: u1,
            EP6_OUT: u1,
            EP7_IN: u1,
            EP7_OUT: u1,
            EP8_IN: u1,
            EP8_OUT: u1,
            EP9_IN: u1,
            EP9_OUT: u1,
            EP10_IN: u1,
            EP10_OUT: u1,
            EP11_IN: u1,
            EP11_OUT: u1,
            EP12_IN: u1,
            EP12_OUT: u1,
            EP13_IN: u1,
            EP13_OUT: u1,
            EP14_IN: u1,
            EP14_OUT: u1,
            EP15_IN: u1,
            EP15_OUT: u1,
        }), base_address + 0x70);

        /// address: 0x50110074
        /// Where to connect the USB controller. Should be to_phy by default.
        pub const USB_MUXING = @intToPtr(*volatile Mmio(32, packed struct {
            TO_PHY: u1,
            TO_EXTPHY: u1,
            TO_DIGITAL_PAD: u1,
            SOFTCON: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x74);

        /// address: 0x50110078
        /// Overrides for the power signals in the event that the VBUS signals are not
        /// hooked up to GPIO. Set the value of the override and then the override enable to
        /// switch over to the override value.
        pub const USB_PWR = @intToPtr(*volatile Mmio(32, packed struct {
            VBUS_EN: u1,
            VBUS_EN_OVERRIDE_EN: u1,
            VBUS_DETECT: u1,
            VBUS_DETECT_OVERRIDE_EN: u1,
            OVERCURR_DETECT: u1,
            OVERCURR_DETECT_EN: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
        }), base_address + 0x78);

        /// address: 0x5011007c
        /// This register allows for direct control of the USB phy. Use in conjunction with
        /// usbphy_direct_override register to enable each override bit.
        pub const USBPHY_DIRECT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the second DP pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2
            DP_PULLUP_HISEL: u1,
            /// DP pull up enable
            DP_PULLUP_EN: u1,
            /// DP pull down enable
            DP_PULLDN_EN: u1,
            reserved0: u1 = 0,
            /// Enable the second DM pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2
            DM_PULLUP_HISEL: u1,
            /// DM pull up enable
            DM_PULLUP_EN: u1,
            /// DM pull down enable
            DM_PULLDN_EN: u1,
            reserved1: u1 = 0,
            /// Output enable. If TX_DIFFMODE=1, OE for DPP/DPM diff pair. 0 - DPP/DPM in Hi-Z
            /// state; 1 - DPP/DPM driving\n
            /// If TX_DIFFMODE=0, OE for DPP only. 0 - DPP in Hi-Z state; 1 - DPP driving
            TX_DP_OE: u1,
            /// Output enable. If TX_DIFFMODE=1, Ignored.\n
            /// If TX_DIFFMODE=0, OE for DPM only. 0 - DPM in Hi-Z state; 1 - DPM driving
            TX_DM_OE: u1,
            /// Output data. If TX_DIFFMODE=1, Drives DPP/DPM diff pair. TX_DP_OE=1 to enable
            /// drive. DPP=TX_DP, DPM=~TX_DP\n
            /// If TX_DIFFMODE=0, Drives DPP only. TX_DP_OE=1 to enable drive. DPP=TX_DP
            TX_DP: u1,
            /// Output data. TX_DIFFMODE=1, Ignored\n
            /// TX_DIFFMODE=0, Drives DPM only. TX_DM_OE=1 to enable drive. DPM=TX_DM
            TX_DM: u1,
            /// RX power down override (if override enable is set). 1 = powered down.
            RX_PD: u1,
            /// TX power down override (if override enable is set). 1 = powered down.
            TX_PD: u1,
            /// TX_FSSLEW=0: Low speed slew rate\n
            /// TX_FSSLEW=1: Full speed slew rate
            TX_FSSLEW: u1,
            /// TX_DIFFMODE=0: Single ended mode\n
            /// TX_DIFFMODE=1: Differential drive mode (TX_DM, TX_DM_OE ignored)
            TX_DIFFMODE: u1,
            /// Differential RX
            RX_DD: u1,
            /// DPP pin state
            RX_DP: u1,
            /// DPM pin state
            RX_DM: u1,
            /// DP overcurrent
            DP_OVCN: u1,
            /// DM overcurrent
            DM_OVCN: u1,
            /// DP over voltage
            DP_OVV: u1,
            /// DM over voltage
            DM_OVV: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
        }), base_address + 0x7c);

        /// address: 0x50110080
        /// Override enable for each control in usbphy_direct
        pub const USBPHY_DIRECT_OVERRIDE = @intToPtr(*volatile Mmio(32, packed struct {
            DP_PULLUP_HISEL_OVERRIDE_EN: u1,
            DM_PULLUP_HISEL_OVERRIDE_EN: u1,
            DP_PULLUP_EN_OVERRIDE_EN: u1,
            DP_PULLDN_EN_OVERRIDE_EN: u1,
            DM_PULLDN_EN_OVERRIDE_EN: u1,
            TX_DP_OE_OVERRIDE_EN: u1,
            TX_DM_OE_OVERRIDE_EN: u1,
            TX_DP_OVERRIDE_EN: u1,
            TX_DM_OVERRIDE_EN: u1,
            RX_PD_OVERRIDE_EN: u1,
            TX_PD_OVERRIDE_EN: u1,
            TX_FSSLEW_OVERRIDE_EN: u1,
            DM_PULLUP_OVERRIDE_EN: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            TX_DIFFMODE_OVERRIDE_EN: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
        }), base_address + 0x80);

        /// address: 0x50110084
        /// Used to adjust trim values of USB phy pull down resistors.
        pub const USBPHY_TRIM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Value to drive to USB PHY\n
            /// DP pulldown resistor trim control\n
            /// Experimental data suggests that the reset value will work, but this register
            /// allows adjustment if required
            DP_PULLDN_TRIM: u5,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            /// Value to drive to USB PHY\n
            /// DM pulldown resistor trim control\n
            /// Experimental data suggests that the reset value will work, but this register
            /// allows adjustment if required
            DM_PULLDN_TRIM: u5,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
        }), base_address + 0x84);

        /// address: 0x5011008c
        /// Raw Interrupts
        pub const INTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host: raised when a device is connected or disconnected (i.e. when
            /// SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
            HOST_CONN_DIS: u1,
            /// Host: raised when a device wakes up the host. Cleared by writing to
            /// SIE_STATUS.RESUME
            HOST_RESUME: u1,
            /// Host: raised every time the host sends a SOF (Start of Frame). Cleared by
            /// reading SOF_RD
            HOST_SOF: u1,
            /// Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this
            /// bit.
            TRANS_COMPLETE: u1,
            /// Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
            /// BUFF_STATUS.
            BUFF_STATUS: u1,
            /// Source: SIE_STATUS.DATA_SEQ_ERROR
            ERROR_DATA_SEQ: u1,
            /// Source: SIE_STATUS.RX_TIMEOUT
            ERROR_RX_TIMEOUT: u1,
            /// Source: SIE_STATUS.RX_OVERFLOW
            ERROR_RX_OVERFLOW: u1,
            /// Source: SIE_STATUS.BIT_STUFF_ERROR
            ERROR_BIT_STUFF: u1,
            /// Source: SIE_STATUS.CRC_ERROR
            ERROR_CRC: u1,
            /// Source: SIE_STATUS.STALL_REC
            STALL: u1,
            /// Source: SIE_STATUS.VBUS_DETECTED
            VBUS_DETECT: u1,
            /// Source: SIE_STATUS.BUS_RESET
            BUS_RESET: u1,
            /// Set when the device connection state changes. Cleared by writing to
            /// SIE_STATUS.CONNECTED
            DEV_CONN_DIS: u1,
            /// Set when the device suspend state changes. Cleared by writing to
            /// SIE_STATUS.SUSPENDED
            DEV_SUSPEND: u1,
            /// Set when the device receives a resume from the host. Cleared by writing to
            /// SIE_STATUS.RESUME
            DEV_RESUME_FROM_HOST: u1,
            /// Device. Source: SIE_STATUS.SETUP_REC
            SETUP_REQ: u1,
            /// Set every time the device receives a SOF (Start of Frame) packet. Cleared by
            /// reading SOF_RD
            DEV_SOF: u1,
            /// Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
            /// ABORT_DONE.
            ABORT_DONE: u1,
            /// Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in
            /// EP_STATUS_STALL_NAK.
            EP_STALL_NAK: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
        }), base_address + 0x8c);

        /// address: 0x50110090
        /// Interrupt Enable
        pub const INTE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host: raised when a device is connected or disconnected (i.e. when
            /// SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
            HOST_CONN_DIS: u1,
            /// Host: raised when a device wakes up the host. Cleared by writing to
            /// SIE_STATUS.RESUME
            HOST_RESUME: u1,
            /// Host: raised every time the host sends a SOF (Start of Frame). Cleared by
            /// reading SOF_RD
            HOST_SOF: u1,
            /// Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this
            /// bit.
            TRANS_COMPLETE: u1,
            /// Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
            /// BUFF_STATUS.
            BUFF_STATUS: u1,
            /// Source: SIE_STATUS.DATA_SEQ_ERROR
            ERROR_DATA_SEQ: u1,
            /// Source: SIE_STATUS.RX_TIMEOUT
            ERROR_RX_TIMEOUT: u1,
            /// Source: SIE_STATUS.RX_OVERFLOW
            ERROR_RX_OVERFLOW: u1,
            /// Source: SIE_STATUS.BIT_STUFF_ERROR
            ERROR_BIT_STUFF: u1,
            /// Source: SIE_STATUS.CRC_ERROR
            ERROR_CRC: u1,
            /// Source: SIE_STATUS.STALL_REC
            STALL: u1,
            /// Source: SIE_STATUS.VBUS_DETECTED
            VBUS_DETECT: u1,
            /// Source: SIE_STATUS.BUS_RESET
            BUS_RESET: u1,
            /// Set when the device connection state changes. Cleared by writing to
            /// SIE_STATUS.CONNECTED
            DEV_CONN_DIS: u1,
            /// Set when the device suspend state changes. Cleared by writing to
            /// SIE_STATUS.SUSPENDED
            DEV_SUSPEND: u1,
            /// Set when the device receives a resume from the host. Cleared by writing to
            /// SIE_STATUS.RESUME
            DEV_RESUME_FROM_HOST: u1,
            /// Device. Source: SIE_STATUS.SETUP_REC
            SETUP_REQ: u1,
            /// Set every time the device receives a SOF (Start of Frame) packet. Cleared by
            /// reading SOF_RD
            DEV_SOF: u1,
            /// Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
            /// ABORT_DONE.
            ABORT_DONE: u1,
            /// Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in
            /// EP_STATUS_STALL_NAK.
            EP_STALL_NAK: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
        }), base_address + 0x90);

        /// address: 0x50110094
        /// Interrupt Force
        pub const INTF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host: raised when a device is connected or disconnected (i.e. when
            /// SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
            HOST_CONN_DIS: u1,
            /// Host: raised when a device wakes up the host. Cleared by writing to
            /// SIE_STATUS.RESUME
            HOST_RESUME: u1,
            /// Host: raised every time the host sends a SOF (Start of Frame). Cleared by
            /// reading SOF_RD
            HOST_SOF: u1,
            /// Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this
            /// bit.
            TRANS_COMPLETE: u1,
            /// Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
            /// BUFF_STATUS.
            BUFF_STATUS: u1,
            /// Source: SIE_STATUS.DATA_SEQ_ERROR
            ERROR_DATA_SEQ: u1,
            /// Source: SIE_STATUS.RX_TIMEOUT
            ERROR_RX_TIMEOUT: u1,
            /// Source: SIE_STATUS.RX_OVERFLOW
            ERROR_RX_OVERFLOW: u1,
            /// Source: SIE_STATUS.BIT_STUFF_ERROR
            ERROR_BIT_STUFF: u1,
            /// Source: SIE_STATUS.CRC_ERROR
            ERROR_CRC: u1,
            /// Source: SIE_STATUS.STALL_REC
            STALL: u1,
            /// Source: SIE_STATUS.VBUS_DETECTED
            VBUS_DETECT: u1,
            /// Source: SIE_STATUS.BUS_RESET
            BUS_RESET: u1,
            /// Set when the device connection state changes. Cleared by writing to
            /// SIE_STATUS.CONNECTED
            DEV_CONN_DIS: u1,
            /// Set when the device suspend state changes. Cleared by writing to
            /// SIE_STATUS.SUSPENDED
            DEV_SUSPEND: u1,
            /// Set when the device receives a resume from the host. Cleared by writing to
            /// SIE_STATUS.RESUME
            DEV_RESUME_FROM_HOST: u1,
            /// Device. Source: SIE_STATUS.SETUP_REC
            SETUP_REQ: u1,
            /// Set every time the device receives a SOF (Start of Frame) packet. Cleared by
            /// reading SOF_RD
            DEV_SOF: u1,
            /// Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
            /// ABORT_DONE.
            ABORT_DONE: u1,
            /// Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in
            /// EP_STATUS_STALL_NAK.
            EP_STALL_NAK: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
        }), base_address + 0x94);

        /// address: 0x50110098
        /// Interrupt status after masking & forcing
        pub const INTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host: raised when a device is connected or disconnected (i.e. when
            /// SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
            HOST_CONN_DIS: u1,
            /// Host: raised when a device wakes up the host. Cleared by writing to
            /// SIE_STATUS.RESUME
            HOST_RESUME: u1,
            /// Host: raised every time the host sends a SOF (Start of Frame). Cleared by
            /// reading SOF_RD
            HOST_SOF: u1,
            /// Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this
            /// bit.
            TRANS_COMPLETE: u1,
            /// Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
            /// BUFF_STATUS.
            BUFF_STATUS: u1,
            /// Source: SIE_STATUS.DATA_SEQ_ERROR
            ERROR_DATA_SEQ: u1,
            /// Source: SIE_STATUS.RX_TIMEOUT
            ERROR_RX_TIMEOUT: u1,
            /// Source: SIE_STATUS.RX_OVERFLOW
            ERROR_RX_OVERFLOW: u1,
            /// Source: SIE_STATUS.BIT_STUFF_ERROR
            ERROR_BIT_STUFF: u1,
            /// Source: SIE_STATUS.CRC_ERROR
            ERROR_CRC: u1,
            /// Source: SIE_STATUS.STALL_REC
            STALL: u1,
            /// Source: SIE_STATUS.VBUS_DETECTED
            VBUS_DETECT: u1,
            /// Source: SIE_STATUS.BUS_RESET
            BUS_RESET: u1,
            /// Set when the device connection state changes. Cleared by writing to
            /// SIE_STATUS.CONNECTED
            DEV_CONN_DIS: u1,
            /// Set when the device suspend state changes. Cleared by writing to
            /// SIE_STATUS.SUSPENDED
            DEV_SUSPEND: u1,
            /// Set when the device receives a resume from the host. Cleared by writing to
            /// SIE_STATUS.RESUME
            DEV_RESUME_FROM_HOST: u1,
            /// Device. Source: SIE_STATUS.SETUP_REC
            SETUP_REQ: u1,
            /// Set every time the device receives a SOF (Start of Frame) packet. Cleared by
            /// reading SOF_RD
            DEV_SOF: u1,
            /// Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
            /// ABORT_DONE.
            ABORT_DONE: u1,
            /// Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in
            /// EP_STATUS_STALL_NAK.
            EP_STALL_NAK: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
        }), base_address + 0x98);
    };

    /// Programmable IO block
    pub const PIO0 = struct {
        pub const base_address = 0x50200000;
        pub const version = "1";

        /// address: 0x50200000
        /// PIO control register
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable/disable each of the four state machines by writing 1/0 to each of these
            /// four bits. When disabled, a state machine will cease executing instructions,
            /// except those written directly to SMx_INSTR by the system. Multiple bits can be
            /// set/cleared at once to run/halt multiple state machines simultaneously.
            SM_ENABLE: u4,
            /// Write 1 to instantly clear internal SM state which may be otherwise difficult to
            /// access and will affect future execution.\n\n
            /// Specifically, the following are cleared: input and output shift counters; the
            /// contents of the input shift register; the delay counter; the waiting-on-IRQ
            /// state; any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any
            /// pin write left asserted due to OUT_STICKY.
            SM_RESTART: u4,
            /// Restart a state machine's clock divider from an initial phase of 0. Clock
            /// dividers are free-running, so once started, their output (including fractional
            /// jitter) is completely determined by the integer/fractional divisor configured in
            /// SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor
            /// are restarted simultaneously, by writing multiple 1 bits to this field, the
            /// execution clocks of those state machines will run in precise lockstep.\n\n
            /// Note that setting/clearing SM_ENABLE does not stop the clock divider from
            /// running, so once multiple state machines' clocks are synchronised, it is safe to
            /// disable/reenable a state machine, whilst keeping the clock dividers in sync.\n\n
            /// Note also that CLKDIV_RESTART can be written to whilst the state machine is
            /// running, and this is useful to resynchronise clock dividers after the divisors
            /// (SMx_CLKDIV) have been changed on-the-fly.
            CLKDIV_RESTART: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x50200004
        /// FIFO status register
        pub const FSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// State machine RX FIFO is full
            RXFULL: u4,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// State machine RX FIFO is empty
            RXEMPTY: u4,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// State machine TX FIFO is full
            TXFULL: u4,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            /// State machine TX FIFO is empty
            TXEMPTY: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x50200008
        /// FIFO debug register
        pub const FDEBUG = @intToPtr(*volatile Mmio(32, packed struct {
            /// State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with
            /// autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO
            /// took place, in which case the state machine has dropped data. Write 1 to clear.
            RXSTALL: u4,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to
            /// clear. Note that read-on-empty does not perturb the state of the FIFO in any
            /// way, but the data returned by reading from an empty FIFO is undefined, so this
            /// flag generally only becomes set due to some kind of software error.
            RXUNDER: u4,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to
            /// clear. Note that write-on-full does not alter the state or contents of the FIFO
            /// in any way, but the data that the system attempted to write is dropped, so if
            /// this flag is set, your software has quite likely dropped some data on the floor.
            TXOVER: u4,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            /// State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT
            /// with autopull enabled. Write 1 to clear.
            TXSTALL: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x5020000c
        /// FIFO levels
        pub const FLEVEL = @intToPtr(*volatile Mmio(32, packed struct {
            TX0: u4,
            RX0: u4,
            TX1: u4,
            RX1: u4,
            TX2: u4,
            RX2: u4,
            TX3: u4,
            RX3: u4,
        }), base_address + 0xc);

        /// address: 0x50200010
        /// Direct write access to the TX FIFO for this state machine. Each write pushes one
        /// word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO
        /// state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
        pub const TXF0 = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x50200014
        /// Direct write access to the TX FIFO for this state machine. Each write pushes one
        /// word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO
        /// state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
        pub const TXF1 = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x50200018
        /// Direct write access to the TX FIFO for this state machine. Each write pushes one
        /// word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO
        /// state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
        pub const TXF2 = @intToPtr(*volatile u32, base_address + 0x18);

        /// address: 0x5020001c
        /// Direct write access to the TX FIFO for this state machine. Each write pushes one
        /// word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO
        /// state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
        pub const TXF3 = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x50200020
        /// Direct read access to the RX FIFO for this state machine. Each read pops one
        /// word from the FIFO. Attempting to read from an empty FIFO has no effect on the
        /// FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The
        /// data returned to the system on a read from an empty FIFO is undefined.
        pub const RXF0 = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x50200024
        /// Direct read access to the RX FIFO for this state machine. Each read pops one
        /// word from the FIFO. Attempting to read from an empty FIFO has no effect on the
        /// FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The
        /// data returned to the system on a read from an empty FIFO is undefined.
        pub const RXF1 = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x50200028
        /// Direct read access to the RX FIFO for this state machine. Each read pops one
        /// word from the FIFO. Attempting to read from an empty FIFO has no effect on the
        /// FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The
        /// data returned to the system on a read from an empty FIFO is undefined.
        pub const RXF2 = @intToPtr(*volatile u32, base_address + 0x28);

        /// address: 0x5020002c
        /// Direct read access to the RX FIFO for this state machine. Each read pops one
        /// word from the FIFO. Attempting to read from an empty FIFO has no effect on the
        /// FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The
        /// data returned to the system on a read from an empty FIFO is undefined.
        pub const RXF3 = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x50200030
        /// State machine IRQ flags register. Write 1 to clear. There are 8 state machine
        /// IRQ flags, which can be set, cleared, and waited on by the state machines.
        /// There's no fixed association between flags and state machines -- any state
        /// machine can use any flag.\n\n
        /// Any of the 8 flags can be used for timing synchronisation between state
        /// machines, using IRQ and WAIT instructions. The lower four of these flags are
        /// also routed out to system-level interrupt requests, alongside FIFO status
        /// interrupts -- see e.g. IRQ0_INTE.
        pub const IRQ = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x30);

        /// address: 0x50200034
        /// Writing a 1 to each of these bits will forcibly assert the corresponding IRQ.
        /// Note this is different to the INTF register: writing here affects PIO internal
        /// state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and
        /// is not visible to the state machines.
        pub const IRQ_FORCE = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x34);

        /// address: 0x50200038
        /// There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic
        /// from metastabilities. This increases input delay, and for fast synchronous IO
        /// (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this
        /// register corresponds to one GPIO.\n
        /// 0 -> input is synchronized (default)\n
        /// 1 -> synchronizer is bypassed\n
        /// If in doubt, leave this register as all zeroes.
        pub const INPUT_SYNC_BYPASS = @intToPtr(*volatile u32, base_address + 0x38);

        /// address: 0x5020003c
        /// Read to sample the pad output values PIO is currently driving to the GPIOs. On
        /// RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
        pub const DBG_PADOUT = @intToPtr(*volatile u32, base_address + 0x3c);

        /// address: 0x50200040
        /// Read to sample the pad output enables (direction) PIO is currently driving to
        /// the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are
        /// hardwired to 0.
        pub const DBG_PADOE = @intToPtr(*volatile u32, base_address + 0x40);

        /// address: 0x50200044
        /// The PIO hardware has some free parameters that may vary between chip products.\n
        /// These should be provided in the chip datasheet, but are also exposed here.
        pub const DBG_CFGINFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// The depth of the state machine TX/RX FIFOs, measured in words.\n
            /// Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double\n
            /// this depth.
            FIFO_DEPTH: u6,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// The number of state machines this PIO instance is equipped with.
            SM_COUNT: u4,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            /// The size of the instruction memory, measured in units of one instruction
            IMEM_SIZE: u6,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
        }), base_address + 0x44);

        /// address: 0x50200048
        /// Write-only access to instruction memory location 0
        pub const INSTR_MEM0 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x48);

        /// address: 0x5020004c
        /// Write-only access to instruction memory location 1
        pub const INSTR_MEM1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x4c);

        /// address: 0x50200050
        /// Write-only access to instruction memory location 2
        pub const INSTR_MEM2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x50);

        /// address: 0x50200054
        /// Write-only access to instruction memory location 3
        pub const INSTR_MEM3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x54);

        /// address: 0x50200058
        /// Write-only access to instruction memory location 4
        pub const INSTR_MEM4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x58);

        /// address: 0x5020005c
        /// Write-only access to instruction memory location 5
        pub const INSTR_MEM5 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x5c);

        /// address: 0x50200060
        /// Write-only access to instruction memory location 6
        pub const INSTR_MEM6 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x60);

        /// address: 0x50200064
        /// Write-only access to instruction memory location 7
        pub const INSTR_MEM7 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x64);

        /// address: 0x50200068
        /// Write-only access to instruction memory location 8
        pub const INSTR_MEM8 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x68);

        /// address: 0x5020006c
        /// Write-only access to instruction memory location 9
        pub const INSTR_MEM9 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x6c);

        /// address: 0x50200070
        /// Write-only access to instruction memory location 10
        pub const INSTR_MEM10 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x70);

        /// address: 0x50200074
        /// Write-only access to instruction memory location 11
        pub const INSTR_MEM11 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x74);

        /// address: 0x50200078
        /// Write-only access to instruction memory location 12
        pub const INSTR_MEM12 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x78);

        /// address: 0x5020007c
        /// Write-only access to instruction memory location 13
        pub const INSTR_MEM13 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x7c);

        /// address: 0x50200080
        /// Write-only access to instruction memory location 14
        pub const INSTR_MEM14 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x80);

        /// address: 0x50200084
        /// Write-only access to instruction memory location 15
        pub const INSTR_MEM15 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x84);

        /// address: 0x50200088
        /// Write-only access to instruction memory location 16
        pub const INSTR_MEM16 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x88);

        /// address: 0x5020008c
        /// Write-only access to instruction memory location 17
        pub const INSTR_MEM17 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x8c);

        /// address: 0x50200090
        /// Write-only access to instruction memory location 18
        pub const INSTR_MEM18 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x90);

        /// address: 0x50200094
        /// Write-only access to instruction memory location 19
        pub const INSTR_MEM19 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x94);

        /// address: 0x50200098
        /// Write-only access to instruction memory location 20
        pub const INSTR_MEM20 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x98);

        /// address: 0x5020009c
        /// Write-only access to instruction memory location 21
        pub const INSTR_MEM21 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x9c);

        /// address: 0x502000a0
        /// Write-only access to instruction memory location 22
        pub const INSTR_MEM22 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xa0);

        /// address: 0x502000a4
        /// Write-only access to instruction memory location 23
        pub const INSTR_MEM23 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xa4);

        /// address: 0x502000a8
        /// Write-only access to instruction memory location 24
        pub const INSTR_MEM24 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xa8);

        /// address: 0x502000ac
        /// Write-only access to instruction memory location 25
        pub const INSTR_MEM25 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xac);

        /// address: 0x502000b0
        /// Write-only access to instruction memory location 26
        pub const INSTR_MEM26 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xb0);

        /// address: 0x502000b4
        /// Write-only access to instruction memory location 27
        pub const INSTR_MEM27 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xb4);

        /// address: 0x502000b8
        /// Write-only access to instruction memory location 28
        pub const INSTR_MEM28 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xb8);

        /// address: 0x502000bc
        /// Write-only access to instruction memory location 29
        pub const INSTR_MEM29 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xbc);

        /// address: 0x502000c0
        /// Write-only access to instruction memory location 30
        pub const INSTR_MEM30 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc0);

        /// address: 0x502000c4
        /// Write-only access to instruction memory location 31
        pub const INSTR_MEM31 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc4);

        /// address: 0x502000c8
        /// Clock divisor register for state machine 0\n
        /// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
        pub const SM0_CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Fractional part of clock divisor
            FRAC: u8,
            /// Effective frequency is sysclk/(int + frac/256).\n
            /// Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
            INT: u16,
        }), base_address + 0xc8);

        /// address: 0x502000cc
        /// Execution/behavioural settings for state machine 0
        pub const SM0_EXECCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparison level for the MOV x, STATUS instruction
            STATUS_N: u4,
            /// Comparison used for the MOV x, STATUS instruction.
            STATUS_SEL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// After reaching wrap_top, execution is wrapped to this address.
            WRAP_BOTTOM: u5,
            /// After reaching this address, execution is wrapped to wrap_bottom.\n
            /// If the instruction is a jump, and the jump condition is true, the jump takes
            /// priority.
            WRAP_TOP: u5,
            /// Continuously assert the most recent OUT/SET to the pins
            OUT_STICKY: u1,
            /// If 1, use a bit of OUT data as an auxiliary write enable\n
            /// When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n
            /// deassert the latest pin write. This can create useful masking/override
            /// behaviour\n
            /// due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
            INLINE_OUT_EN: u1,
            /// Which data bit to use for inline OUT enable
            OUT_EN_SEL: u5,
            /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
            JMP_PIN: u5,
            /// If 1, side-set data is asserted to pin directions, instead of pin values
            SIDE_PINDIR: u1,
            /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set
            /// enable, rather than a side-set data bit. This allows instructions to perform
            /// side-set optionally, rather than on every instruction, but the maximum possible
            /// side-set width is reduced from 5 to 4. Note that the value of
            /// PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
            SIDE_EN: u1,
            /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state
            /// machine. Will clear to 0 once this instruction completes.
            EXEC_STALLED: u1,
        }), base_address + 0xcc);

        /// address: 0x502000d0
        /// Control behaviour of the input/output shift registers for state machine 0
        pub const SM0_SHIFTCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            /// Push automatically when the input shift register is filled, i.e. on an IN
            /// instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
            AUTOPUSH: u1,
            /// Pull automatically when the output shift register is emptied, i.e. on or
            /// following an OUT instruction which causes the output shift counter to reach or
            /// exceed PULL_THRESH.
            AUTOPULL: u1,
            /// 1 = shift input shift register to right (data enters from left). 0 = to left.
            IN_SHIFTDIR: u1,
            /// 1 = shift out of output shift register to right. 0 = to left.
            OUT_SHIFTDIR: u1,
            /// Number of bits shifted into ISR before autopush, or conditional push (PUSH
            /// IFFULL), will take place.\n
            /// Write 0 for value of 32.
            PUSH_THRESH: u5,
            /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL
            /// IFEMPTY), will take place.\n
            /// Write 0 for value of 32.
            PULL_THRESH: u5,
            /// When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n
            /// RX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_TX: u1,
            /// When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n
            /// TX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_RX: u1,
        }), base_address + 0xd0);

        /// address: 0x502000d4
        /// Current instruction address of state machine 0
        pub const SM0_ADDR = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xd4);

        /// address: 0x502000d8
        /// Read to see the instruction currently addressed by state machine 0's program
        /// counter\n
        /// Write to execute an instruction immediately (including jumps) and then resume
        /// execution.
        pub const SM0_INSTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xd8);

        /// address: 0x502000dc
        /// State machine pin control
        pub const SM0_PINCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV
            /// PINS instruction. The data written to this pin will always be the
            /// least-significant bit of the OUT or MOV data.
            OUT_BASE: u5,
            /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS
            /// instruction. The data written to this pin is the least-significant bit of the
            /// SET data.
            SET_BASE: u5,
            /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs
            /// of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT)
            /// are used for side-set data, with the remaining LSBs used for delay. The
            /// least-significant bit of the side-set portion is the bit written to this pin,
            /// with more-significant bits written to higher-numbered pins.
            SIDESET_BASE: u5,
            /// The pin which is mapped to the least-significant bit of a state machine's IN
            /// data bus. Higher-numbered pins are mapped to consecutively more-significant data
            /// bits, with a modulo of 32 applied to pin number.
            IN_BASE: u5,
            /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction.
            /// In the range 0 to 32 inclusive.
            OUT_COUNT: u6,
            /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
            SET_COUNT: u3,
            /// The number of MSBs of the Delay/Side-set instruction field which are used for
            /// side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits,
            /// no side-set) and maximum of 5 (all side-set, no delay).
            SIDESET_COUNT: u3,
        }), base_address + 0xdc);

        /// address: 0x502000e0
        /// Clock divisor register for state machine 1\n
        /// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
        pub const SM1_CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Fractional part of clock divisor
            FRAC: u8,
            /// Effective frequency is sysclk/(int + frac/256).\n
            /// Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
            INT: u16,
        }), base_address + 0xe0);

        /// address: 0x502000e4
        /// Execution/behavioural settings for state machine 1
        pub const SM1_EXECCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparison level for the MOV x, STATUS instruction
            STATUS_N: u4,
            /// Comparison used for the MOV x, STATUS instruction.
            STATUS_SEL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// After reaching wrap_top, execution is wrapped to this address.
            WRAP_BOTTOM: u5,
            /// After reaching this address, execution is wrapped to wrap_bottom.\n
            /// If the instruction is a jump, and the jump condition is true, the jump takes
            /// priority.
            WRAP_TOP: u5,
            /// Continuously assert the most recent OUT/SET to the pins
            OUT_STICKY: u1,
            /// If 1, use a bit of OUT data as an auxiliary write enable\n
            /// When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n
            /// deassert the latest pin write. This can create useful masking/override
            /// behaviour\n
            /// due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
            INLINE_OUT_EN: u1,
            /// Which data bit to use for inline OUT enable
            OUT_EN_SEL: u5,
            /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
            JMP_PIN: u5,
            /// If 1, side-set data is asserted to pin directions, instead of pin values
            SIDE_PINDIR: u1,
            /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set
            /// enable, rather than a side-set data bit. This allows instructions to perform
            /// side-set optionally, rather than on every instruction, but the maximum possible
            /// side-set width is reduced from 5 to 4. Note that the value of
            /// PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
            SIDE_EN: u1,
            /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state
            /// machine. Will clear to 0 once this instruction completes.
            EXEC_STALLED: u1,
        }), base_address + 0xe4);

        /// address: 0x502000e8
        /// Control behaviour of the input/output shift registers for state machine 1
        pub const SM1_SHIFTCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            /// Push automatically when the input shift register is filled, i.e. on an IN
            /// instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
            AUTOPUSH: u1,
            /// Pull automatically when the output shift register is emptied, i.e. on or
            /// following an OUT instruction which causes the output shift counter to reach or
            /// exceed PULL_THRESH.
            AUTOPULL: u1,
            /// 1 = shift input shift register to right (data enters from left). 0 = to left.
            IN_SHIFTDIR: u1,
            /// 1 = shift out of output shift register to right. 0 = to left.
            OUT_SHIFTDIR: u1,
            /// Number of bits shifted into ISR before autopush, or conditional push (PUSH
            /// IFFULL), will take place.\n
            /// Write 0 for value of 32.
            PUSH_THRESH: u5,
            /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL
            /// IFEMPTY), will take place.\n
            /// Write 0 for value of 32.
            PULL_THRESH: u5,
            /// When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n
            /// RX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_TX: u1,
            /// When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n
            /// TX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_RX: u1,
        }), base_address + 0xe8);

        /// address: 0x502000ec
        /// Current instruction address of state machine 1
        pub const SM1_ADDR = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xec);

        /// address: 0x502000f0
        /// Read to see the instruction currently addressed by state machine 1's program
        /// counter\n
        /// Write to execute an instruction immediately (including jumps) and then resume
        /// execution.
        pub const SM1_INSTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xf0);

        /// address: 0x502000f4
        /// State machine pin control
        pub const SM1_PINCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV
            /// PINS instruction. The data written to this pin will always be the
            /// least-significant bit of the OUT or MOV data.
            OUT_BASE: u5,
            /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS
            /// instruction. The data written to this pin is the least-significant bit of the
            /// SET data.
            SET_BASE: u5,
            /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs
            /// of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT)
            /// are used for side-set data, with the remaining LSBs used for delay. The
            /// least-significant bit of the side-set portion is the bit written to this pin,
            /// with more-significant bits written to higher-numbered pins.
            SIDESET_BASE: u5,
            /// The pin which is mapped to the least-significant bit of a state machine's IN
            /// data bus. Higher-numbered pins are mapped to consecutively more-significant data
            /// bits, with a modulo of 32 applied to pin number.
            IN_BASE: u5,
            /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction.
            /// In the range 0 to 32 inclusive.
            OUT_COUNT: u6,
            /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
            SET_COUNT: u3,
            /// The number of MSBs of the Delay/Side-set instruction field which are used for
            /// side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits,
            /// no side-set) and maximum of 5 (all side-set, no delay).
            SIDESET_COUNT: u3,
        }), base_address + 0xf4);

        /// address: 0x502000f8
        /// Clock divisor register for state machine 2\n
        /// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
        pub const SM2_CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Fractional part of clock divisor
            FRAC: u8,
            /// Effective frequency is sysclk/(int + frac/256).\n
            /// Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
            INT: u16,
        }), base_address + 0xf8);

        /// address: 0x502000fc
        /// Execution/behavioural settings for state machine 2
        pub const SM2_EXECCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparison level for the MOV x, STATUS instruction
            STATUS_N: u4,
            /// Comparison used for the MOV x, STATUS instruction.
            STATUS_SEL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// After reaching wrap_top, execution is wrapped to this address.
            WRAP_BOTTOM: u5,
            /// After reaching this address, execution is wrapped to wrap_bottom.\n
            /// If the instruction is a jump, and the jump condition is true, the jump takes
            /// priority.
            WRAP_TOP: u5,
            /// Continuously assert the most recent OUT/SET to the pins
            OUT_STICKY: u1,
            /// If 1, use a bit of OUT data as an auxiliary write enable\n
            /// When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n
            /// deassert the latest pin write. This can create useful masking/override
            /// behaviour\n
            /// due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
            INLINE_OUT_EN: u1,
            /// Which data bit to use for inline OUT enable
            OUT_EN_SEL: u5,
            /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
            JMP_PIN: u5,
            /// If 1, side-set data is asserted to pin directions, instead of pin values
            SIDE_PINDIR: u1,
            /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set
            /// enable, rather than a side-set data bit. This allows instructions to perform
            /// side-set optionally, rather than on every instruction, but the maximum possible
            /// side-set width is reduced from 5 to 4. Note that the value of
            /// PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
            SIDE_EN: u1,
            /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state
            /// machine. Will clear to 0 once this instruction completes.
            EXEC_STALLED: u1,
        }), base_address + 0xfc);

        /// address: 0x50200100
        /// Control behaviour of the input/output shift registers for state machine 2
        pub const SM2_SHIFTCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            /// Push automatically when the input shift register is filled, i.e. on an IN
            /// instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
            AUTOPUSH: u1,
            /// Pull automatically when the output shift register is emptied, i.e. on or
            /// following an OUT instruction which causes the output shift counter to reach or
            /// exceed PULL_THRESH.
            AUTOPULL: u1,
            /// 1 = shift input shift register to right (data enters from left). 0 = to left.
            IN_SHIFTDIR: u1,
            /// 1 = shift out of output shift register to right. 0 = to left.
            OUT_SHIFTDIR: u1,
            /// Number of bits shifted into ISR before autopush, or conditional push (PUSH
            /// IFFULL), will take place.\n
            /// Write 0 for value of 32.
            PUSH_THRESH: u5,
            /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL
            /// IFEMPTY), will take place.\n
            /// Write 0 for value of 32.
            PULL_THRESH: u5,
            /// When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n
            /// RX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_TX: u1,
            /// When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n
            /// TX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_RX: u1,
        }), base_address + 0x100);

        /// address: 0x50200104
        /// Current instruction address of state machine 2
        pub const SM2_ADDR = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x104);

        /// address: 0x50200108
        /// Read to see the instruction currently addressed by state machine 2's program
        /// counter\n
        /// Write to execute an instruction immediately (including jumps) and then resume
        /// execution.
        pub const SM2_INSTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x108);

        /// address: 0x5020010c
        /// State machine pin control
        pub const SM2_PINCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV
            /// PINS instruction. The data written to this pin will always be the
            /// least-significant bit of the OUT or MOV data.
            OUT_BASE: u5,
            /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS
            /// instruction. The data written to this pin is the least-significant bit of the
            /// SET data.
            SET_BASE: u5,
            /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs
            /// of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT)
            /// are used for side-set data, with the remaining LSBs used for delay. The
            /// least-significant bit of the side-set portion is the bit written to this pin,
            /// with more-significant bits written to higher-numbered pins.
            SIDESET_BASE: u5,
            /// The pin which is mapped to the least-significant bit of a state machine's IN
            /// data bus. Higher-numbered pins are mapped to consecutively more-significant data
            /// bits, with a modulo of 32 applied to pin number.
            IN_BASE: u5,
            /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction.
            /// In the range 0 to 32 inclusive.
            OUT_COUNT: u6,
            /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
            SET_COUNT: u3,
            /// The number of MSBs of the Delay/Side-set instruction field which are used for
            /// side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits,
            /// no side-set) and maximum of 5 (all side-set, no delay).
            SIDESET_COUNT: u3,
        }), base_address + 0x10c);

        /// address: 0x50200110
        /// Clock divisor register for state machine 3\n
        /// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
        pub const SM3_CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Fractional part of clock divisor
            FRAC: u8,
            /// Effective frequency is sysclk/(int + frac/256).\n
            /// Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
            INT: u16,
        }), base_address + 0x110);

        /// address: 0x50200114
        /// Execution/behavioural settings for state machine 3
        pub const SM3_EXECCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparison level for the MOV x, STATUS instruction
            STATUS_N: u4,
            /// Comparison used for the MOV x, STATUS instruction.
            STATUS_SEL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// After reaching wrap_top, execution is wrapped to this address.
            WRAP_BOTTOM: u5,
            /// After reaching this address, execution is wrapped to wrap_bottom.\n
            /// If the instruction is a jump, and the jump condition is true, the jump takes
            /// priority.
            WRAP_TOP: u5,
            /// Continuously assert the most recent OUT/SET to the pins
            OUT_STICKY: u1,
            /// If 1, use a bit of OUT data as an auxiliary write enable\n
            /// When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n
            /// deassert the latest pin write. This can create useful masking/override
            /// behaviour\n
            /// due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
            INLINE_OUT_EN: u1,
            /// Which data bit to use for inline OUT enable
            OUT_EN_SEL: u5,
            /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
            JMP_PIN: u5,
            /// If 1, side-set data is asserted to pin directions, instead of pin values
            SIDE_PINDIR: u1,
            /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set
            /// enable, rather than a side-set data bit. This allows instructions to perform
            /// side-set optionally, rather than on every instruction, but the maximum possible
            /// side-set width is reduced from 5 to 4. Note that the value of
            /// PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
            SIDE_EN: u1,
            /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state
            /// machine. Will clear to 0 once this instruction completes.
            EXEC_STALLED: u1,
        }), base_address + 0x114);

        /// address: 0x50200118
        /// Control behaviour of the input/output shift registers for state machine 3
        pub const SM3_SHIFTCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            /// Push automatically when the input shift register is filled, i.e. on an IN
            /// instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
            AUTOPUSH: u1,
            /// Pull automatically when the output shift register is emptied, i.e. on or
            /// following an OUT instruction which causes the output shift counter to reach or
            /// exceed PULL_THRESH.
            AUTOPULL: u1,
            /// 1 = shift input shift register to right (data enters from left). 0 = to left.
            IN_SHIFTDIR: u1,
            /// 1 = shift out of output shift register to right. 0 = to left.
            OUT_SHIFTDIR: u1,
            /// Number of bits shifted into ISR before autopush, or conditional push (PUSH
            /// IFFULL), will take place.\n
            /// Write 0 for value of 32.
            PUSH_THRESH: u5,
            /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL
            /// IFEMPTY), will take place.\n
            /// Write 0 for value of 32.
            PULL_THRESH: u5,
            /// When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n
            /// RX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_TX: u1,
            /// When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n
            /// TX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_RX: u1,
        }), base_address + 0x118);

        /// address: 0x5020011c
        /// Current instruction address of state machine 3
        pub const SM3_ADDR = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x11c);

        /// address: 0x50200120
        /// Read to see the instruction currently addressed by state machine 3's program
        /// counter\n
        /// Write to execute an instruction immediately (including jumps) and then resume
        /// execution.
        pub const SM3_INSTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x120);

        /// address: 0x50200124
        /// State machine pin control
        pub const SM3_PINCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV
            /// PINS instruction. The data written to this pin will always be the
            /// least-significant bit of the OUT or MOV data.
            OUT_BASE: u5,
            /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS
            /// instruction. The data written to this pin is the least-significant bit of the
            /// SET data.
            SET_BASE: u5,
            /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs
            /// of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT)
            /// are used for side-set data, with the remaining LSBs used for delay. The
            /// least-significant bit of the side-set portion is the bit written to this pin,
            /// with more-significant bits written to higher-numbered pins.
            SIDESET_BASE: u5,
            /// The pin which is mapped to the least-significant bit of a state machine's IN
            /// data bus. Higher-numbered pins are mapped to consecutively more-significant data
            /// bits, with a modulo of 32 applied to pin number.
            IN_BASE: u5,
            /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction.
            /// In the range 0 to 32 inclusive.
            OUT_COUNT: u6,
            /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
            SET_COUNT: u3,
            /// The number of MSBs of the Delay/Side-set instruction field which are used for
            /// side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits,
            /// no side-set) and maximum of 5 (all side-set, no delay).
            SIDESET_COUNT: u3,
        }), base_address + 0x124);

        /// address: 0x50200128
        /// Raw Interrupts
        pub const INTR = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x128);

        /// address: 0x5020012c
        /// Interrupt Enable for irq0
        pub const IRQ0_INTE = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x12c);

        /// address: 0x50200130
        /// Interrupt Force for irq0
        pub const IRQ0_INTF = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x130);

        /// address: 0x50200134
        /// Interrupt status after masking & forcing for irq0
        pub const IRQ0_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x134);

        /// address: 0x50200138
        /// Interrupt Enable for irq1
        pub const IRQ1_INTE = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x138);

        /// address: 0x5020013c
        /// Interrupt Force for irq1
        pub const IRQ1_INTF = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x13c);

        /// address: 0x50200140
        /// Interrupt status after masking & forcing for irq1
        pub const IRQ1_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x140);
    };
    pub const PIO1 = struct {
        pub const base_address = 0x50300000;

        /// address: 0x50300000
        /// PIO control register
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable/disable each of the four state machines by writing 1/0 to each of these
            /// four bits. When disabled, a state machine will cease executing instructions,
            /// except those written directly to SMx_INSTR by the system. Multiple bits can be
            /// set/cleared at once to run/halt multiple state machines simultaneously.
            SM_ENABLE: u4,
            /// Write 1 to instantly clear internal SM state which may be otherwise difficult to
            /// access and will affect future execution.\n\n
            /// Specifically, the following are cleared: input and output shift counters; the
            /// contents of the input shift register; the delay counter; the waiting-on-IRQ
            /// state; any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any
            /// pin write left asserted due to OUT_STICKY.
            SM_RESTART: u4,
            /// Restart a state machine's clock divider from an initial phase of 0. Clock
            /// dividers are free-running, so once started, their output (including fractional
            /// jitter) is completely determined by the integer/fractional divisor configured in
            /// SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor
            /// are restarted simultaneously, by writing multiple 1 bits to this field, the
            /// execution clocks of those state machines will run in precise lockstep.\n\n
            /// Note that setting/clearing SM_ENABLE does not stop the clock divider from
            /// running, so once multiple state machines' clocks are synchronised, it is safe to
            /// disable/reenable a state machine, whilst keeping the clock dividers in sync.\n\n
            /// Note also that CLKDIV_RESTART can be written to whilst the state machine is
            /// running, and this is useful to resynchronise clock dividers after the divisors
            /// (SMx_CLKDIV) have been changed on-the-fly.
            CLKDIV_RESTART: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x0);

        /// address: 0x50300004
        /// FIFO status register
        pub const FSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// State machine RX FIFO is full
            RXFULL: u4,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// State machine RX FIFO is empty
            RXEMPTY: u4,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// State machine TX FIFO is full
            TXFULL: u4,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            /// State machine TX FIFO is empty
            TXEMPTY: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
        }), base_address + 0x4);

        /// address: 0x50300008
        /// FIFO debug register
        pub const FDEBUG = @intToPtr(*volatile Mmio(32, packed struct {
            /// State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with
            /// autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO
            /// took place, in which case the state machine has dropped data. Write 1 to clear.
            RXSTALL: u4,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            /// RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to
            /// clear. Note that read-on-empty does not perturb the state of the FIFO in any
            /// way, but the data returned by reading from an empty FIFO is undefined, so this
            /// flag generally only becomes set due to some kind of software error.
            RXUNDER: u4,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to
            /// clear. Note that write-on-full does not alter the state or contents of the FIFO
            /// in any way, but the data that the system attempted to write is dropped, so if
            /// this flag is set, your software has quite likely dropped some data on the floor.
            TXOVER: u4,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            /// State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT
            /// with autopull enabled. Write 1 to clear.
            TXSTALL: u4,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
        }), base_address + 0x8);

        /// address: 0x5030000c
        /// FIFO levels
        pub const FLEVEL = @intToPtr(*volatile Mmio(32, packed struct {
            TX0: u4,
            RX0: u4,
            TX1: u4,
            RX1: u4,
            TX2: u4,
            RX2: u4,
            TX3: u4,
            RX3: u4,
        }), base_address + 0xc);

        /// address: 0x50300010
        /// Direct write access to the TX FIFO for this state machine. Each write pushes one
        /// word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO
        /// state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
        pub const TXF0 = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x50300014
        /// Direct write access to the TX FIFO for this state machine. Each write pushes one
        /// word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO
        /// state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
        pub const TXF1 = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x50300018
        /// Direct write access to the TX FIFO for this state machine. Each write pushes one
        /// word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO
        /// state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
        pub const TXF2 = @intToPtr(*volatile u32, base_address + 0x18);

        /// address: 0x5030001c
        /// Direct write access to the TX FIFO for this state machine. Each write pushes one
        /// word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO
        /// state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
        pub const TXF3 = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x50300020
        /// Direct read access to the RX FIFO for this state machine. Each read pops one
        /// word from the FIFO. Attempting to read from an empty FIFO has no effect on the
        /// FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The
        /// data returned to the system on a read from an empty FIFO is undefined.
        pub const RXF0 = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x50300024
        /// Direct read access to the RX FIFO for this state machine. Each read pops one
        /// word from the FIFO. Attempting to read from an empty FIFO has no effect on the
        /// FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The
        /// data returned to the system on a read from an empty FIFO is undefined.
        pub const RXF1 = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x50300028
        /// Direct read access to the RX FIFO for this state machine. Each read pops one
        /// word from the FIFO. Attempting to read from an empty FIFO has no effect on the
        /// FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The
        /// data returned to the system on a read from an empty FIFO is undefined.
        pub const RXF2 = @intToPtr(*volatile u32, base_address + 0x28);

        /// address: 0x5030002c
        /// Direct read access to the RX FIFO for this state machine. Each read pops one
        /// word from the FIFO. Attempting to read from an empty FIFO has no effect on the
        /// FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The
        /// data returned to the system on a read from an empty FIFO is undefined.
        pub const RXF3 = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x50300030
        /// State machine IRQ flags register. Write 1 to clear. There are 8 state machine
        /// IRQ flags, which can be set, cleared, and waited on by the state machines.
        /// There's no fixed association between flags and state machines -- any state
        /// machine can use any flag.\n\n
        /// Any of the 8 flags can be used for timing synchronisation between state
        /// machines, using IRQ and WAIT instructions. The lower four of these flags are
        /// also routed out to system-level interrupt requests, alongside FIFO status
        /// interrupts -- see e.g. IRQ0_INTE.
        pub const IRQ = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x30);

        /// address: 0x50300034
        /// Writing a 1 to each of these bits will forcibly assert the corresponding IRQ.
        /// Note this is different to the INTF register: writing here affects PIO internal
        /// state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and
        /// is not visible to the state machines.
        pub const IRQ_FORCE = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x34);

        /// address: 0x50300038
        /// There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic
        /// from metastabilities. This increases input delay, and for fast synchronous IO
        /// (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this
        /// register corresponds to one GPIO.\n
        /// 0 -> input is synchronized (default)\n
        /// 1 -> synchronizer is bypassed\n
        /// If in doubt, leave this register as all zeroes.
        pub const INPUT_SYNC_BYPASS = @intToPtr(*volatile u32, base_address + 0x38);

        /// address: 0x5030003c
        /// Read to sample the pad output values PIO is currently driving to the GPIOs. On
        /// RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
        pub const DBG_PADOUT = @intToPtr(*volatile u32, base_address + 0x3c);

        /// address: 0x50300040
        /// Read to sample the pad output enables (direction) PIO is currently driving to
        /// the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are
        /// hardwired to 0.
        pub const DBG_PADOE = @intToPtr(*volatile u32, base_address + 0x40);

        /// address: 0x50300044
        /// The PIO hardware has some free parameters that may vary between chip products.\n
        /// These should be provided in the chip datasheet, but are also exposed here.
        pub const DBG_CFGINFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// The depth of the state machine TX/RX FIFOs, measured in words.\n
            /// Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double\n
            /// this depth.
            FIFO_DEPTH: u6,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// The number of state machines this PIO instance is equipped with.
            SM_COUNT: u4,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            /// The size of the instruction memory, measured in units of one instruction
            IMEM_SIZE: u6,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
        }), base_address + 0x44);

        /// address: 0x50300048
        /// Write-only access to instruction memory location 0
        pub const INSTR_MEM0 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x48);

        /// address: 0x5030004c
        /// Write-only access to instruction memory location 1
        pub const INSTR_MEM1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x4c);

        /// address: 0x50300050
        /// Write-only access to instruction memory location 2
        pub const INSTR_MEM2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x50);

        /// address: 0x50300054
        /// Write-only access to instruction memory location 3
        pub const INSTR_MEM3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x54);

        /// address: 0x50300058
        /// Write-only access to instruction memory location 4
        pub const INSTR_MEM4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x58);

        /// address: 0x5030005c
        /// Write-only access to instruction memory location 5
        pub const INSTR_MEM5 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x5c);

        /// address: 0x50300060
        /// Write-only access to instruction memory location 6
        pub const INSTR_MEM6 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x60);

        /// address: 0x50300064
        /// Write-only access to instruction memory location 7
        pub const INSTR_MEM7 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x64);

        /// address: 0x50300068
        /// Write-only access to instruction memory location 8
        pub const INSTR_MEM8 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x68);

        /// address: 0x5030006c
        /// Write-only access to instruction memory location 9
        pub const INSTR_MEM9 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x6c);

        /// address: 0x50300070
        /// Write-only access to instruction memory location 10
        pub const INSTR_MEM10 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x70);

        /// address: 0x50300074
        /// Write-only access to instruction memory location 11
        pub const INSTR_MEM11 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x74);

        /// address: 0x50300078
        /// Write-only access to instruction memory location 12
        pub const INSTR_MEM12 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x78);

        /// address: 0x5030007c
        /// Write-only access to instruction memory location 13
        pub const INSTR_MEM13 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x7c);

        /// address: 0x50300080
        /// Write-only access to instruction memory location 14
        pub const INSTR_MEM14 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x80);

        /// address: 0x50300084
        /// Write-only access to instruction memory location 15
        pub const INSTR_MEM15 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x84);

        /// address: 0x50300088
        /// Write-only access to instruction memory location 16
        pub const INSTR_MEM16 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x88);

        /// address: 0x5030008c
        /// Write-only access to instruction memory location 17
        pub const INSTR_MEM17 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x8c);

        /// address: 0x50300090
        /// Write-only access to instruction memory location 18
        pub const INSTR_MEM18 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x90);

        /// address: 0x50300094
        /// Write-only access to instruction memory location 19
        pub const INSTR_MEM19 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x94);

        /// address: 0x50300098
        /// Write-only access to instruction memory location 20
        pub const INSTR_MEM20 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x98);

        /// address: 0x5030009c
        /// Write-only access to instruction memory location 21
        pub const INSTR_MEM21 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x9c);

        /// address: 0x503000a0
        /// Write-only access to instruction memory location 22
        pub const INSTR_MEM22 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xa0);

        /// address: 0x503000a4
        /// Write-only access to instruction memory location 23
        pub const INSTR_MEM23 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xa4);

        /// address: 0x503000a8
        /// Write-only access to instruction memory location 24
        pub const INSTR_MEM24 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xa8);

        /// address: 0x503000ac
        /// Write-only access to instruction memory location 25
        pub const INSTR_MEM25 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xac);

        /// address: 0x503000b0
        /// Write-only access to instruction memory location 26
        pub const INSTR_MEM26 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xb0);

        /// address: 0x503000b4
        /// Write-only access to instruction memory location 27
        pub const INSTR_MEM27 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xb4);

        /// address: 0x503000b8
        /// Write-only access to instruction memory location 28
        pub const INSTR_MEM28 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xb8);

        /// address: 0x503000bc
        /// Write-only access to instruction memory location 29
        pub const INSTR_MEM29 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xbc);

        /// address: 0x503000c0
        /// Write-only access to instruction memory location 30
        pub const INSTR_MEM30 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc0);

        /// address: 0x503000c4
        /// Write-only access to instruction memory location 31
        pub const INSTR_MEM31 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc4);

        /// address: 0x503000c8
        /// Clock divisor register for state machine 0\n
        /// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
        pub const SM0_CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Fractional part of clock divisor
            FRAC: u8,
            /// Effective frequency is sysclk/(int + frac/256).\n
            /// Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
            INT: u16,
        }), base_address + 0xc8);

        /// address: 0x503000cc
        /// Execution/behavioural settings for state machine 0
        pub const SM0_EXECCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparison level for the MOV x, STATUS instruction
            STATUS_N: u4,
            /// Comparison used for the MOV x, STATUS instruction.
            STATUS_SEL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// After reaching wrap_top, execution is wrapped to this address.
            WRAP_BOTTOM: u5,
            /// After reaching this address, execution is wrapped to wrap_bottom.\n
            /// If the instruction is a jump, and the jump condition is true, the jump takes
            /// priority.
            WRAP_TOP: u5,
            /// Continuously assert the most recent OUT/SET to the pins
            OUT_STICKY: u1,
            /// If 1, use a bit of OUT data as an auxiliary write enable\n
            /// When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n
            /// deassert the latest pin write. This can create useful masking/override
            /// behaviour\n
            /// due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
            INLINE_OUT_EN: u1,
            /// Which data bit to use for inline OUT enable
            OUT_EN_SEL: u5,
            /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
            JMP_PIN: u5,
            /// If 1, side-set data is asserted to pin directions, instead of pin values
            SIDE_PINDIR: u1,
            /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set
            /// enable, rather than a side-set data bit. This allows instructions to perform
            /// side-set optionally, rather than on every instruction, but the maximum possible
            /// side-set width is reduced from 5 to 4. Note that the value of
            /// PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
            SIDE_EN: u1,
            /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state
            /// machine. Will clear to 0 once this instruction completes.
            EXEC_STALLED: u1,
        }), base_address + 0xcc);

        /// address: 0x503000d0
        /// Control behaviour of the input/output shift registers for state machine 0
        pub const SM0_SHIFTCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            /// Push automatically when the input shift register is filled, i.e. on an IN
            /// instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
            AUTOPUSH: u1,
            /// Pull automatically when the output shift register is emptied, i.e. on or
            /// following an OUT instruction which causes the output shift counter to reach or
            /// exceed PULL_THRESH.
            AUTOPULL: u1,
            /// 1 = shift input shift register to right (data enters from left). 0 = to left.
            IN_SHIFTDIR: u1,
            /// 1 = shift out of output shift register to right. 0 = to left.
            OUT_SHIFTDIR: u1,
            /// Number of bits shifted into ISR before autopush, or conditional push (PUSH
            /// IFFULL), will take place.\n
            /// Write 0 for value of 32.
            PUSH_THRESH: u5,
            /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL
            /// IFEMPTY), will take place.\n
            /// Write 0 for value of 32.
            PULL_THRESH: u5,
            /// When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n
            /// RX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_TX: u1,
            /// When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n
            /// TX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_RX: u1,
        }), base_address + 0xd0);

        /// address: 0x503000d4
        /// Current instruction address of state machine 0
        pub const SM0_ADDR = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xd4);

        /// address: 0x503000d8
        /// Read to see the instruction currently addressed by state machine 0's program
        /// counter\n
        /// Write to execute an instruction immediately (including jumps) and then resume
        /// execution.
        pub const SM0_INSTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xd8);

        /// address: 0x503000dc
        /// State machine pin control
        pub const SM0_PINCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV
            /// PINS instruction. The data written to this pin will always be the
            /// least-significant bit of the OUT or MOV data.
            OUT_BASE: u5,
            /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS
            /// instruction. The data written to this pin is the least-significant bit of the
            /// SET data.
            SET_BASE: u5,
            /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs
            /// of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT)
            /// are used for side-set data, with the remaining LSBs used for delay. The
            /// least-significant bit of the side-set portion is the bit written to this pin,
            /// with more-significant bits written to higher-numbered pins.
            SIDESET_BASE: u5,
            /// The pin which is mapped to the least-significant bit of a state machine's IN
            /// data bus. Higher-numbered pins are mapped to consecutively more-significant data
            /// bits, with a modulo of 32 applied to pin number.
            IN_BASE: u5,
            /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction.
            /// In the range 0 to 32 inclusive.
            OUT_COUNT: u6,
            /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
            SET_COUNT: u3,
            /// The number of MSBs of the Delay/Side-set instruction field which are used for
            /// side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits,
            /// no side-set) and maximum of 5 (all side-set, no delay).
            SIDESET_COUNT: u3,
        }), base_address + 0xdc);

        /// address: 0x503000e0
        /// Clock divisor register for state machine 1\n
        /// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
        pub const SM1_CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Fractional part of clock divisor
            FRAC: u8,
            /// Effective frequency is sysclk/(int + frac/256).\n
            /// Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
            INT: u16,
        }), base_address + 0xe0);

        /// address: 0x503000e4
        /// Execution/behavioural settings for state machine 1
        pub const SM1_EXECCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparison level for the MOV x, STATUS instruction
            STATUS_N: u4,
            /// Comparison used for the MOV x, STATUS instruction.
            STATUS_SEL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// After reaching wrap_top, execution is wrapped to this address.
            WRAP_BOTTOM: u5,
            /// After reaching this address, execution is wrapped to wrap_bottom.\n
            /// If the instruction is a jump, and the jump condition is true, the jump takes
            /// priority.
            WRAP_TOP: u5,
            /// Continuously assert the most recent OUT/SET to the pins
            OUT_STICKY: u1,
            /// If 1, use a bit of OUT data as an auxiliary write enable\n
            /// When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n
            /// deassert the latest pin write. This can create useful masking/override
            /// behaviour\n
            /// due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
            INLINE_OUT_EN: u1,
            /// Which data bit to use for inline OUT enable
            OUT_EN_SEL: u5,
            /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
            JMP_PIN: u5,
            /// If 1, side-set data is asserted to pin directions, instead of pin values
            SIDE_PINDIR: u1,
            /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set
            /// enable, rather than a side-set data bit. This allows instructions to perform
            /// side-set optionally, rather than on every instruction, but the maximum possible
            /// side-set width is reduced from 5 to 4. Note that the value of
            /// PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
            SIDE_EN: u1,
            /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state
            /// machine. Will clear to 0 once this instruction completes.
            EXEC_STALLED: u1,
        }), base_address + 0xe4);

        /// address: 0x503000e8
        /// Control behaviour of the input/output shift registers for state machine 1
        pub const SM1_SHIFTCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            /// Push automatically when the input shift register is filled, i.e. on an IN
            /// instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
            AUTOPUSH: u1,
            /// Pull automatically when the output shift register is emptied, i.e. on or
            /// following an OUT instruction which causes the output shift counter to reach or
            /// exceed PULL_THRESH.
            AUTOPULL: u1,
            /// 1 = shift input shift register to right (data enters from left). 0 = to left.
            IN_SHIFTDIR: u1,
            /// 1 = shift out of output shift register to right. 0 = to left.
            OUT_SHIFTDIR: u1,
            /// Number of bits shifted into ISR before autopush, or conditional push (PUSH
            /// IFFULL), will take place.\n
            /// Write 0 for value of 32.
            PUSH_THRESH: u5,
            /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL
            /// IFEMPTY), will take place.\n
            /// Write 0 for value of 32.
            PULL_THRESH: u5,
            /// When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n
            /// RX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_TX: u1,
            /// When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n
            /// TX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_RX: u1,
        }), base_address + 0xe8);

        /// address: 0x503000ec
        /// Current instruction address of state machine 1
        pub const SM1_ADDR = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xec);

        /// address: 0x503000f0
        /// Read to see the instruction currently addressed by state machine 1's program
        /// counter\n
        /// Write to execute an instruction immediately (including jumps) and then resume
        /// execution.
        pub const SM1_INSTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xf0);

        /// address: 0x503000f4
        /// State machine pin control
        pub const SM1_PINCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV
            /// PINS instruction. The data written to this pin will always be the
            /// least-significant bit of the OUT or MOV data.
            OUT_BASE: u5,
            /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS
            /// instruction. The data written to this pin is the least-significant bit of the
            /// SET data.
            SET_BASE: u5,
            /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs
            /// of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT)
            /// are used for side-set data, with the remaining LSBs used for delay. The
            /// least-significant bit of the side-set portion is the bit written to this pin,
            /// with more-significant bits written to higher-numbered pins.
            SIDESET_BASE: u5,
            /// The pin which is mapped to the least-significant bit of a state machine's IN
            /// data bus. Higher-numbered pins are mapped to consecutively more-significant data
            /// bits, with a modulo of 32 applied to pin number.
            IN_BASE: u5,
            /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction.
            /// In the range 0 to 32 inclusive.
            OUT_COUNT: u6,
            /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
            SET_COUNT: u3,
            /// The number of MSBs of the Delay/Side-set instruction field which are used for
            /// side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits,
            /// no side-set) and maximum of 5 (all side-set, no delay).
            SIDESET_COUNT: u3,
        }), base_address + 0xf4);

        /// address: 0x503000f8
        /// Clock divisor register for state machine 2\n
        /// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
        pub const SM2_CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Fractional part of clock divisor
            FRAC: u8,
            /// Effective frequency is sysclk/(int + frac/256).\n
            /// Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
            INT: u16,
        }), base_address + 0xf8);

        /// address: 0x503000fc
        /// Execution/behavioural settings for state machine 2
        pub const SM2_EXECCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparison level for the MOV x, STATUS instruction
            STATUS_N: u4,
            /// Comparison used for the MOV x, STATUS instruction.
            STATUS_SEL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// After reaching wrap_top, execution is wrapped to this address.
            WRAP_BOTTOM: u5,
            /// After reaching this address, execution is wrapped to wrap_bottom.\n
            /// If the instruction is a jump, and the jump condition is true, the jump takes
            /// priority.
            WRAP_TOP: u5,
            /// Continuously assert the most recent OUT/SET to the pins
            OUT_STICKY: u1,
            /// If 1, use a bit of OUT data as an auxiliary write enable\n
            /// When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n
            /// deassert the latest pin write. This can create useful masking/override
            /// behaviour\n
            /// due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
            INLINE_OUT_EN: u1,
            /// Which data bit to use for inline OUT enable
            OUT_EN_SEL: u5,
            /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
            JMP_PIN: u5,
            /// If 1, side-set data is asserted to pin directions, instead of pin values
            SIDE_PINDIR: u1,
            /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set
            /// enable, rather than a side-set data bit. This allows instructions to perform
            /// side-set optionally, rather than on every instruction, but the maximum possible
            /// side-set width is reduced from 5 to 4. Note that the value of
            /// PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
            SIDE_EN: u1,
            /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state
            /// machine. Will clear to 0 once this instruction completes.
            EXEC_STALLED: u1,
        }), base_address + 0xfc);

        /// address: 0x50300100
        /// Control behaviour of the input/output shift registers for state machine 2
        pub const SM2_SHIFTCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            /// Push automatically when the input shift register is filled, i.e. on an IN
            /// instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
            AUTOPUSH: u1,
            /// Pull automatically when the output shift register is emptied, i.e. on or
            /// following an OUT instruction which causes the output shift counter to reach or
            /// exceed PULL_THRESH.
            AUTOPULL: u1,
            /// 1 = shift input shift register to right (data enters from left). 0 = to left.
            IN_SHIFTDIR: u1,
            /// 1 = shift out of output shift register to right. 0 = to left.
            OUT_SHIFTDIR: u1,
            /// Number of bits shifted into ISR before autopush, or conditional push (PUSH
            /// IFFULL), will take place.\n
            /// Write 0 for value of 32.
            PUSH_THRESH: u5,
            /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL
            /// IFEMPTY), will take place.\n
            /// Write 0 for value of 32.
            PULL_THRESH: u5,
            /// When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n
            /// RX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_TX: u1,
            /// When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n
            /// TX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_RX: u1,
        }), base_address + 0x100);

        /// address: 0x50300104
        /// Current instruction address of state machine 2
        pub const SM2_ADDR = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x104);

        /// address: 0x50300108
        /// Read to see the instruction currently addressed by state machine 2's program
        /// counter\n
        /// Write to execute an instruction immediately (including jumps) and then resume
        /// execution.
        pub const SM2_INSTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x108);

        /// address: 0x5030010c
        /// State machine pin control
        pub const SM2_PINCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV
            /// PINS instruction. The data written to this pin will always be the
            /// least-significant bit of the OUT or MOV data.
            OUT_BASE: u5,
            /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS
            /// instruction. The data written to this pin is the least-significant bit of the
            /// SET data.
            SET_BASE: u5,
            /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs
            /// of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT)
            /// are used for side-set data, with the remaining LSBs used for delay. The
            /// least-significant bit of the side-set portion is the bit written to this pin,
            /// with more-significant bits written to higher-numbered pins.
            SIDESET_BASE: u5,
            /// The pin which is mapped to the least-significant bit of a state machine's IN
            /// data bus. Higher-numbered pins are mapped to consecutively more-significant data
            /// bits, with a modulo of 32 applied to pin number.
            IN_BASE: u5,
            /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction.
            /// In the range 0 to 32 inclusive.
            OUT_COUNT: u6,
            /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
            SET_COUNT: u3,
            /// The number of MSBs of the Delay/Side-set instruction field which are used for
            /// side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits,
            /// no side-set) and maximum of 5 (all side-set, no delay).
            SIDESET_COUNT: u3,
        }), base_address + 0x10c);

        /// address: 0x50300110
        /// Clock divisor register for state machine 3\n
        /// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
        pub const SM3_CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            /// Fractional part of clock divisor
            FRAC: u8,
            /// Effective frequency is sysclk/(int + frac/256).\n
            /// Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
            INT: u16,
        }), base_address + 0x110);

        /// address: 0x50300114
        /// Execution/behavioural settings for state machine 3
        pub const SM3_EXECCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparison level for the MOV x, STATUS instruction
            STATUS_N: u4,
            /// Comparison used for the MOV x, STATUS instruction.
            STATUS_SEL: u1,
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            /// After reaching wrap_top, execution is wrapped to this address.
            WRAP_BOTTOM: u5,
            /// After reaching this address, execution is wrapped to wrap_bottom.\n
            /// If the instruction is a jump, and the jump condition is true, the jump takes
            /// priority.
            WRAP_TOP: u5,
            /// Continuously assert the most recent OUT/SET to the pins
            OUT_STICKY: u1,
            /// If 1, use a bit of OUT data as an auxiliary write enable\n
            /// When used in conjunction with OUT_STICKY, writes with an enable of 0 will\n
            /// deassert the latest pin write. This can create useful masking/override
            /// behaviour\n
            /// due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
            INLINE_OUT_EN: u1,
            /// Which data bit to use for inline OUT enable
            OUT_EN_SEL: u5,
            /// The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
            JMP_PIN: u5,
            /// If 1, side-set data is asserted to pin directions, instead of pin values
            SIDE_PINDIR: u1,
            /// If 1, the MSB of the Delay/Side-set instruction field is used as side-set
            /// enable, rather than a side-set data bit. This allows instructions to perform
            /// side-set optionally, rather than on every instruction, but the maximum possible
            /// side-set width is reduced from 5 to 4. Note that the value of
            /// PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
            SIDE_EN: u1,
            /// If 1, an instruction written to SMx_INSTR is stalled, and latched by the state
            /// machine. Will clear to 0 once this instruction completes.
            EXEC_STALLED: u1,
        }), base_address + 0x114);

        /// address: 0x50300118
        /// Control behaviour of the input/output shift registers for state machine 3
        pub const SM3_SHIFTCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            /// Push automatically when the input shift register is filled, i.e. on an IN
            /// instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
            AUTOPUSH: u1,
            /// Pull automatically when the output shift register is emptied, i.e. on or
            /// following an OUT instruction which causes the output shift counter to reach or
            /// exceed PULL_THRESH.
            AUTOPULL: u1,
            /// 1 = shift input shift register to right (data enters from left). 0 = to left.
            IN_SHIFTDIR: u1,
            /// 1 = shift out of output shift register to right. 0 = to left.
            OUT_SHIFTDIR: u1,
            /// Number of bits shifted into ISR before autopush, or conditional push (PUSH
            /// IFFULL), will take place.\n
            /// Write 0 for value of 32.
            PUSH_THRESH: u5,
            /// Number of bits shifted out of OSR before autopull, or conditional pull (PULL
            /// IFEMPTY), will take place.\n
            /// Write 0 for value of 32.
            PULL_THRESH: u5,
            /// When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.\n
            /// RX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_TX: u1,
            /// When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.\n
            /// TX FIFO is disabled as a result (always reads as both full and empty).\n
            /// FIFOs are flushed when this bit is changed.
            FJOIN_RX: u1,
        }), base_address + 0x118);

        /// address: 0x5030011c
        /// Current instruction address of state machine 3
        pub const SM3_ADDR = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x11c);

        /// address: 0x50300120
        /// Read to see the instruction currently addressed by state machine 3's program
        /// counter\n
        /// Write to execute an instruction immediately (including jumps) and then resume
        /// execution.
        pub const SM3_INSTR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x120);

        /// address: 0x50300124
        /// State machine pin control
        pub const SM3_PINCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV
            /// PINS instruction. The data written to this pin will always be the
            /// least-significant bit of the OUT or MOV data.
            OUT_BASE: u5,
            /// The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS
            /// instruction. The data written to this pin is the least-significant bit of the
            /// SET data.
            SET_BASE: u5,
            /// The lowest-numbered pin that will be affected by a side-set operation. The MSBs
            /// of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT)
            /// are used for side-set data, with the remaining LSBs used for delay. The
            /// least-significant bit of the side-set portion is the bit written to this pin,
            /// with more-significant bits written to higher-numbered pins.
            SIDESET_BASE: u5,
            /// The pin which is mapped to the least-significant bit of a state machine's IN
            /// data bus. Higher-numbered pins are mapped to consecutively more-significant data
            /// bits, with a modulo of 32 applied to pin number.
            IN_BASE: u5,
            /// The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction.
            /// In the range 0 to 32 inclusive.
            OUT_COUNT: u6,
            /// The number of pins asserted by a SET. In the range 0 to 5 inclusive.
            SET_COUNT: u3,
            /// The number of MSBs of the Delay/Side-set instruction field which are used for
            /// side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits,
            /// no side-set) and maximum of 5 (all side-set, no delay).
            SIDESET_COUNT: u3,
        }), base_address + 0x124);

        /// address: 0x50300128
        /// Raw Interrupts
        pub const INTR = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x128);

        /// address: 0x5030012c
        /// Interrupt Enable for irq0
        pub const IRQ0_INTE = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x12c);

        /// address: 0x50300130
        /// Interrupt Force for irq0
        pub const IRQ0_INTF = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x130);

        /// address: 0x50300134
        /// Interrupt status after masking & forcing for irq0
        pub const IRQ0_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x134);

        /// address: 0x50300138
        /// Interrupt Enable for irq1
        pub const IRQ1_INTE = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x138);

        /// address: 0x5030013c
        /// Interrupt Force for irq1
        pub const IRQ1_INTF = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x13c);

        /// address: 0x50300140
        /// Interrupt status after masking & forcing for irq1
        pub const IRQ1_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            SM0_RXNEMPTY: u1,
            SM1_RXNEMPTY: u1,
            SM2_RXNEMPTY: u1,
            SM3_RXNEMPTY: u1,
            SM0_TXNFULL: u1,
            SM1_TXNFULL: u1,
            SM2_TXNFULL: u1,
            SM3_TXNFULL: u1,
            SM0: u1,
            SM1: u1,
            SM2: u1,
            SM3: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
        }), base_address + 0x140);
    };

    /// Single-cycle IO block\n
    /// Provides core-local and inter-core hardware for the two processors, with
    /// single-cycle access.
    pub const SIO = struct {
        pub const base_address = 0xd0000000;
        pub const version = "1";

        /// address: 0xd0000000
        /// Processor core identifier\n
        /// Value is 0 when read from processor core 0, and 1 when read from processor core
        /// 1.
        pub const CPUID = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0xd0000004
        /// Input value for GPIO pins
        pub const GPIO_IN = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x4);

        /// address: 0xd0000008
        /// Input value for QSPI pins
        pub const GPIO_HI_IN = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x8);

        /// address: 0xd0000010
        /// GPIO output value
        pub const GPIO_OUT = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x10);

        /// address: 0xd0000014
        /// GPIO output value set
        pub const GPIO_OUT_SET = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x14);

        /// address: 0xd0000018
        /// GPIO output value clear
        pub const GPIO_OUT_CLR = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x18);

        /// address: 0xd000001c
        /// GPIO output value XOR
        pub const GPIO_OUT_XOR = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x1c);

        /// address: 0xd0000020
        /// GPIO output enable
        pub const GPIO_OE = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x20);

        /// address: 0xd0000024
        /// GPIO output enable set
        pub const GPIO_OE_SET = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x24);

        /// address: 0xd0000028
        /// GPIO output enable clear
        pub const GPIO_OE_CLR = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x28);

        /// address: 0xd000002c
        /// GPIO output enable XOR
        pub const GPIO_OE_XOR = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x2c);

        /// address: 0xd0000030
        /// QSPI output value
        pub const GPIO_HI_OUT = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x30);

        /// address: 0xd0000034
        /// QSPI output value set
        pub const GPIO_HI_OUT_SET = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x34);

        /// address: 0xd0000038
        /// QSPI output value clear
        pub const GPIO_HI_OUT_CLR = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x38);

        /// address: 0xd000003c
        /// QSPI output value XOR
        pub const GPIO_HI_OUT_XOR = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x3c);

        /// address: 0xd0000040
        /// QSPI output enable
        pub const GPIO_HI_OE = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x40);

        /// address: 0xd0000044
        /// QSPI output enable set
        pub const GPIO_HI_OE_SET = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x44);

        /// address: 0xd0000048
        /// QSPI output enable clear
        pub const GPIO_HI_OE_CLR = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x48);

        /// address: 0xd000004c
        /// QSPI output enable XOR
        pub const GPIO_HI_OE_XOR = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x4c);

        /// address: 0xd0000050
        /// Status register for inter-core FIFOs (mailboxes).\n
        /// There is one FIFO in the core 0 -> core 1 direction, and one core 1 -> core 0.
        /// Both are 32 bits wide and 8 words deep.\n
        /// Core 0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1
        /// FIFO (TX).\n
        /// Core 1 can see the read side of the 0->1 FIFO (RX), and the write side of 1->0
        /// FIFO (TX).\n
        /// The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of
        /// its FIFO_ST register.
        pub const FIFO_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Value is 1 if this core's RX FIFO is not empty (i.e. if FIFO_RD is valid)
            VLD: u1,
            /// Value is 1 if this core's TX FIFO is not full (i.e. if FIFO_WR is ready for more
            /// data)
            RDY: u1,
            /// Sticky flag indicating the TX FIFO was written when full. This write was ignored
            /// by the FIFO.
            WOF: u1,
            /// Sticky flag indicating the RX FIFO was read when empty. This read was ignored by
            /// the FIFO.
            ROE: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
        }), base_address + 0x50);

        /// address: 0xd0000054
        /// Write access to this core's TX FIFO
        pub const FIFO_WR = @intToPtr(*volatile u32, base_address + 0x54);

        /// address: 0xd0000058
        /// Read access to this core's RX FIFO
        pub const FIFO_RD = @intToPtr(*volatile u32, base_address + 0x58);

        /// address: 0xd000005c
        /// Spinlock state\n
        /// A bitmap containing the state of all 32 spinlocks (1=locked).\n
        /// Mainly intended for debugging.
        pub const SPINLOCK_ST = @intToPtr(*volatile u32, base_address + 0x5c);

        /// address: 0xd0000060
        /// Divider unsigned dividend\n
        /// Write to the DIVIDEND operand of the divider, i.e. the p in `p / q`.\n
        /// Any operand write starts a new calculation. The results appear in QUOTIENT,
        /// REMAINDER.\n
        /// UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias
        /// starts an\n
        /// unsigned calculation, and the S alias starts a signed calculation.
        pub const DIV_UDIVIDEND = @intToPtr(*volatile u32, base_address + 0x60);

        /// address: 0xd0000064
        /// Divider unsigned divisor\n
        /// Write to the DIVISOR operand of the divider, i.e. the q in `p / q`.\n
        /// Any operand write starts a new calculation. The results appear in QUOTIENT,
        /// REMAINDER.\n
        /// UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias
        /// starts an\n
        /// unsigned calculation, and the S alias starts a signed calculation.
        pub const DIV_UDIVISOR = @intToPtr(*volatile u32, base_address + 0x64);

        /// address: 0xd0000068
        /// Divider signed dividend\n
        /// The same as UDIVIDEND, but starts a signed calculation, rather than unsigned.
        pub const DIV_SDIVIDEND = @intToPtr(*volatile u32, base_address + 0x68);

        /// address: 0xd000006c
        /// Divider signed divisor\n
        /// The same as UDIVISOR, but starts a signed calculation, rather than unsigned.
        pub const DIV_SDIVISOR = @intToPtr(*volatile u32, base_address + 0x6c);

        /// address: 0xd0000070
        /// Divider result quotient\n
        /// The result of `DIVIDEND / DIVISOR` (division). Contents undefined while
        /// CSR_READY is low.\n
        /// For signed calculations, QUOTIENT is negative when the signs of DIVIDEND and
        /// DIVISOR differ.\n
        /// This register can be written to directly, for context save/restore purposes.
        /// This halts any\n
        /// in-progress calculation and sets the CSR_READY and CSR_DIRTY flags.\n
        /// Reading from QUOTIENT clears the CSR_DIRTY flag, so should read results in the
        /// order\n
        /// REMAINDER, QUOTIENT if CSR_DIRTY is used.
        pub const DIV_QUOTIENT = @intToPtr(*volatile u32, base_address + 0x70);

        /// address: 0xd0000074
        /// Divider result remainder\n
        /// The result of `DIVIDEND % DIVISOR` (modulo). Contents undefined while CSR_READY
        /// is low.\n
        /// For signed calculations, REMAINDER is negative only when DIVIDEND is negative.\n
        /// This register can be written to directly, for context save/restore purposes.
        /// This halts any\n
        /// in-progress calculation and sets the CSR_READY and CSR_DIRTY flags.
        pub const DIV_REMAINDER = @intToPtr(*volatile u32, base_address + 0x74);

        /// address: 0xd0000078
        /// Control and status register for divider.
        pub const DIV_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reads as 0 when a calculation is in progress, 1 otherwise.\n
            /// Writing an operand (xDIVIDEND, xDIVISOR) will immediately start a new
            /// calculation, no\n
            /// matter if one is already in progress.\n
            /// Writing to a result register will immediately terminate any in-progress
            /// calculation\n
            /// and set the READY and DIRTY flags.
            READY: u1,
            /// Changes to 1 when any register is written, and back to 0 when QUOTIENT is
            /// read.\n
            /// Software can use this flag to make save/restore more efficient (skip if not
            /// DIRTY).\n
            /// If the flag is used in this way, it's recommended to either read QUOTIENT
            /// only,\n
            /// or REMAINDER and then QUOTIENT, to prevent data loss on context switch.
            DIRTY: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
            padding11: u1 = 0,
            padding12: u1 = 0,
            padding13: u1 = 0,
            padding14: u1 = 0,
            padding15: u1 = 0,
            padding16: u1 = 0,
            padding17: u1 = 0,
            padding18: u1 = 0,
            padding19: u1 = 0,
            padding20: u1 = 0,
            padding21: u1 = 0,
            padding22: u1 = 0,
            padding23: u1 = 0,
            padding24: u1 = 0,
            padding25: u1 = 0,
            padding26: u1 = 0,
            padding27: u1 = 0,
            padding28: u1 = 0,
            padding29: u1 = 0,
        }), base_address + 0x78);

        /// address: 0xd0000080
        /// Read/write access to accumulator 0
        pub const INTERP0_ACCUM0 = @intToPtr(*volatile u32, base_address + 0x80);

        /// address: 0xd0000084
        /// Read/write access to accumulator 1
        pub const INTERP0_ACCUM1 = @intToPtr(*volatile u32, base_address + 0x84);

        /// address: 0xd0000088
        /// Read/write access to BASE0 register.
        pub const INTERP0_BASE0 = @intToPtr(*volatile u32, base_address + 0x88);

        /// address: 0xd000008c
        /// Read/write access to BASE1 register.
        pub const INTERP0_BASE1 = @intToPtr(*volatile u32, base_address + 0x8c);

        /// address: 0xd0000090
        /// Read/write access to BASE2 register.
        pub const INTERP0_BASE2 = @intToPtr(*volatile u32, base_address + 0x90);

        /// address: 0xd0000094
        /// Read LANE0 result, and simultaneously write lane results to both accumulators
        /// (POP).
        pub const INTERP0_POP_LANE0 = @intToPtr(*volatile u32, base_address + 0x94);

        /// address: 0xd0000098
        /// Read LANE1 result, and simultaneously write lane results to both accumulators
        /// (POP).
        pub const INTERP0_POP_LANE1 = @intToPtr(*volatile u32, base_address + 0x98);

        /// address: 0xd000009c
        /// Read FULL result, and simultaneously write lane results to both accumulators
        /// (POP).
        pub const INTERP0_POP_FULL = @intToPtr(*volatile u32, base_address + 0x9c);

        /// address: 0xd00000a0
        /// Read LANE0 result, without altering any internal state (PEEK).
        pub const INTERP0_PEEK_LANE0 = @intToPtr(*volatile u32, base_address + 0xa0);

        /// address: 0xd00000a4
        /// Read LANE1 result, without altering any internal state (PEEK).
        pub const INTERP0_PEEK_LANE1 = @intToPtr(*volatile u32, base_address + 0xa4);

        /// address: 0xd00000a8
        /// Read FULL result, without altering any internal state (PEEK).
        pub const INTERP0_PEEK_FULL = @intToPtr(*volatile u32, base_address + 0xa8);

        /// address: 0xd00000ac
        /// Control register for lane 0
        pub const INTERP0_CTRL_LANE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Logical right-shift applied to accumulator before masking
            SHIFT: u5,
            /// The least-significant bit allowed to pass by the mask (inclusive)
            MASK_LSB: u5,
            /// The most-significant bit allowed to pass by the mask (inclusive)\n
            /// Setting MSB < LSB may cause chip to turn inside-out
            MASK_MSB: u5,
            /// If SIGNED is set, the shifted and masked accumulator value is sign-extended to
            /// 32 bits\n
            /// before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read
            /// by processor.
            SIGNED: u1,
            /// If 1, feed the opposite lane's accumulator into this lane's shift + mask
            /// hardware.\n
            /// Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the
            /// shift+mask bypass)
            CROSS_INPUT: u1,
            /// If 1, feed the opposite lane's result into this lane's accumulator on POP.
            CROSS_RESULT: u1,
            /// If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL
            /// result.
            ADD_RAW: u1,
            /// ORed into bits 29:28 of the lane result presented to the processor on the bus.\n
            /// No effect on the internal 32-bit datapath. Handy for using a lane to generate
            /// sequence\n
            /// of pointers into flash or SRAM.
            FORCE_MSB: u2,
            /// Only present on INTERP0 on each core. If BLEND mode is enabled:\n
            /// - LANE1 result is a linear interpolation between BASE0 and BASE1, controlled\n
            /// by the 8 LSBs of lane 1 shift and mask value (a fractional number between\n
            /// 0 and 255/256ths)\n
            /// - LANE0 result does not have BASE0 added (yields only the 8 LSBs of lane 1
            /// shift+mask value)\n
            /// - FULL result does not have lane 1 shift+mask value added (BASE2 + lane 0
            /// shift+mask)\n
            /// LANE1 SIGNED flag controls whether the interpolation is signed or unsigned.
            BLEND: u1,
            reserved0: u1 = 0,
            /// Indicates if any masked-off MSBs in ACCUM0 are set.
            OVERF0: u1,
            /// Indicates if any masked-off MSBs in ACCUM1 are set.
            OVERF1: u1,
            /// Set if either OVERF0 or OVERF1 is set.
            OVERF: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
        }), base_address + 0xac);

        /// address: 0xd00000b0
        /// Control register for lane 1
        pub const INTERP0_CTRL_LANE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Logical right-shift applied to accumulator before masking
            SHIFT: u5,
            /// The least-significant bit allowed to pass by the mask (inclusive)
            MASK_LSB: u5,
            /// The most-significant bit allowed to pass by the mask (inclusive)\n
            /// Setting MSB < LSB may cause chip to turn inside-out
            MASK_MSB: u5,
            /// If SIGNED is set, the shifted and masked accumulator value is sign-extended to
            /// 32 bits\n
            /// before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read
            /// by processor.
            SIGNED: u1,
            /// If 1, feed the opposite lane's accumulator into this lane's shift + mask
            /// hardware.\n
            /// Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the
            /// shift+mask bypass)
            CROSS_INPUT: u1,
            /// If 1, feed the opposite lane's result into this lane's accumulator on POP.
            CROSS_RESULT: u1,
            /// If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL
            /// result.
            ADD_RAW: u1,
            /// ORed into bits 29:28 of the lane result presented to the processor on the bus.\n
            /// No effect on the internal 32-bit datapath. Handy for using a lane to generate
            /// sequence\n
            /// of pointers into flash or SRAM.
            FORCE_MSB: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
        }), base_address + 0xb0);

        /// address: 0xd00000b4
        /// Values written here are atomically added to ACCUM0\n
        /// Reading yields lane 0's raw shift and mask value (BASE0 not added).
        pub const INTERP0_ACCUM0_ADD = @intToPtr(*volatile MmioInt(32, u24), base_address + 0xb4);

        /// address: 0xd00000b8
        /// Values written here are atomically added to ACCUM1\n
        /// Reading yields lane 1's raw shift and mask value (BASE1 not added).
        pub const INTERP0_ACCUM1_ADD = @intToPtr(*volatile MmioInt(32, u24), base_address + 0xb8);

        /// address: 0xd00000bc
        /// On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.\n
        /// Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.
        pub const INTERP0_BASE_1AND0 = @intToPtr(*volatile u32, base_address + 0xbc);

        /// address: 0xd00000c0
        /// Read/write access to accumulator 0
        pub const INTERP1_ACCUM0 = @intToPtr(*volatile u32, base_address + 0xc0);

        /// address: 0xd00000c4
        /// Read/write access to accumulator 1
        pub const INTERP1_ACCUM1 = @intToPtr(*volatile u32, base_address + 0xc4);

        /// address: 0xd00000c8
        /// Read/write access to BASE0 register.
        pub const INTERP1_BASE0 = @intToPtr(*volatile u32, base_address + 0xc8);

        /// address: 0xd00000cc
        /// Read/write access to BASE1 register.
        pub const INTERP1_BASE1 = @intToPtr(*volatile u32, base_address + 0xcc);

        /// address: 0xd00000d0
        /// Read/write access to BASE2 register.
        pub const INTERP1_BASE2 = @intToPtr(*volatile u32, base_address + 0xd0);

        /// address: 0xd00000d4
        /// Read LANE0 result, and simultaneously write lane results to both accumulators
        /// (POP).
        pub const INTERP1_POP_LANE0 = @intToPtr(*volatile u32, base_address + 0xd4);

        /// address: 0xd00000d8
        /// Read LANE1 result, and simultaneously write lane results to both accumulators
        /// (POP).
        pub const INTERP1_POP_LANE1 = @intToPtr(*volatile u32, base_address + 0xd8);

        /// address: 0xd00000dc
        /// Read FULL result, and simultaneously write lane results to both accumulators
        /// (POP).
        pub const INTERP1_POP_FULL = @intToPtr(*volatile u32, base_address + 0xdc);

        /// address: 0xd00000e0
        /// Read LANE0 result, without altering any internal state (PEEK).
        pub const INTERP1_PEEK_LANE0 = @intToPtr(*volatile u32, base_address + 0xe0);

        /// address: 0xd00000e4
        /// Read LANE1 result, without altering any internal state (PEEK).
        pub const INTERP1_PEEK_LANE1 = @intToPtr(*volatile u32, base_address + 0xe4);

        /// address: 0xd00000e8
        /// Read FULL result, without altering any internal state (PEEK).
        pub const INTERP1_PEEK_FULL = @intToPtr(*volatile u32, base_address + 0xe8);

        /// address: 0xd00000ec
        /// Control register for lane 0
        pub const INTERP1_CTRL_LANE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Logical right-shift applied to accumulator before masking
            SHIFT: u5,
            /// The least-significant bit allowed to pass by the mask (inclusive)
            MASK_LSB: u5,
            /// The most-significant bit allowed to pass by the mask (inclusive)\n
            /// Setting MSB < LSB may cause chip to turn inside-out
            MASK_MSB: u5,
            /// If SIGNED is set, the shifted and masked accumulator value is sign-extended to
            /// 32 bits\n
            /// before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read
            /// by processor.
            SIGNED: u1,
            /// If 1, feed the opposite lane's accumulator into this lane's shift + mask
            /// hardware.\n
            /// Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the
            /// shift+mask bypass)
            CROSS_INPUT: u1,
            /// If 1, feed the opposite lane's result into this lane's accumulator on POP.
            CROSS_RESULT: u1,
            /// If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL
            /// result.
            ADD_RAW: u1,
            /// ORed into bits 29:28 of the lane result presented to the processor on the bus.\n
            /// No effect on the internal 32-bit datapath. Handy for using a lane to generate
            /// sequence\n
            /// of pointers into flash or SRAM.
            FORCE_MSB: u2,
            reserved0: u1 = 0,
            /// Only present on INTERP1 on each core. If CLAMP mode is enabled:\n
            /// - LANE0 result is shifted and masked ACCUM0, clamped by a lower bound of\n
            /// BASE0 and an upper bound of BASE1.\n
            /// - Signedness of these comparisons is determined by LANE0_CTRL_SIGNED
            CLAMP: u1,
            /// Indicates if any masked-off MSBs in ACCUM0 are set.
            OVERF0: u1,
            /// Indicates if any masked-off MSBs in ACCUM1 are set.
            OVERF1: u1,
            /// Set if either OVERF0 or OVERF1 is set.
            OVERF: u1,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
        }), base_address + 0xec);

        /// address: 0xd00000f0
        /// Control register for lane 1
        pub const INTERP1_CTRL_LANE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Logical right-shift applied to accumulator before masking
            SHIFT: u5,
            /// The least-significant bit allowed to pass by the mask (inclusive)
            MASK_LSB: u5,
            /// The most-significant bit allowed to pass by the mask (inclusive)\n
            /// Setting MSB < LSB may cause chip to turn inside-out
            MASK_MSB: u5,
            /// If SIGNED is set, the shifted and masked accumulator value is sign-extended to
            /// 32 bits\n
            /// before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read
            /// by processor.
            SIGNED: u1,
            /// If 1, feed the opposite lane's accumulator into this lane's shift + mask
            /// hardware.\n
            /// Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the
            /// shift+mask bypass)
            CROSS_INPUT: u1,
            /// If 1, feed the opposite lane's result into this lane's accumulator on POP.
            CROSS_RESULT: u1,
            /// If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL
            /// result.
            ADD_RAW: u1,
            /// ORed into bits 29:28 of the lane result presented to the processor on the bus.\n
            /// No effect on the internal 32-bit datapath. Handy for using a lane to generate
            /// sequence\n
            /// of pointers into flash or SRAM.
            FORCE_MSB: u2,
            padding0: u1 = 0,
            padding1: u1 = 0,
            padding2: u1 = 0,
            padding3: u1 = 0,
            padding4: u1 = 0,
            padding5: u1 = 0,
            padding6: u1 = 0,
            padding7: u1 = 0,
            padding8: u1 = 0,
            padding9: u1 = 0,
            padding10: u1 = 0,
        }), base_address + 0xf0);

        /// address: 0xd00000f4
        /// Values written here are atomically added to ACCUM0\n
        /// Reading yields lane 0's raw shift and mask value (BASE0 not added).
        pub const INTERP1_ACCUM0_ADD = @intToPtr(*volatile MmioInt(32, u24), base_address + 0xf4);

        /// address: 0xd00000f8
        /// Values written here are atomically added to ACCUM1\n
        /// Reading yields lane 1's raw shift and mask value (BASE1 not added).
        pub const INTERP1_ACCUM1_ADD = @intToPtr(*volatile MmioInt(32, u24), base_address + 0xf8);

        /// address: 0xd00000fc
        /// On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.\n
        /// Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.
        pub const INTERP1_BASE_1AND0 = @intToPtr(*volatile u32, base_address + 0xfc);

        /// address: 0xd0000100
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK0 = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0xd0000104
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK1 = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0xd0000108
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK2 = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0xd000010c
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK3 = @intToPtr(*volatile u32, base_address + 0x10c);

        /// address: 0xd0000110
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK4 = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0xd0000114
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK5 = @intToPtr(*volatile u32, base_address + 0x114);

        /// address: 0xd0000118
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK6 = @intToPtr(*volatile u32, base_address + 0x118);

        /// address: 0xd000011c
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK7 = @intToPtr(*volatile u32, base_address + 0x11c);

        /// address: 0xd0000120
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK8 = @intToPtr(*volatile u32, base_address + 0x120);

        /// address: 0xd0000124
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK9 = @intToPtr(*volatile u32, base_address + 0x124);

        /// address: 0xd0000128
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK10 = @intToPtr(*volatile u32, base_address + 0x128);

        /// address: 0xd000012c
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK11 = @intToPtr(*volatile u32, base_address + 0x12c);

        /// address: 0xd0000130
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK12 = @intToPtr(*volatile u32, base_address + 0x130);

        /// address: 0xd0000134
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK13 = @intToPtr(*volatile u32, base_address + 0x134);

        /// address: 0xd0000138
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK14 = @intToPtr(*volatile u32, base_address + 0x138);

        /// address: 0xd000013c
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK15 = @intToPtr(*volatile u32, base_address + 0x13c);

        /// address: 0xd0000140
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK16 = @intToPtr(*volatile u32, base_address + 0x140);

        /// address: 0xd0000144
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK17 = @intToPtr(*volatile u32, base_address + 0x144);

        /// address: 0xd0000148
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK18 = @intToPtr(*volatile u32, base_address + 0x148);

        /// address: 0xd000014c
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK19 = @intToPtr(*volatile u32, base_address + 0x14c);

        /// address: 0xd0000150
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK20 = @intToPtr(*volatile u32, base_address + 0x150);

        /// address: 0xd0000154
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK21 = @intToPtr(*volatile u32, base_address + 0x154);

        /// address: 0xd0000158
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK22 = @intToPtr(*volatile u32, base_address + 0x158);

        /// address: 0xd000015c
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK23 = @intToPtr(*volatile u32, base_address + 0x15c);

        /// address: 0xd0000160
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK24 = @intToPtr(*volatile u32, base_address + 0x160);

        /// address: 0xd0000164
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK25 = @intToPtr(*volatile u32, base_address + 0x164);

        /// address: 0xd0000168
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK26 = @intToPtr(*volatile u32, base_address + 0x168);

        /// address: 0xd000016c
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK27 = @intToPtr(*volatile u32, base_address + 0x16c);

        /// address: 0xd0000170
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK28 = @intToPtr(*volatile u32, base_address + 0x170);

        /// address: 0xd0000174
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK29 = @intToPtr(*volatile u32, base_address + 0x174);

        /// address: 0xd0000178
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK30 = @intToPtr(*volatile u32, base_address + 0x178);

        /// address: 0xd000017c
        /// Reading from a spinlock address will:\n
        /// - Return 0 if lock is already locked\n
        /// - Otherwise return nonzero, and simultaneously claim the lock\n\n
        /// Writing (any value) releases the lock.\n
        /// If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
        /// wins.\n
        /// The value returned on success is 0x1 << lock number.
        pub const SPINLOCK31 = @intToPtr(*volatile u32, base_address + 0x17c);
    };
    pub const PPB = struct {
        pub const base_address = 0xe0000000;
        pub const version = "1";

        /// address: 0xe000ed20
        /// System handlers are a special class of exception handler that can have their
        /// priority set to any of the priority levels. Use the System Handler Priority
        /// Register 3 to set the priority of PendSV and SysTick.
        pub const SHPR3 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1 = 0,
            reserved1: u1 = 0,
            reserved2: u1 = 0,
            reserved3: u1 = 0,
            reserved4: u1 = 0,
            reserved5: u1 = 0,
            reserved6: u1 = 0,
            reserved7: u1 = 0,
            reserved8: u1 = 0,
            reserved9: u1 = 0,
            reserved10: u1 = 0,
            reserved11: u1 = 0,
            reserved12: u1 = 0,
            reserved13: u1 = 0,
            reserved14: u1 = 0,
            reserved15: u1 = 0,
            reserved16: u1 = 0,
            reserved17: u1 = 0,
            reserved18: u1 = 0,
            reserved19: u1 = 0,
            reserved20: u1 = 0,
            reserved21: u1 = 0,
            /// Priority of system handler 14, PendSV
            PRI_14: u2,
            reserved22: u1 = 0,
            reserved23: u1 = 0,
            reserved24: u1 = 0,
            reserved25: u1 = 0,
            reserved26: u1 = 0,
            reserved27: u1 = 0,
            /// Priority of system handler 15, SysTick
            PRI_15: u2,
        }), base_address + 0xed20);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub inline fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub inline fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub inline fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub inline fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub inline fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub inline fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

pub const InterruptVector = extern union {
    C: fn () callconv(.C) void,
    Naked: fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};
